# Function & argument definitions for cyto_plot --------------------------------

# cyto_plot with pass all of its arguments to the cyto_plot internal functions
# as a named list. The function which receives these arguments is determined
# based on the length of the supplied channels.

# ADDING NEW FEATURES TO CYTO_PLOT:
# 1. Add the argument to cyto_plot with an appropriate default. This will
# automatically be passed with all the other arguments to the internal plotting
# functions in a named list.
# 2. Modify the code in the called cyto_plot internal function to add the new
# feature. New arguments can be accessed form the argument list by name (e.g.
# args[["argument_name"]]).

# ARGUMENT CONVENTIONS:
# Arguments that can be replaced internally are set to missing by default and
# replaced if not assigned NA. Arguments that can be either supplied or not are
# set to NA by default.

# MISSING ARGUMENTS: (TURNING OFF PLOT ATTRIBUTES)
# Only arguments that allow manual off switching are set to missing, these
# include arguments such as title, xlab and ylab. Users setting these to NA will
# turn off these plot attributes. All other arguments that require user
# assignment are set to NA by default.

#' cyto_plot
#'
#' Explore & visualise cytometry data.
#'
#' \code{cyto_plot} is a cytometry visualisation tool built on base graphics
#' which supports all existing cytometry objects including
#' \code{\link[flowCore:flowFrame-class]{flowFrame}},
#' \code{\link[flowCore:flowSet-class]{flowSet}},
#' \code{\link[flowWorkspace:GatingHierarchy-class]{GatingHierarchy}} and
#' \code{\link[flowWorkspace:GatingSet-class]{GatingSet}} objects. The type of
#' plot constructed by \code{cyto_plot} is determined by the number of channels
#' supplied to the \code{channels} argument. If a single channel is supplied, a
#' 1-D density distribution will be plotted. Supplying two channels to this
#' argument will result in construction of a 2-D scatterplot with a blue-red
#' density colour scale for points.
#'
#' Some key features of \code{cyto_plot} include: \itemize{ \item autocomplete
#' friendly arguments \item minimal coding \item 1-D density distributions \item
#' 2-D scatterplots \item stacked density distributions \item 2-D contour lines
#' \item back-gating \item overlays \item population labelling \item grid to
#' visualise multiple samples \item plot gate objects \item plot in pop-up
#' windows \item sampling \item fully customisable \item copy and paste
#' arguments from gate_draw }
#'
#' @param x object of class \code{flowFrame}, \code{flowSet},
#'   \code{GatingHierarchy} or \code{GatingSet}.
#' @param ... additional method-specific arguments for cyto_plot.
#'
#' @seealso \code{\link{cyto_plot,flowFrame-method}}
#' @seealso \code{\link{cyto_plot,flowSet-method}}
#' @seealso \code{\link{cyto_plot,GatingHierarchy-method}}
#' @seealso \code{\link{cyto_plot,GatingSet-method}}
#'
#' @author Dillon Hammill, \email{Dillon.Hammill@anu.edu.au}
#'
#' @export
cyto_plot <- function(x, ...) {
  UseMethod("cyto_plot")
}

#' cyto_plot - flowFrame Method
#'
#' Explore & visualise a flowFrame.
#'
#' @param x object of class \code{\link[flowCore:flowFrame-class]{flowFrame}}.
#' @param channels name of the channel(s) or marker(s) to be used to construct
#'   the plot. The length of channels determines the type of plot to be
#'   constructed, either a 1-D density distribution for a single channel or a
#'   2-D scatterplot with blue-red colour scale for two channels.
#' @param axes_trans object of class
#'   \code{\link[flowCore:transformList-class]{transformList}} or
#'   \code{\link[flowWorkspace]{transformerList}} generated by
#'   \code{\link[flowCore:logicleTransform]{estimateLogicle}} which was used to
#'   transform the fluorescent channels of the supplied flowFrame. This
#'   transformation object will be used internally to ensure that the axes
#'   labels of the plot are appropriately transformed. The transformation object
#'   will NOT be applied to the flowFrame internally and should be applied to
#'   the flowFrame prior to plotting.
#' @param overlay name(s) of the populations to overlay or a \code{flowFrame},
#'   \code{flowSet}, \code{list of flowFrames}, \code{list of flowSets} or
#'   \code{list of flowFrame lists} containing populations to be overlaid onto
#'   the plot(s).
#' @param gate gate object(s) to be added to plot.  For \code{cyto_1d_plot} only
#'   gate objects of class
#'   \code{\link[flowCore:rectangleGate-class]{rectangleGate}} in either 1 or 2
#'   dimensions are supported. Multiple gates can be supplied either as a
#'   \code{list} or \code{\link[flowCore:filters-class]{filters}} object.
#' @param limits indicates whether the axes limits should be based on the
#'   \code{"data"} or \code{"machine"}, set to "machine" by default to show
#'   complete axes ranges. This argument will only alter the upper axis limits,
#'   to modify the lower limits use \code{xlim} and \code{ylim}.
#' @param display numeric [0,1] to control the percentage of events to be
#'   plotted. Specifying a value for \code{display} can substantial improve
#'   plotting speed for less powerful machines.
#' @param popup logical indicating whether the plot should be constructed in a
#'   pop-up window, set to FALSE by default. \code{popup} will open OS-specific
#'   graphic device prior to plotting. Mac users will need to install
#'   \href{https://www.xquartz.org/}{XQuartz} for this functionality.
#' @param xlim lower and upper limits of x axis (e.g. c(0,5)).
#' @param ylim lower and upper limits of y axis (e.g. c(0,5)).
#' @param xlab x axis label.
#' @param ylab y axis label.
#' @param title title to use for the plot, set to the name of the sample by
#'   default. Title can be removed by setting this argument to \code{NA}.
#' @param negate logical indicating whether a label should be included for the
#'   negated population if gate objects are supplied, set to FALSE by default.
#' @param density_modal logical indicating whether density should be normalised
#'   to mode and presented as a percentage for 1-D plots. Set to \code{TRUE} by
#'   default.
#' @param density_smooth smoothing parameter passed to
#'   \code{\link[stats:density]{density}} to adjust kernel density for 1-D
#'   plots.
#' @param density_stack numeric [0,1] indicating the degree of offset for 1-D
#'   density distributions with overlay, set to 0.5 by default.
#' @param density_cols vector colours to draw from when selecting density fill
#'   colours if none are supplied to density_fill.
#' @param density_fill fill colour(s) for 1-D density distributions.
#' @param density_fill_alpha numeric [0,1] used to control 1-D density fill
#'   colour transparency, set to 1 by default for solid colours.
#' @param density_line_type line type(s) to use for 1-D density lines, set to 1
#'   by default to use solid lines. See \code{\link[graphics:par]{lty}} for
#'   alternatives.
#' @param density_line_width numeric to control line width(s) for 1-D density
#'   lines, set to 1 by default.
#' @param density_line_col colour(s) for 1-D density lines, set to
#'   \code{"black"} by default.
#' @param point_shape shape(s) to use for points in 2-D scatterplots, set to
#'   \code{"."} by default to maximise plotting speed.  See
#'   \code{\link[graphics:par]{pch}} for alternatives.
#' @param point_size numeric to control the size of points in 2-D scatter plots
#'   set to 2 by default.
#' @param point_col_scale vector of ordered colours to use for the density
#'   colour gradient of points.
#' @param point_cols vector colours to draw from when selecting colours for
#'   points if none are supplied to point_col.
#' @param point_col colour(s) to use for points in 2-D scatter plots, set to NA
#'   by default to use a blue-red density colour scale.
#' @param point_col_alpha numeric [0,1] to control point colour transparency in
#'   2-D scatter plots, set to 1 by default to use solid colours.
#' @param contour_lines numeric indicating the number of levels to use for
#'   contour lines in 2-D scatter plots, set to 0 by default to turn off contour
#'   lines.
#' @param contour_line_type integer [0,6] to control the line type of contour
#'   lines in 2-D scatter plots, set to \code{1} to draw solid lines by default.
#'   See \code{\link[graphics:par]{lty}} for alternatives.
#' @param contour_line_width numeric to control line width(s) for contour lines
#'   in 2-D scatter plots, set to 2 by default.
#' @param contour_line_col colour(s) to use for contour lines in 2-D scatter
#'   plots, set to \code{"black"} by default.
#' @param axes_text logical vector of length 2 indicating whether axis text
#'   should be included for the x and y axes respectively, set to
#'   \code{c(TRUE,TRUE)} by default to display axes text on both axes.
#' @param axes_text_font numeric to control the font of axes text, set to 1 for
#'   plain font by default. See \code{\link[graphics:par]{font}} for
#'   alternatives.
#' @param axes_text_size numeric to control the size of axes text, set to 1 by
#'   default.
#' @param axes_text_col colour to use for axes text, set to \code{"black"} by
#'   default.
#' @param axes_label_text_font numeric to control the font axes labels, set to 1
#'   for plain font by default. See \code{\link[graphics:par]{font}} for
#'   alternatives.
#' @param axes_label_text_size numeric to control the text size of axes labels,
#'   set to 1.1 by default.
#' @param axes_label_text_col colour to use for axes labels text, set to
#'   \code{"black"} by default.
#' @param title_text_font numeric to control the font of title text, set to 2
#'   for bold font by default. See \code{\link[graphics:par]{font}} for
#'   alternatives.
#' @param title_text_size numeric to control the text size of the plot title,
#'   set to 1.1 by default.
#' @param title_text_col colour to use for plot title text, set to
#'   \code{"black"} by default.
#' @param legend can be either \code{"line"} or \code{"fill"} to indicate
#'   whether a legend should be constructed based on the density \code{"line"}
#'   or \code{"fill"}, set to FALSE by default to remove the legend.
#' @param legend_text vector of labels to use in the legend.
#' @param legend_text_font numeric to control the font of legend text, set to 1
#'   for plain font by default. See \code{\link[graphics:par]{font}} for
#'   alternatives.
#' @param legend_text_size numeric to control the size of text in the legend,
#'   set to 1 by default.
#' @param legend_text_col colour(s) to use for text in legend, set to
#'   \code{"black"} by default.
#' @param legend_line_col colour(s) to use for the lines in 1-D plot legends
#'   when legend is set to \code{"line"}.
#' @param legend_box_fill fill colour(s) to use for the boxes in 1-D plot
#'   legends when legend is set to \code{"fill"}.
#' @param legend_point_col colour(s) to use for points in 2-D scatter plot
#'   legend.
#' @param gate_line_type integer [0,6] to control the line type of gates, set to
#'   \code{1} to draw solid lines by default. See
#'   \code{\link[graphics:par]{lty}} for alternatives.
#' @param gate_line_width numeric to control the line width(s) of gates, set to
#'   \code{2.5} by default.
#' @param gate_line_col colour(s) to use for gates, set to \code{"red"} by
#'   default.
#' @param gate_fill fill colour(s) to use for gates, set to "white by default.
#' @param gate_fill_alpha numeric to control the fill transparency of gates, set
#'   to 0 by default to remove fill colour(s).
#' @param label logical indicating whether gated populations should be labelled.
#'   To include the names of the populations in these labels, supply the
#'   population names to the \code{label_text} argument. The default statistic
#'   is \code{"percent"} for gated data and \code{"count"} for un-gated data.
#'   This argument must be set to TRUE in order to add labels with gates.
#' @param label_text vector of population names to use in the labels.
#' @param label_stat indicates the type of statistic to include in the plot
#'   labels, can be \code{"percent"}, \code{"count"}, \code{"mean"},
#'   \code{"median"}, \code{"mode"} or \code{"geo mean"}, set to
#'   \code{"percent"} for gated data or \code{NA} to exclude statistics for
#'   un-gated data. Currently, only \code{"percent"} and \code{"count"} are
#'   supported for 2-D scatter plots.
#' @param label_position either "auto" or "manual". The "auto" option (default)
#'   positions labels will be placed in the center of gates and offset if
#'   necessary. The "manual" option will allow label positioning by mouse click.
#'   Label positions are set on a per gate basis, all samples in the same group
#'   will have the same label positions. To individually label plots users must
#'   manually supply the co-ordinates to label_text_x and label_text_y.
#' @param label_text_x vector of x co-ordinate(s) to manually adjust the
#'   position plot label(s) on the plot. To interactively position labels set
#'   either \code{label_text_x} or \code{label_text_y} to "select".
#' @param label_text_y vector of y co-ordinate(s) to manually adjust the
#'   position plot label(s) on the plot. To interactively position labels set
#'   either \code{label_text_x} or \code{label_text_y} to "select".
#' @param label_text_font numeric to control the font of text in plot labels,
#'   set to 2 for bold font by default. See \code{\link[graphics:par]{font}} for
#'   alternatives.
#' @param label_text_size numeric to control the size of text in the plot
#'   labels, set to 1 by default.
#' @param label_text_col colour(s) to use for text in plot labels, set to
#'   \code{"black"} by default.
#' @param label_fill fill colour(s) to use for labels, set to "white" by
#'   default.
#' @param label_fill_alpha numeric to control background fill transparency of
#'   label, set to 0.6 by default to introduce some transparency.
#' @param border_line_type integer [0,6] to control the line type of plot
#'   border, set to \code{1} by default for a solid border. See
#'   \code{\link[graphics:par]{lty}} for alternatives.
#' @param border_line_width numeric to control line width for the plot border,
#'   set to 1 by default.
#' @param border_line_col colour to use for the plot border, set to "black" by
#'   default.
#' @param border_fill border_fill fill colour to use inside the plot border
#'   (i.e. background colour), set to "white" by default.
#' @param border_fill_alpha transparency to use for border_fill colour, set to 1
#'   by default for no transparency.
#' @param ... additional arguments not currently in use.
#'
#' @examples
#' library(CytoRSuiteData)
#'
#' # Load in samples
#' fs <- Activation
#'
#' # Apply compensation
#' fs <- compensate(fs, fs[[1]]@description$SPILL)
#'
#' # Transform fluorescent channels
#' trans <- estimateLogicle(fs[[4]], cyto_fluor_channels(fs))
#' fs <- transform(fs, trans)
#'
#' # 1-D Density Distribution
#' cyto_plot(fs[[1]],
#'   channels = "PE-A",
#'   axes_trans = trans,
#'   overlay = fs[2:4],
#'   density_stack = 0.5
#' )
#'
#' # 2-D Scatter Plot
#' cyto_plot(fs[[4]],
#'   channels = c("FSC-A", "PE-A"),
#'   axes_trans = trans,
#'   overlay = fs[[1]]
#' )
#' @importFrom flowWorkspace getGate getData sampleNames getTransformations
#'   sampleNames pData getNodes
#' @importFrom flowCore flowSet identifier
#' @importFrom openCyto templateGen
#' @importFrom grDevices recordPlot
#' @importFrom methods formalArgs
#' @importFrom purrr transpose pmap
#'
#' @seealso \code{\link{cyto_plot,flowFrame-method}}
#' @seealso \code{\link{cyto_plot,flowSet-method}}
#' @seealso \code{\link{cyto_plot,GatingHierarchy-method}}
#'
#' @author Dillon Hammill, \email{Dillon.Hammill@anu.edu.au}
#'
#' @export
cyto_plot.flowFrame <- function(x,
                                channels,
                                axes_trans = NA,
                                overlay = NA,
                                gate = NA,
                                limits = "machine",
                                display = 1,
                                popup = FALSE,
                                xlim = NA,
                                ylim = NA,
                                xlab,
                                ylab,
                                title,
                                negate = FALSE,
                                density_modal = TRUE,
                                density_smooth = 0.6,
                                density_stack = 0.5,
                                density_cols = NA,
                                density_fill = NA,
                                density_fill_alpha = 1,
                                density_line_type = 1,
                                density_line_width = 1,
                                density_line_col = "black",
                                point_shape = ".",
                                point_size = 2,
                                point_col_scale = NA,
                                point_cols = NA,
                                point_col = NA,
                                point_col_alpha = 1,
                                contour_lines = 0,
                                contour_line_type = 1,
                                contour_line_width = 1,
                                contour_line_col = "black",
                                axes_text = c(TRUE, TRUE),
                                axes_text_font = 1,
                                axes_text_size = 1,
                                axes_text_col = "black",
                                axes_label_text_font = 1,
                                axes_label_text_size = 1.1,
                                axes_label_text_col = "black",
                                title_text_font = 2,
                                title_text_size = 1.1,
                                title_text_col = "black",
                                legend = FALSE,
                                legend_text = NA,
                                legend_text_font = 1,
                                legend_text_size = 1,
                                legend_text_col = "black",
                                legend_line_type = NA,
                                legend_line_width = NA,
                                legend_line_col = NA,
                                legend_box_fill = NA,
                                legend_point_col = NA,
                                gate_line_type = 1,
                                gate_line_width = 2.5,
                                gate_line_col = "red",
                                gate_fill = "white",
                                gate_fill_alpha = 0,
                                label,
                                label_text,
                                label_stat,
                                label_position = "auto",
                                label_text_x = NA,
                                label_text_y = NA,
                                label_text_font = 2,
                                label_text_size = 1,
                                label_text_col = "black",
                                label_fill = "white",
                                label_fill_alpha = 0.6,
                                border_line_type = 1,
                                border_line_width = 1,
                                border_line_col = "black",
                                border_fill = "white",
                                border_fill_alpha = 1, ...) {
  
  # Checks ---------------------------------------------------------------------
  
  # Set plot method - determine when dev.off should be called when saving
  if (is.null(getOption("CytoRSuite_cyto_plot_method"))) {
    options("CytoRSuite_cyto_plot_method" = "flowFrame")
  }
  
  # Check if channels are supplied
  if (missing(channels)) {
    stop("Supply channel/marker(s) to construct the plot.")
  }
  
  # cyto_plot_theme ------------------------------------------------------------
  
  # Remember all missing arguments now converted to "" (use .empty())
  
  # Pull down arguments to named list
  args <- .args_list()
  
  # Inherit arguments from cyto_plot_theme
  args <- .cyto_plot_theme_inherit(args)
  
  # Update arguments
  .args_update(args)
  
  # cyto_plot_save -------------------------------------------------------------
  
  # Turn off popup if cyto_plot_save is activated
  if (getOption("CytoRSuite_cyto_plot_save") == TRUE) {
    popup <- FALSE
  }
  
  # Extract channels & transformations -----------------------------------------
  
  # Get valid channel names if markers are supplied
  channels <- cyto_channels_extract(x, channels, plot = TRUE)
  
  # transformerList required
  if (!.all_na(axes_trans)) {
    if(inherits(axes_trans, "transformList")){
      axes_trans <- NA
      message("Supply a transformerList object to axes_trans to transform axes.")
    }
  }
  
  # Extract & format data for plotting (list of flowFrames) ---------------
  
  # Add flowFrame to list
  fr_list <- list(x)
  names(fr_list) <- identifier(x)
  
  # Add overlay to list and group if necessary
  if (!.all_na(overlay)) {
    
    # overlay must be list of flowFrames
    
    # flowFrame overlay added to list
    if (inherits(overlay, "flowFrame")) {
      overlay_list <- list(overlay)
      
      # flowSet overlay convert to list of flowFrames
    } else if (inherits(overlay, "flowSet")) {
      overlay_list <- cyto_convert(overlay, "list of flowFrames")
      
      # flowFrame list overlay as is - flowSet list overlay use overlay[[1]]
    } else if (inherits(overlay, "list")) {
      
      # overlay should be list of flowFrames
      if (all(LAPPLY(overlay, function(z) {
        inherits(z, "flowFrame")
      }))) {
        overlay_list <- overlay
        # overlay list of flowSets - use first fs convert to list of flowFrames
      } else if (all(LAPPLY(overlay, function(z) {
        inherits(z, "flowSet")
      }))) {
        overlay <- overlay[[1]]
        overlay_list <- cyto_convert(overlay, "list of flowFrames")
        # overlay not supported
      } else {
        stop(paste(
          "'overlay' should be either the names of the populations to",
          "overlay, a flowFrame, a flowSet or a list of flowFrames."
        ))
      }
    }
  }
  
  # Combine base layers with overlay into list of flowFrames
  if (!.all_na(overlay)) {
    fr_list <- c(fr_list, overlay_list)
  }
  
  # Prepare arguments for plotting ---------------------------------------------
  
  # Legend text - names of fr_list[[i]]
  if (.all_na(legend_text)) {
    legend_text <- LAPPLY(fr_list, function(z) {
      nm <- identifier(z)
      if(nm == "anonymous"){
        nm <- "Combined Events"
      }
      return(nm)
    })
  }
  
  # Title
  if (.empty(title)) {
    
    # Title is sampleName of x
    title <- identifier(x)
    
    # Convert anonymous to "Combined Events"
    if(title == "anonymous"){
      title <- "Combined Events"
    }
    
    # Remove title for stacked density distributions
    if (length(channels) == 1 & 
        length(fr_list) > 1 & 
        density_stack != 0) {
      title <- NA
    }
    
  }
  
  # Label text
  if(.empty(label_text)){
    label_text <- NA
  }
  
  # X axis breaks and labels - pass through axes_text argument
  if (axes_text[1] == TRUE) {
    axes_text_x <- .cyto_plot_axes_text(x,
                                        channels = channels,
                                        axes_trans = axes_trans
    )[[1]]
  } else {
    axes_text_x <- FALSE
  }
  
  # Y axis breaks and labels - pass through axes_text argument
  if (axes_text[2] == TRUE) {
    if (length(channels) == 2) {
      axes_text_y <- .cyto_plot_axes_text(x,
                                          channels = channels[2],
                                          axes_trans = axes_trans
      )[[1]]
    } else {
      axes_text_y <- NA
    }
  } else {
    axes_text_y <- FALSE
  }
  axes_text <- list(axes_text_x, axes_text_y)
  
  # X axis limits
  if (.all_na(xlim)) {
    xlim <- .cyto_range(fr_list,
                        channels = channels[1],
                        limits = limits,
                        plot = TRUE
    )[, 1]
  }
  
  # Y axis limits - 1D y limit calculated downstream
  if (.all_na(ylim) & length(channels) != 1) {
    ylim <- .cyto_range(fr_list,
                        channels = channels[2],
                        limits = limits,
                        plot = TRUE
    )[, 1]
  }
  
  # GRAPHICS DEVICE
  if(popup == TRUE){
    cyto_plot_new(popup)
  }
  
  # Repeat arguments as required -----------------------------------------------
  
  # Pull down arguments to named list - missing converted to ""
  args <- .args_list()
  
  # Repeat arguments as required using .cyto_plot_args_split
  args <- .cyto_plot_args_split(args,
                                channels = channels,
                                n = length(fr_list),
                                plots = 1,
                                layers = length(fr_list),
                                gates = length(unlist(gate))
  )
  
  # Unlist arguments modified by .cyto_plot_args_split
  lapply(.cyto_plot_args(), function(z){
    args[[z]] <<- args[[z]][[1]]
  })
  
  # Update arguments
  .args_update(args)
  
  # Check if current call is the same as previous call -------------------------
  
  previous_call <- getOption("CytoRSuite_cyto_plot_call")
  current_call <- list(x,
                       channels,
                       gate,
                       label,
                       label_text,
                       label_position)
  names(current_call) <- c("data",
                           "channels",
                           "gate",
                           "label",
                           "label_text",
                           "label_position")
    
  print(previous_call)
  print(current_call)
  print(identical(previous_call, current_call))
  print(getOption("CytoRSuite_cyto_plot_save"))
  
  # Reset saved gates and labels if cyto_plot_save and calls match
  if(identical(previous_call, current_call) |
     getOption("CytoRSuite_cyto_plot_save") == FALSE){
      
    # Reset saved gates
    options("CytoRSuite_cyto_plot_gates" = NULL)
      
    # Reset saved label co-ordinates
    options("CytoRSuite_cyto_plot_labels" = NULL)

  }
  
  # Update previous call -
  options("CytoRSuite_cyto_plot_call" = current_call)
  
  # Organise gates -------------------------------------------------------------
  
  # Must be list of gate objects
  if(!.all_na(gate)){
    if(class(gate) %in% c("rectangleGate","polygonGate","ellipsoidGate")){
      # Add gate to list
      gate <- list(gate)
    }else if(class(gate) == "filters"){
      gate <- unlist(gate)
    }else if(class(gate) == "list"){
      # list of valid gate objects
      if(all(LAPPLY(gates, "class") %in% c("rectangleGate",
                                                   "polygonGate",
                                                   "ellipsoidGate",
                                                   "filters"))){
        # extract gate objects from filters
        gate <- unlist(gate)
      }else if(all(LAPPLY(gates, "class") == "list")){
        # list of gate object lists supplied - use first element
        gate <- unlist(gate[[1]])
      }
    }
  }
  
  # Prepare gates for 1D plots with overlays
  if(!.all_na(overlay)){
    # Repeat gates per layer
    gate <- rep(list(gate), length(fr_list))
    # Convert any 2D gates to 1D gates
    
  }
  
  # Save gates globally --------------------------------------------------------
  
  # Gates have not been assigned globally - list of gate lists 1 per sample
  if(is.null(getOption("CytoRSuite_cyto_plot_gates"))){
    # Assign gates
    if(!.all_na(gate)){
      # Assign globally - list of gate lists 1 per sample
      if(length(channels) == 2){
        options("CytoRSuite_cyto_plot_gates" = list(gate))
      # Only 1 layer no need to repeat saved gates
      }else if(length(channels) == 1 & .all_na(overlay)){
        options("CytoRSuite_cyto_plot_gates" = list(gate))
      # Repeat saved gates to get one per layer
      }else if(length(channels) == 1 &
               !.all_na(overlay) & 
               density_stack != 0){
        options("CytoRSuite_cyto_plot_gates" = rep(list(gate)), length(fr_list))
      }
      
    }
    
  }
  
  # Manual label co-ordinate selection -----------------------------------------
  
  # Manual label positioning sets label_text_x and label_text_y to "select"
  if(label_position == "manual"){
    
    # Either all coords manually supplied or must be manually selected
    if(!all(is.numeric(c(label_text_x,label_text_y)))){
      label_text_x <- rep("select", length(label_text_x))
      label_text_y <- rep("select", length(label_text_y))
    }

  }
  
  # Organise global option for saving label coords -----------------------------
  
  # Gates
  if(!.all_na(gate)){
    # One set of label coords per gate
    if(is.null(getOption("CytoRSuite_cyto_plot_labels"))){
      # Prepare empty list for saving label coords later
      gts <- length(getOption("CytoRSuite_cyto_plot_gates"))
      options("CytoRSuite_cyto_plot_labels" = rep(list(list()), gts))
    }
  # No gates  
  }else{
    # One set of label coords per label
    if(is.null(getOption("CytoRSuite_cyto_plot_labels"))){
      # Prepare empty list for saving label coords later
      lbls <- length(label_text)
      options("CytoRSuite_cyto_plot_labels" = rep(list(list()), lbls))
    }
  }
  
  # Inherit saved label coords -------------------------------------------------
  
  # Pull down saved label coords
  saved_label_coords <- getOption("CytoRSuite_cyto_plot_labels")
  
  # Only inherit saved labels if calls match and saving is not activated
  if(identical(previous_call, current_call) &
     getOption("CytoRSuite_cyto_plot_save") == TRUE){
    
    # Each saved element is a data frame of coords per layer
    if(!is.null(unlist(getOption("CytoRSuite_cyto_plot_labels")))){
      label_text_x <- lapply(saved_label_coords, function(z){z[,1]})
      label_text_y <- lapply(saved_label_coords, function(z){z[,2]})
    }
    
  }
  
  print(label_text_x)
  print(label_text_y)
  
  # Calls to .cyto_plot internal -----------------------------------------------
  
  # Pass arguments to .cyto_plot to construct plot
  .cyto_plot(fr_list,
             channels = channels,
             gate = gate,
             axes_trans = axes_trans,
             limits = limits,
             display = display,
             popup = popup,
             xlim = xlim,
             ylim = ylim,
             xlab = xlab,
             ylab = ylab,
             title = title,
             negate = negate,
             title_text_font = title_text_font,
             title_text_size = title_text_size,
             title_text_col = title_text_col,
             density_modal = density_modal,
             density_smooth = density_smooth,
             density_stack = density_stack,
             density_cols = density_cols,
             density_fill = density_fill,
             density_fill_alpha = density_fill_alpha,
             density_line_type = density_line_type,
             density_line_width = density_line_width,
             density_line_col = density_line_col,
             point_shape = point_shape,
             point_size = point_size,
             point_col_scale = point_col_scale,
             point_cols = point_cols,
             point_col = point_col,
             point_col_alpha = point_col_alpha,
             contour_lines = contour_lines,
             contour_line_type = contour_line_type,
             contour_line_width = contour_line_width,
             contour_line_col = contour_line_col,
             axes_text = axes_text,
             axes_text_font = axes_text_font,
             axes_text_size = axes_text_size,
             axes_text_col = axes_text_col,
             axes_label_text_font = axes_label_text_font,
             axes_label_text_size = axes_label_text_size,
             axes_label_text_col = axes_label_text_col,
             legend = legend,
             legend_text = legend_text,
             legend_text_font = legend_text_font,
             legend_text_size = legend_text_size,
             legend_text_col = legend_text_col,
             legend_line_type = legend_line_type,
             legend_line_width = legend_line_width,
             legend_line_col = legend_line_col,
             legend_box_fill = legend_box_fill,
             legend_point_col = legend_point_col,
             gate_line_type = gate_line_type,
             gate_line_width = gate_line_width,
             gate_line_col = gate_line_col,
             gate_fill = gate_fill,
             gate_fill_alpha = gate_fill_alpha,
             label = label,
             label_text = label_text,
             label_stat = label_stat,
             label_position = label_position,
             label_text_x = label_text_x,
             label_text_y = label_text_y,
             label_text_font = label_text_font,
             label_text_size = label_text_size,
             label_text_col = label_text_col,
             label_fill = label_fill,
             label_fill_alpha = label_fill_alpha,
             border_line_type = border_line_type,
             border_line_width = border_line_width,
             border_line_col = border_line_col,
             border_fill = border_fill,
             border_fill_alpha = border_fill_alpha
  )
  
  # Record and/or save ---------------------------------------------------------
  
  # Turn off graphics device for saving
  if (getOption("CytoRSuite_cyto_plot_save")) {
    if (inherits(x, getOption("CytoRSuite_cyto_plot_method"))) {
      if (!getOption("CytoRSuite_cyto_plot_custom")) {
        
        # Close graphics device
        dev.off()
      }
      
      # Reset CytoRSuite_cyto_plot_save
      options("CytoRSuite_cyto_plot_save" = FALSE)
      
      # Reset CytoRSuite_cyto_plot_method
      options("cytoRSuite_cyto_plot_method" = NULL)
      
      # Reset custom plotting flag
      options("CytoRSuite_cyto_plot_custom")
    }
  }
  
  # Record plot for assignment
  invisible(recordPlot())
}

#' cyto_plot - flowSet Method
#'
#' Explore & visualise a flowSet.
#'
#' @param x object of class \code{\link[flowCore:flowSet-class]{flowSet}}.
#' @param channels name of the channel(s) or marker(s) to be used to construct
#'   the plot. The length of channels determines the type of plot to be
#'   constructed, either a 1-D density distribution for a single channel or a
#'   2-D scatterplot with blue-red colour scale for two channels.
#' @param axes_trans object of class
#'   \code{\link[flowCore:transformList-class]{transformList}} or
#'   \code{\link[flowWorkspace]{transformerList}} generated by
#'   \code{\link[flowCore:logicleTransform]{estimateLogicle}} which was used to
#'   transform the fluorescent channels of the supplied flowFrame. This
#'   transformation object will be used internally to ensure that the axes
#'   labels of the plot are appropriately transformed. The transformation object
#'   will NOT be applied to the flowFrame internally and should be applied to
#'   the flowFrame prior to plotting.
#' @param group_by a vector of pData variables to sort and merge samples into
#'   groups prior to plotting, set to NULL by default to prevent merging. To
#'   merge all samples set this argument to \code{TRUE} or \code{"all"}.
#' @param overlay name(s) of the populations to overlay or a \code{flowFrame},
#'   \code{flowSet}, \code{list of flowFrames}, \code{list of flowSets} or
#'   \code{list of flowFrame lists} containing populations to be overlaid onto
#'   the plot(s).
#' @param gate gate object(s) to be added to plot.  For \code{cyto_1d_plot} only
#'   gate objects of class
#'   \code{\link[flowCore:rectangleGate-class]{rectangleGate}} in either 1 or 2
#'   dimensions are supported. Multiple gates can be supplied either as a
#'   \code{list} or \code{\link[flowCore:filters-class]{filters}} object.
#' @param limits indicates whether the axes limits should be based on the
#'   \code{"data"} or \code{"machine"}, set to "machine" by default to show
#'   complete axes ranges. This argument will only alter the upper axis limits,
#'   to modify the lower limits use \code{xlim} and \code{ylim}.
#' @param display numeric [0,1] to control the percentage of events to be
#'   plotted. Specifying a value for \code{display} can substantial improve
#'   plotting speed for less powerful machines.
#' @param layout a vector of the length 2 indicating the dimensions of the grid
#'   for plotting \code{c(#rows, #columns)}.
#' @param popup logical indicating whether the plot should be constructed in a
#'   pop-up window, set to FALSE by default. \code{popup} will open OS-specific
#'   graphic device prior to plotting. Mac users will need to install
#'   \href{https://www.xquartz.org/}{XQuartz} for this functionality.
#' @param xlim lower and upper limits of x axis (e.g. c(0,5)).
#' @param ylim lower and upper limits of y axis (e.g. c(0,5)).
#' @param xlab x axis label.
#' @param ylab y axis label.
#' @param title title to use for the plot, set to the name of the sample by
#'   default. Title can be removed by setting this argument to \code{NA}.
#' @param negate logical indicating whether a label should be included for the
#'   negated population when gate objects are supplied, set to FALSE by default.
#' @param density_modal logical indicating whether density should be normalised
#'   to mode and presented as a percentage for 1-D plots. Set to \code{TRUE} by
#'   default.
#' @param density_smooth smoothing parameter passed to
#'   \code{\link[stats:density]{density}} to adjust kernel density for 1-D
#'   plots.
#' @param density_stack numeric [0,1] indicating the degree of offset for 1-D
#'   density distributions with overlay, set to 0.5 by default.
#' @param density_layers numeric indicating the number of samples to stack in
#'   each plot, set to all samples by default.
#' @param density_cols vector colours to draw from when selecting density fill
#'   colours if none are supplied to density_fill.
#' @param density_fill fill colour(s) for 1-D density distributions.
#' @param density_fill_alpha numeric [0,1] used to control 1-D density fill
#'   colour transparency, set to 1 by default for solid colours.
#' @param density_line_type line type(s) to use for 1-D density lines, set to 1
#'   by default to use solid lines. See \code{\link[graphics:par]{lty}} for
#'   alternatives.
#' @param density_line_width numeric to control line width(s) for 1-D density
#'   lines, set to 1 by default.
#' @param density_line_col colour(s) for 1-D density lines, set to
#'   \code{"black"} by default.
#' @param point_shape shape(s) to use for points in 2-D scatterplots, set to
#'   \code{"."} by default to maximise plotting speed.  See
#'   \code{\link[graphics:par]{pch}} for alternatives.
#' @param point_size numeric to control the size of points in 2-D scatter plots
#'   set to 2 by default.
#' @param point_col_scale vector of ordered colours to use for the density
#'   colour gradient of points.
#' @param point_cols vector colours to draw from when selecting colours for
#'   points if none are supplied to point_col.
#' @param point_col colour(s) to use for points in 2-D scatter plots, set to NA
#'   by default to use a blue-red density colour scale.
#' @param point_col_alpha numeric [0,1] to control point colour transparency in
#'   2-D scatter plots, set to 1 by default to use solid colours.
#' @param contour_lines numeric indicating the number of levels to use for
#'   contour lines in 2-D scatter plots, set to 0 by default to turn off contour
#'   lines.
#' @param contour_line_type integer [0,6] to control the line type of contour
#'   lines in 2-D scatter plots, set to \code{1} to draw solid lines by default.
#'   See \code{\link[graphics:par]{lty}} for alternatives.
#' @param contour_line_width numeric to control line width(s) for contour lines
#'   in 2-D scatter plots, set to 2 by default.
#' @param contour_line_col colour(s) to use for contour lines in 2-D scatter
#'   plots, set to \code{"black"} by default.
#' @param axes_text logical vector of length 2 indicating whether axis text
#'   should be included for the x and y axes respectively, set to
#'   \code{c(TRUE,TRUE)} by default to display axes text on both axes.
#' @param axes_text_font numeric to control the font of axes text, set to 1 for
#'   plain font by default. See \code{\link[graphics:par]{font}} for
#'   alternatives.
#' @param axes_text_size numeric to control the size of axes text, set to 1 by
#'   default.
#' @param axes_text_col colour to use for axes text, set to \code{"black"} by
#'   default.
#' @param axes_label_text_font numeric to control the font axes labels, set to 1
#'   for plain font by default. See \code{\link[graphics:par]{font}} for
#'   alternatives.
#' @param axes_label_text_size numeric to control the text size of axes labels,
#'   set to 1.1 by default.
#' @param axes_label_text_col colour to use for axes labels text, set to
#'   \code{"black"} by default.
#' @param title_text_font numeric to control the font of title text, set to 2
#'   for bold font by default. See \code{\link[graphics:par]{font}} for
#'   alternatives.
#' @param title_text_size numeric to control the text size of the plot title,
#'   set to 1.1 by default.
#' @param title_text_col colour to use for plot title text, set to
#'   \code{"black"} by default.
#' @param legend can be either \code{"line"} or \code{"fill"} to indicate
#'   whether a legend should be constructed based on the density \code{"line"}
#'   or \code{"fill"}, set to FALSE by default to remove the legend.
#' @param legend_text vector of labels to use in the legend.
#' @param legend_text_font numeric to control the font of legend text, set to 1
#'   for plain font by default. See \code{\link[graphics:par]{font}} for
#'   alternatives.
#' @param legend_text_size numeric to control the size of text in the legend,
#'   set to 1 by default.
#' @param legend_text_col colour(s) to use for text in legend, set to
#'   \code{"black"} by default.
#' @param legend_line_col colour(s) to use for the lines in 1-D plot legends
#'   when legend is set to \code{"line"}.
#' @param legend_box_fill fill colour(s) to use for the boxes in 1-D plot
#'   legends when legend is set to \code{"fill"}.
#' @param legend_point_col colour(s) to use for points in 2-D scatter plot
#'   legend.
#' @param gate_line_type integer [0,6] to control the line type of gates, set to
#'   \code{1} to draw solid lines by default. See
#'   \code{\link[graphics:par]{lty}} for alternatives.
#' @param gate_line_width numeric to control the line width(s) of gates, set to
#'   \code{2.5} by default.
#' @param gate_line_col colour(s) to use for gates, set to \code{"red"} by
#'   default.
#' @param gate_fill fill colour(s) to use for gates, set to "white by default.
#' @param gate_fill_alpha numeric to control the fill transparency of gates, set
#'   to 0 by default to remove fill colour(s).
#' @param label logical indicating whether gated populations should be labelled.
#'   To include the names of the populations in these labels, supply the
#'   population names to the \code{label_text} argument. The default statistic
#'   is \code{"percent"} for gated data and \code{"count"} for un-gated data.
#'   This argument must be set to TRUE in order to add labels with gates.
#' @param label_text vector of population names to use in the labels.
#' @param label_stat indicates the type of statistic to include in the plot
#'   labels, can be \code{"percent"}, \code{"count"}, \code{"mean"},
#'   \code{"median"}, \code{"mode"} or \code{"geo mean"}, set to
#'   \code{"percent"} for gated data or \code{NA} to exclude statistics for
#'   un-gated data. Currently, only \code{"percent"} and \code{"count"} are
#'   supported for 2-D scatter plots.
#' @param label_position either "auto" or "manual". The "auto" option (default)
#'   positions labels will be placed in the center of gates and offset if
#'   necessary. The "manual" option will allow label positioning by mouse click.
#'   Label positions are set on a per gate basis, all samples in the same group
#'   will have the same label positions. To individually label plots users must
#'   manually supply the co-ordinates to label_text_x and label_text_y.
#' @param label_text_x vector of x co-ordinate(s) to manually adjust the
#'   position plot label(s) on the plot. To interactively position labels set
#'   either \code{label_text_x} or \code{label_text_y} to "select".
#' @param label_text_y vector of y co-ordinate(s) to manually adjust the
#'   position plot label(s) on the plot. To interactively position labels set
#'   either \code{label_text_x} or \code{label_text_y} to "select".
#' @param label_text_font numeric to control the font of text in plot labels,
#'   set to 2 for bold font by default. See \code{\link[graphics:par]{font}} for
#'   alternatives.
#' @param label_text_size numeric to control the size of text in the plot
#'   labels, set to 1 by default.
#' @param label_text_col colour(s) to use for text in plot labels, set to
#'   \code{"black"} by default.
#' @param label_fill fill colour(s) to use for labels, set to "white" by
#'   default.
#' @param label_fill_alpha numeric to control background fill transparency of
#'   label, set to 0.6 by default to introduce some transparency.
#' @param border_line_type integer [0,6] to control the line type of plot
#'   border, set to \code{1} by default for a solid border. See
#'   \code{\link[graphics:par]{lty}} for alternatives.
#' @param border_line_width numeric to control line width for the plot border,
#'   set to 1 by default.
#' @param border_line_col colour to use for the plot border, set to "black" by
#'   default.
#' @param border_fill border_fill fill colour to use inside the plot border
#'   (i.e. background colour), set to "white" by default.
#' @param border_fill_alpha transparency to use for border_fill colour, set to 1
#'   by default for no transparency.
#' @param ... additional arguments not currently in use.
#'
#' @examples
#' library(CytoRSuiteData)
#'
#' # Load in samples
#' fs <- Activation
#'
#' # Apply compensation
#' fs <- compensate(fs, fs[[1]]@description$SPILL)
#'
#' # Transform fluorescent channels
#' trans <- estimateLogicle(fs[[4]], cyto_fluor_channels(fs))
#' fs <- transform(fs, trans)
#'
#' # 1-D Density Distribution
#' cyto_plot(fs,
#'   channels = c("PE-A"),
#'   axes_trans = trans,
#'   overlay = fs[[1]],
#'   density_stack = 0.4
#' )
#'
#' # 2-D Scatter Plot with Contour Lines
#' cyto_plot(fs,
#'   channels = c("Alexa Fluor 700-A", "PE-A"),
#'   axes_trans = trans,
#'   contour_lines = 15
#' )
#' @importFrom flowWorkspace getGate getData sampleNames getTransformations
#'   sampleNames pData getNodes
#' @importFrom flowCore flowSet identifier
#' @importFrom openCyto templateGen
#' @importFrom grDevices recordPlot
#' @importFrom methods formalArgs
#' @importFrom purrr transpose pmap
#'
#' @seealso \code{\link{cyto_plot,flowFrame-method}}
#' @seealso \code{\link{cyto_plot,GatingHierarchy-method}}
#' @seealso \code{\link{cyto_plot,GatingSet-method}}
#'
#' @author Dillon Hammill, \email{Dillon.Hammill@anu.edu.au}
#'
#' @export
cyto_plot.flowSet <- function(x,
                              channels,
                              axes_trans = NA,
                              group_by = NA,
                              overlay = NA,
                              gate = NA,
                              limits = "machine",
                              display = 1,
                              layout,
                              popup = FALSE,
                              xlim = NA,
                              ylim = NA,
                              xlab,
                              ylab,
                              title,
                              negate = FALSE,
                              density_modal = TRUE,
                              density_smooth = 0.6,
                              density_stack = 0.5,
                              density_layers = NA,
                              density_cols = NA,
                              density_fill = NA,
                              density_fill_alpha = 1,
                              density_line_type = 1,
                              density_line_width = 1,
                              density_line_col = "black",
                              point_shape = ".",
                              point_size = 2,
                              point_col_scale = NA,
                              point_cols = NA,
                              point_col = NA,
                              point_col_alpha = 1,
                              contour_lines = 0,
                              contour_line_type = 1,
                              contour_line_width = 1,
                              contour_line_col = "black",
                              axes_text = c(TRUE, TRUE),
                              axes_text_font = 1,
                              axes_text_size = 1,
                              axes_text_col = "black",
                              axes_label_text_font = 1,
                              axes_label_text_size = 1.1,
                              axes_label_text_col = "black",
                              title_text_font = 2,
                              title_text_size = 1.1,
                              title_text_col = "black",
                              legend = FALSE,
                              legend_text = NA,
                              legend_text_font = 1,
                              legend_text_size = 1,
                              legend_text_col = "black",
                              legend_line_type = NA,
                              legend_line_width = NA,
                              legend_line_col = NA,
                              legend_box_fill = NA,
                              legend_point_col = NA,
                              gate_line_type = 1,
                              gate_line_width = 2.5,
                              gate_line_col = "red",
                              gate_fill = "white",
                              gate_fill_alpha = 0,
                              label,
                              label_text = NA,
                              label_stat,
                              label_position = "auto",
                              label_text_x = NA,
                              label_text_y = NA,
                              label_text_font = 2,
                              label_text_size = 1,
                              label_text_col = "black",
                              label_fill = "white",
                              label_fill_alpha = 0.6,
                              border_line_type = 1,
                              border_line_width = 1,
                              border_line_col = "black",
                              border_fill = "white",
                              border_fill_alpha = 1, ...) {
  
  # Checks ---------------------------------------------------------------------
  
  # Set plot method - determine when dev.off should be called when saving
  if (is.null(getOption("CytoRSuite_cyto_plot_method"))) {
    options("CytoRSuite_cyto_plot_method" = "flowSet")
  }
  
  # Signal a custom plot if layout is FALSE
  if (!missing(layout)) {
    if (all(layout == FALSE)) {
      options("CytoRSuite_cyto_plot_custom" = TRUE)
    }
  }
  
  # Reset saved label co-ordinates
  options("CytoRSuite_cyto_plot_label_coords" = NULL)
  
  # Check if channels are supplied
  if (missing(channels)) {
    stop("Supply channel/marker(s) to construct the plot.")
  }
  
  # Graphics parameters --------------------------------------------------------
  
  # Current graphics parameters
  old_pars <- par(c("mar", "mfrow"))
  
  # Reset graphics parameters on exit
  on.exit(par(old_pars))
  
  # cyto_plot_theme ------------------------------------------------------------
  
  # Remember all missing arguments now converted to "" (use .empty())
  
  # Pull down arguments to named list
  args <- .args_list()
  
  # Inherit arguments from cyto_plot_theme
  args <- .cyto_plot_theme_inherit(args)
  
  # Update arguments
  .args_update(args)
  
  # cyto_plot_save -------------------------------------------------------------
  
  # Turn off popup if cyto_plot_save is activated
  if (getOption("CytoRSuite_cyto_plot_save") == TRUE) {
    popup <- FALSE
  }
  
  # Extract channels & transformations -----------------------------------------
  
  # Get valid channel names if markers are supplied
  channels <- cyto_channels_extract(x, channels, plot = TRUE)
  
  # transformerList required
  if (!.all_na(axes_trans)) {
    if(inherits(axes_trans, "transformList")){
      axes_trans <- NA
      message("Supply a transformerList object to axes_trans to transform axes.")
    }
  }
  
  # Extract experiment details & add grouping ----------------------------------
  
  # Extract experiment details
  pd <- cyto_details(x)
  
  # Add group_by column if group_by supplied
  if (!.all_na(group_by)) {
    if (length(group_by) == 1) {
      if (group_by == "all") {
        pd$group_by <- rep("all", nrow(pd))
      } else {
        pd$group_by <- pd[, group_by]
      }
    } else {
      pd$group_by <- do.call("paste", pd[, group_by])
    }
  }
  
  # Extract & format data for plotting (list of flowFrame lists) ---------------
  
  # Add data to list and group if necessary - convert groups to flowFrames
  if (!.all_na(group_by)) {
    fs_list <- cyto_group_by(x, group_by)
    fr_list <- lapply(fs_list, function(z) {
      cyto_convert(z, "flowFrame")
    })
  } else {
    fr_list <- cyto_convert(x, "list of flowFrames")
    names(fr_list) <- sampleNames(x)
  }
  
  # Add overlay to list and group if necessary
  if (!.all_na(overlay)) {
    
    # overlay must be list of flowFrame lists
    
    # Repeat flowFrame once per plot - no grouping
    if (inherits(overlay, "flowFrame")) {
      overlay_list <- rep(list(list(overlay)), length(fr_list))
      # Convert to list of flowFrame lists
    } else if (inherits(overlay, "flowSet")) {
      
      # Apply same grouping to overlay
      if (!.all_na(group_by)) {
        overlay_list <- cyto_group_by(overlay, group_by)
        overlay_list <- lapply(overlay_list, function(z) {
          cyto_convert(z, "flowFrame")
        })
      } else {
        overlay_list <- cyto_convert(overlay, "list of flowFrames")
      }
      
      overlay_list <- lapply(overlay_list, function(z) {
        list(z)
      })
      # Convert list of flowSets to list of flowFrame lists
    } else if (inherits(overlay, "list")) {
      
      # Allow list of flowFrame lists of length fr_list
      if (all(LAPPLY(unlist(overlay), function(z) {
        inherits(z, "flowFrame")
      }))) {
        
        # Must be of same length as fr_list
        if (length(overlay) != length(fr_list)) {
          stop(paste(
            "'overlay' must be a list of flowFrame lists -",
            "one flowFrame list per plot."
          ))
        }
        
        # No grouping is applied internally for these types of overlays
        overlay_list <- overlay
        
        # list of flowSets
      } else if (all(LAPPLY(overlay, function(z) {
        inherits(z, "flowSet")
      }))) {
        
        # Apply same grouping to overlay
        if (!.all_na(group_by)) {
          overlay_list <- lapply(overlay, function(z) {
            cyto_group_by(z, group_by)
          })
          overlay_list <- lapply(overlay_list, function(z) {
            lapply(z, function(y) {
              cyto_convert(y, "flowFrame")
            })
          })
        } else {
          overlay_list <- lapply(overlay, function(z) {
            cyto_convert(z, "list of flowFrames")
          })
        }
        
        overlay_list <- overlay_list %>% transpose()
        
        # Overlay is not supported
      } else {
        stop(paste(
          "'overlay' should be either the names of the populations to",
          "overlay, a flowFrame, a flowSet, list of flowFrame lists",
          "or list of flowSet lists."
        ))
      }
    }
    
    # No overlay
  } else if (.all_na(overlay)) {
    nms <- names(fr_list)
    fr_list <- lapply(seq(1, length(fr_list)), function(z) {
      lst <- list(fr_list[[z]])
      names(lst) <- nms[z]
      return(lst)
    })
  }
  
  # Combine base layers with overlay into list of flowFrame lists
  if (!.all_na(overlay)) {
    nms <- names(fr_list)
    fr_list <- lapply(seq_len(length(fr_list)), function(z) {
      c(fr_list[z], overlay_list[[z]])
    })
    names(fr_list) <- nms
  }
  
  # Support splitting stacked samples without overlay
  if (length(channels) == 1 & .all_na(overlay) & density_stack != 0) {
    
    # Convert list of individual flowFrame lists into list(list of flowFrames)
    fr_list <- list(unlist(fr_list))
    
    # Change legend text to sampleNames
    if (.all_na(legend_text)) {
      legend_text <- nms
    }
    
    # Support splitting into separate plots by density_layers
    if (!.all_na(density_layers)) {
      
      # Only supported if same number of layers in each plot
      if (length(fr_list[[1]]) %% density_layers != 0) {
        stop("Each plot must have the same number of layers!")
      }
      
      ind <- rep(seq_len(length(fr_list[[1]])),
                 each = density_layers,
                 length.out = length(fr_list[[1]])
      )
      fr_list <- lapply(unique(ind), function(z) {
        fr_list[[1]][ind == z]
      })
    }
  }
  
  # Convert to list of density distributions for 1D plots ----------------------
  
  # Convert each flowFrame to density distribution - each list in separate plot
  if(length(channels == 1)){
    fr_list <- lapply(fr_list, function(z){
      lapply(z, function(y){
        suppressWarnings(.cyto_density(y,
                                       channel = channels,
                                       smooth = density_smooth,
                                       modal = density_modal))
      })
    })
  }
  
  # Number of overlays
  ovn <- length(fr_list) - 1
  
  # shift distributions by density_stack
  if(!.all_na(fr_list)){
    # Calculate mean maximum y value for kernel densities
    if(density_modal){
      y_max <- 100
    }else{
      y_max <- mean(LAPPLY(fr_list, function(d){
        if(!.all_na(d)){
          max(d$y)
        }else{
          NA
        }
      }), na.rm = TRUE)
    }
    
    # Degree of y shifting
    shft <- seq(0,
                ovn * density_stack * y_max,
                density_stack * y_max)
    
    # Adjust y values if density_stack != 0
    if(density_stack > 0 & length(fr_list) > 1){
      # Shift distributions for stacking
      lapply(seq_len(length(fr_list)), function(z){
        if(!.all_na(fr_list[[z]])){
          fr_list[[z]]$y <<- fr_list[[z]]$y + shft[z]
        }
      })
    }
  # No events in any fr_list  
  }else if(.all_na(fr_list)){
    
    # Turn off y axis text
    axes_text[[2]] <- FALSE
    
    # Set y_max to 100
    y_max <- 100
    
    # Set y limits to 0-100
    ylim <- c(0, y_max + ovn * density_stack * y_max)
    
    # Stacked distributions require shifting of y values
    shft <- seq(0,
                ovn * density_stack * y_max,
                density_stack * y_max)
    
  }
  
  # Extract gate objects -------------------------------------------------------
  
  # Add gate objects to list and repeat once pr plot
  if(!.all_na(gate)){
    gate <- rep(list(gate), length(fr_list))
  }
  
  # Organise gates for stacked 1D without overlay
  if (length(channels) == 1 & .all_na(overlay) & density_stack != 0) {
    
    # Can't plot per sample 1D gates - must all be the same
    # Repeated in mapply as required
    gate <- list(gate[[1]]) # uses gates from first sample only
  }
  
  # Prepare arguments for plotting ---------------------------------------------
  
  # Legend text - names of fr_list[[i]]
  if (.all_na(legend_text)) {
    legend_text <- LAPPLY(fr_list, function(z) {
      lapply(z, function(y) {
        nm <- identifier(y)
        if(nm == "anonymous"){
          nm <- "Combined Events"
        }
        return(nm)
      })
    })
  }
  
  # Title
  if (.empty(title)) {
    
    # Extract plot title from names of fr_list
    title <- nms
    
    # Convert anonymous to "Combined Events"
    if (any(title %in% c("all","anonymous"))) {
      title[title %in% c("all","anonymous")] <- "Combined Events"
    }
    
    # Remove title for stacked density distributions
    if (length(channels) == 1 & 
        length(fr_list[[1]]) > 1 & 
        density_stack != 0) {
      title <- NA
    }
    
  }
  
  # Label text
  if(.empty(label_text)){
    label_text <- NA
  }
  
  # X axis breaks and labels - pass through axes_text argument
  if (axes_text[1] == TRUE) {
    axes_text_x <- .cyto_plot_axes_text(x[[1]],
                                        channels = channels,
                                        axes_trans = axes_trans
    )[[1]]
  } else {
    axes_text_x <- FALSE
  }
  
  # Y axis breaks and labels - pass through axes_text argument
  if (axes_text[2] == TRUE) {
    if (length(channels) == 2) {
      axes_text_y <- .cyto_plot_axes_text(x[[1]],
                                          channels = channels[2],
                                          axes_trans = axes_trans
      )[[1]]
    } else {
      axes_text_y <- NA
    }
  } else {
    axes_text_y <- FALSE
  }
  axes_text <- list(axes_text_x, axes_text_y)
  axes_text <- rep(axes_text, length(fr_list))
  
  # X axis limits
  if (.all_na(xlim)) {
    xlim <- .cyto_range(fr_list,
                        channels = channels[1],
                        limits = limits,
                        plot = TRUE
    )[, 1]
  }
  
  # Y axis limits - 1D y limit calculated downstream
  if (.all_na(ylim) & length(channels) != 1) {
    ylim <- .cyto_range(fr_list,
                        channels = channels[2],
                        limits = limits,
                        plot = TRUE
    )[, 1]
  }
  
  # GRAPHICS DEVICE
  if(popup == TRUE){
    cyto_plot_new(popup)
  }
  
  # Layout - missing/off/supplied
  if (.empty(layout)) {
    
    # Layout dimensions
    layout <- .cyto_plot_layout(fr_list,
                                layout = layout,
                                density_stack = density_stack,
                                density_layers = density_layers
    )
  } else if (all(layout == FALSE) | .all_na(layout)) {
    
    # Use current dimensions
    layout <- par("mfrow")
  }
  par("mfrow" = layout)
  np <- layout[1] * layout[2]
  
  # Repeat arguments as required -----------------------------------------------
  
  # Pull down arguments to named list - missing converted to ""
  args <- .args_list()
  
  # Repeat arguments as required using .cyto_plot_args_split
  args <- .cyto_plot_args_split(args,
                                channels = channels,
                                n = length(fr_list[[1]]) * length(fr_list),
                                plots = length(fr_list),
                                layers = length(fr_list[[1]]),
                                gates = length(unlist(gate[[1]]))
  )
  
  # Update arguments
  .args_update(args)
  
  # Calls to .cyto_plot internal -----------------------------------------------
  
  # Pass arguments to .cyto_plot to construct plot
  cnt <- 0
  mapply(
    function(x,
             gate,
             limits,
             display,
             xlab,
             ylab,
             title,
             title_text_font,
             title_text_size,
             title_text_col,
             density_modal,
             density_smooth,
             density_stack,
             density_fill,
             density_fill_alpha,
             density_line_type,
             density_line_width,
             density_line_col,
             point_shape,
             point_size,
             point_col,
             point_col_alpha,
             contour_lines,
             contour_line_type,
             contour_line_width,
             contour_line_col,
             axes_text,
             axes_text_font,
             axes_text_size,
             axes_text_col,
             axes_label_text_font,
             axes_label_text_size,
             axes_label_text_col,
             legend,
             legend_text,
             legend_text_font,
             legend_text_size,
             legend_text_col,
             legend_line_type,
             legend_line_width,
             legend_line_col,
             legend_box_fill,
             legend_point_col,
             gate_line_type,
             gate_line_width,
             gate_line_col,
             gate_fill,
             gate_fill_alpha,
             label,
             label_text,
             label_stat,
             label_text_x,
             label_text_y,
             label_text_font,
             label_text_size,
             label_text_col,
             label_fill,
             label_fill_alpha,
             border_line_type,
             border_line_width,
             border_line_col,
             border_fill,
             border_fill_alpha) {
      cnt <<- cnt + 1
      
      .cyto_plot(x,
                 channels = channels,
                 gate = gate,
                 axes_trans = axes_trans,
                 limits = limits,
                 display = display,
                 popup = FALSE,
                 xlim = xlim,
                 ylim = ylim,
                 xlab = xlab,
                 ylab = ylab,
                 title = title,
                 negate = negate,
                 title_text_font = title_text_font,
                 title_text_size = title_text_size,
                 title_text_col = title_text_col,
                 density_modal = density_modal,
                 density_smooth = density_smooth,
                 density_stack = density_stack,
                 density_cols = density_cols,
                 density_fill = density_fill,
                 density_fill_alpha = density_fill_alpha,
                 density_line_type = density_line_type,
                 density_line_width = density_line_width,
                 density_line_col = density_line_col,
                 point_shape = point_shape,
                 point_size = point_size,
                 point_col_scale = point_col_scale,
                 point_cols = point_cols,
                 point_col = point_col,
                 point_col_alpha = point_col_alpha,
                 contour_lines = contour_lines,
                 contour_line_type = contour_line_type,
                 contour_line_width = contour_line_width,
                 contour_line_col = contour_line_col,
                 axes_text = axes_text,
                 axes_text_font = axes_text_font,
                 axes_text_size = axes_text_size,
                 axes_text_col = axes_text_col,
                 axes_label_text_font = axes_label_text_font,
                 axes_label_text_size = axes_label_text_size,
                 axes_label_text_col = axes_label_text_col,
                 legend = legend,
                 legend_text = legend_text,
                 legend_text_font = legend_text_font,
                 legend_text_size = legend_text_size,
                 legend_text_col = legend_text_col,
                 legend_line_type = legend_line_type,
                 legend_line_width = legend_line_width,
                 legend_line_col = legend_line_col,
                 legend_box_fill = legend_box_fill,
                 legend_point_col = legend_point_col,
                 gate_line_type = gate_line_type,
                 gate_line_width = gate_line_width,
                 gate_line_col = gate_line_col,
                 gate_fill = gate_fill,
                 gate_fill_alpha = gate_fill_alpha,
                 label = label,
                 label_text = label_text,
                 label_stat = label_stat,
                 label_position = label_position,
                 label_text_x = label_text_x,
                 label_text_y = label_text_y,
                 label_text_font = label_text_font,
                 label_text_size = label_text_size,
                 label_text_col = label_text_col,
                 label_fill = label_fill,
                 label_fill_alpha = label_fill_alpha,
                 border_line_type = border_line_type,
                 border_line_width = border_line_width,
                 border_line_col = border_line_col,
                 border_fill = border_fill,
                 border_fill_alpha = border_fill_alpha
      )
      
      # New plot
      if (popup == TRUE &
          cnt %% np == 0 &
          length(fr_list) > cnt) {
        cyto_plot_new(popup = popup)
        par("mfrow" = layout)
      }
      
    },
    fr_list,
    gate,
    limits,
    display,
    xlab,
    ylab,
    title,
    title_text_font,
    title_text_size,
    title_text_col,
    density_modal,
    density_smooth,
    density_stack,
    density_fill,
    density_fill_alpha,
    density_line_type,
    density_line_width,
    density_line_col,
    point_shape,
    point_size,
    point_col,
    point_col_alpha,
    contour_lines,
    contour_line_type,
    contour_line_width,
    contour_line_col,
    axes_text,
    axes_text_font,
    axes_text_size,
    axes_text_col,
    axes_label_text_font,
    axes_label_text_size,
    axes_label_text_col,
    legend,
    legend_text,
    legend_text_font,
    legend_text_size,
    legend_text_col,
    legend_line_type,
    legend_line_width,
    legend_line_col,
    legend_box_fill,
    legend_point_col,
    gate_line_type,
    gate_line_width,
    gate_line_col,
    gate_fill,
    gate_fill_alpha,
    label,
    label_text,
    label_stat,
    label_text_x,
    label_text_y,
    label_text_font,
    label_text_size,
    label_text_col,
    label_fill,
    label_fill_alpha,
    border_line_type,
    border_line_width,
    border_line_col,
    border_fill,
    border_fill_alpha
  )

  # Record and/or save ---------------------------------------------------------
  
  # Turn off graphics device for saving
  if (getOption("CytoRSuite_cyto_plot_save")) {
    if (inherits(x, getOption("CytoRSuite_cyto_plot_method"))) {
      if (!getOption("CytoRSuite_cyto_plot_custom")) {
        
        # Close graphics device
        dev.off()
      }
      
      # Reset CytoRSuite_cyto_plot_save
      options("CytoRSuite_cyto_plot_save" = FALSE)
      
      # Reset CytoRSuite_cyto_plot_method
      options("cytoRSuite_cyto_plot_method" = NULL)
      
      # Reset custom plotting flag
      options("CytoRSuite_cyto_plot_custom")
    }
  }
  
  # Record plot for assignment
  invisible(recordPlot())
}

#' cyto_plot - GatingHierarchy Method
#'
#' Explore & visualise a GatingHierarchy.
#'
#' @param x object of class
#'   \code{\link[flowWorkspace:GatingHierarchy-class]{GatingHierarchy}}.
#' @param parent name of the population containing the events to plot.
#' @param alias name of the gated population for which the gate should be drawn
#'   on the plot. Setting \code{alias} to "" will automatically plot any gates
#'   contructed in the supplied channels.
#' @param channels name of the channel(s) or marker(s) to be used to construct
#'   the plot. The length of channels determines the type of plot to be
#'   constructed, either a 1-D density distribution for a single channel or a
#'   2-D scatterplot with blue-red colour scale for two channels.
#' @param axes_trans object of class
#'   \code{\link[flowCore:transformList-class]{transformList}} or
#'   \code{\link[flowWorkspace]{transformerList}} generated by
#'   \code{\link[flowCore:logicleTransform]{estimateLogicle}} which was used to
#'   transform the fluorescent channels of the supplied flowFrame. This
#'   transformation object will be used internally to ensure that the axes
#'   labels of the plot are appropriately transformed. The transformation object
#'   will NOT be applied to the flowFrame internally and should be applied to
#'   the flowFrame prior to plotting.
#' @param overlay name(s) of the populations to overlay or a \code{flowFrame},
#'   \code{flowSet}, \code{list of flowFrames}, \code{list of flowSets} or
#'   \code{list of flowFrame lists} containing populations to be overlaid onto
#'   the plot(s).
#' @param gate gate object(s) to be added to plot.  For \code{cyto_1d_plot} only
#'   gate objects of class
#'   \code{\link[flowCore:rectangleGate-class]{rectangleGate}} in either 1 or 2
#'   dimensions are supported. Multiple gates can be supplied either as a
#'   \code{list} or \code{\link[flowCore:filters-class]{filters}} object.
#' @param limits indicates whether the axes limits should be based on the
#'   \code{"data"} or \code{"machine"}, set to "machine" by default to show
#'   complete axes ranges. This argument will only alter the upper axis limits,
#'   to modify the lower limits use \code{xlim} and \code{ylim}.
#' @param display numeric [0,1] to control the percentage of events to be
#'   plotted. Specifying a value for \code{display} can substantial improve
#'   plotting speed for less powerful machines.
#' @param popup logical indicating whether the plot should be constructed in a
#'   pop-up window, set to FALSE by default. \code{popup} will open OS-specific
#'   graphic device prior to plotting. Mac users will need to install
#'   \href{https://www.xquartz.org/}{XQuartz} for this functionality.
#' @param xlim lower and upper limits of x axis (e.g. c(0,5)).
#' @param ylim lower and upper limits of y axis (e.g. c(0,5)).
#' @param xlab x axis label.
#' @param ylab y axis label.
#' @param title title to use for the plot, set to the name of the sample by
#'   default. Title can be removed by setting this argument to \code{NA}.
#' @param negate logical indicating whether a label should be included for the
#'   negated population when gate objects are supplied, set to FALSE by default.
#' @param density_modal logical indicating whether density should be normalised
#'   to mode and presented as a percentage for 1-D plots. Set to \code{TRUE} by
#'   default.
#' @param density_smooth smoothing parameter passed to
#'   \code{\link[stats:density]{density}} to adjust kernel density for 1-D
#'   plots.
#' @param density_stack numeric [0,1] indicating the degree of offset for 1-D
#'   density distributions with overlay, set to 0.5 by default.
#' @param density_cols vector colours to draw from when selecting density fill
#'   colours if none are supplied to density_fill.
#' @param density_fill fill colour(s) for 1-D density distributions.
#' @param density_fill_alpha numeric [0,1] used to control 1-D density fill
#'   colour transparency, set to 1 by default for solid colours.
#' @param density_line_type line type(s) to use for 1-D density lines, set to 1
#'   by default to use solid lines. See \code{\link[graphics:par]{lty}} for
#'   alternatives.
#' @param density_line_width numeric to control line width(s) for 1-D density
#'   lines, set to 1 by default.
#' @param density_line_col colour(s) for 1-D density lines, set to
#'   \code{"black"} by default.
#' @param point_shape shape(s) to use for points in 2-D scatterplots, set to
#'   \code{"."} by default to maximise plotting speed.  See
#'   \code{\link[graphics:par]{pch}} for alternatives.
#' @param point_size numeric to control the size of points in 2-D scatter plots
#'   set to 2 by default.
#' @param point_col_scale vector of ordered colours to use for the density
#'   colour gradient of points.
#' @param point_cols vector colours to draw from when selecting colours for
#'   points if none are supplied to point_col.
#' @param point_col colour(s) to use for points in 2-D scatter plots, set to NA
#'   by default to use a blue-red density colour scale.
#' @param point_col_alpha numeric [0,1] to control point colour transparency in
#'   2-D scatter plots, set to 1 by default to use solid colours.
#' @param contour_lines numeric indicating the number of levels to use for
#'   contour lines in 2-D scatter plots, set to 0 by default to turn off contour
#'   lines.
#' @param contour_line_type integer [0,6] to control the line type of contour
#'   lines in 2-D scatter plots, set to \code{1} to draw solid lines by default.
#'   See \code{\link[graphics:par]{lty}} for alternatives.
#' @param contour_line_width numeric to control line width(s) for contour lines
#'   in 2-D scatter plots, set to 2 by default.
#' @param contour_line_col colour(s) to use for contour lines in 2-D scatter
#'   plots, set to \code{"black"} by default.
#' @param axes_text logical vector of length 2 indicating whether axis text
#'   should be included for the x and y axes respectively, set to
#'   \code{c(TRUE,TRUE)} by default to display axes text on both axes.
#' @param axes_text_font numeric to control the font of axes text, set to 1 for
#'   plain font by default. See \code{\link[graphics:par]{font}} for
#'   alternatives.
#' @param axes_text_size numeric to control the size of axes text, set to 1 by
#'   default.
#' @param axes_text_col colour to use for axes text, set to \code{"black"} by
#'   default.
#' @param axes_label_text_font numeric to control the font axes labels, set to 1
#'   for plain font by default. See \code{\link[graphics:par]{font}} for
#'   alternatives.
#' @param axes_label_text_size numeric to control the text size of axes labels,
#'   set to 1.1 by default.
#' @param axes_label_text_col colour to use for axes labels text, set to
#'   \code{"black"} by default.
#' @param title_text_font numeric to control the font of title text, set to 2
#'   for bold font by default. See \code{\link[graphics:par]{font}} for
#'   alternatives.
#' @param title_text_size numeric to control the text size of the plot title,
#'   set to 1.1 by default.
#' @param title_text_col colour to use for plot title text, set to
#'   \code{"black"} by default.
#' @param legend can be either \code{"line"} or \code{"fill"} to indicate
#'   whether a legend should be constructed based on the density \code{"line"}
#'   or \code{"fill"}, set to FALSE by default to remove the legend.
#' @param legend_text vector of labels to use in the legend.
#' @param legend_text_font numeric to control the font of legend text, set to 1
#'   for plain font by default. See \code{\link[graphics:par]{font}} for
#'   alternatives.
#' @param legend_text_size numeric to control the size of text in the legend,
#'   set to 1 by default.
#' @param legend_text_col colour(s) to use for text in legend, set to
#'   \code{"black"} by default.
#' @param legend_line_col colour(s) to use for the lines in 1-D plot legends
#'   when legend is set to \code{"line"}.
#' @param legend_box_fill fill colour(s) to use for the boxes in 1-D plot
#'   legends when legend is set to \code{"fill"}.
#' @param legend_point_col colour(s) to use for points in 2-D scatter plot
#'   legend.
#' @param gate_line_type integer [0,6] to control the line type of gates, set to
#'   \code{1} to draw solid lines by default. See
#'   \code{\link[graphics:par]{lty}} for alternatives.
#' @param gate_line_width numeric to control the line width(s) of gates, set to
#'   \code{2.5} by default.
#' @param gate_line_col colour(s) to use for gates, set to \code{"red"} by
#'   default.
#' @param gate_fill fill colour(s) to use for gates, set to "white by default.
#' @param gate_fill_alpha numeric to control the fill transparency of gates, set
#'   to 0 by default to remove fill colour(s).
#' @param label logical indicating whether gated populations should be labelled.
#'   To include the names of the populations in these labels, supply the
#'   population names to the \code{label_text} argument. The default statistic
#'   is \code{"percent"} for gated data and \code{"count"} for un-gated data.
#'   This argument must be set to TRUE in order to add labels with gates.
#' @param label_text vector of population names to use in the labels.The exclude
#'   the population names set this argument to NA.
#' @param label_stat indicates the type of statistic to include in the plot
#'   labels, can be \code{"percent"}, \code{"count"}, \code{"mean"},
#'   \code{"median"}, \code{"mode"} or \code{"geo mean"}, set to
#'   \code{"percent"} for gated data or \code{NA} to exclude statistics for
#'   un-gated data. Currently, only \code{"percent"} and \code{"count"} are
#'   supported for 2-D scatter plots.
#' @param label_position either "auto" or "manual". The "auto" option (default)
#'   positions labels will be placed in the center of gates and offset if
#'   necessary. The "manual" option will allow label positioning by mouse click.
#'   Label positions are set on a per gate basis, all samples in the same group
#'   will have the same label positions. To individually label plots users must
#'   manually supply the co-ordinates to label_text_x and label_text_y.
#' @param label_text_x vector of x co-ordinate(s) to manually adjust the
#'   position plot label(s) on the plot. To interactively position labels set
#'   either \code{label_text_x} or \code{label_text_y} to "select".
#' @param label_text_y vector of y co-ordinate(s) to manually adjust the
#'   position plot label(s) on the plot. To interactively position labels set
#'   either \code{label_text_x} or \code{label_text_y} to "select".
#' @param label_text_font numeric to control the font of text in plot labels,
#'   set to 2 for bold font by default. See \code{\link[graphics:par]{font}} for
#'   alternatives.
#' @param label_text_size numeric to control the size of text in the plot
#'   labels, set to 1 by default.
#' @param label_text_col colour(s) to use for text in plot labels, set to
#'   \code{"black"} by default.
#' @param label_fill fill colour(s) to use for labels, set to "white" by
#'   default.
#' @param label_fill_alpha numeric to control background fill transparency of
#'   label, set to 0.6 by default to introduce some transparency.
#' @param border_line_type integer [0,6] to control the line type of plot
#'   border, set to \code{1} by default for a solid border. See
#'   \code{\link[graphics:par]{lty}} for alternatives.
#' @param border_line_width numeric to control line width for the plot border,
#'   set to 1 by default.
#' @param border_line_col colour to use for the plot border, set to "black" by
#'   default.
#' @param border_fill border_fill fill colour to use inside the plot border
#'   (i.e. background colour), set to "white" by default.
#' @param border_fill_alpha transparency to use for border_fill colour, set to 1
#'   by default for no transparency.
#' @param ... additional arguments not currently in use.
#'
#' @examples
#' library(CytoRSuiteData)
#'
#' # Load samples into GatingSet
#' fs <- Activation
#' gs <- GatingSet(fs)
#'
#' # Apply coompensation
#' gs <- compensate(gs, fs[[1]]@description$SPILL)
#'
#' # Transform fluorescent channels
#' trans <- estimateLogicle(gs[[4]], cyto_fluor_channels(gs))
#' gs <- transform(gs, trans)
#'
#' # Apply gatingTemplate
#' gt <- Activation_gatingTemplate
#' gating(gt, gs)
#'
#' # 2-D scatter plot with Overlays & Gate
#' cyto_plot(gs[[4]],
#'   parent = "CD4 T Cells",
#'   alias = "CD69+ CD4 T Cells",
#'   channels = c("Alexa Fluor 647-A", "7-AAD-A"),
#'   overlay = "CD69+ CD4 T Cells",
#' )
#'
#' # 2-D Scatter plot with Back-Gating & Gates
#' cyto_plot(gs[[4]],
#'   parent = "T Cells",
#'   alias = c("CD4 T Cells", "CD8 T Cells"),
#'   channels = c("Alexa Fluor 488-A", "Alexa Fluor 700-A"),
#'   overlay = c("CD69+ CD4 T Cells", "CD69+ CD8 T Cells")
#' )
#'
#' # 1-D density distribution
#' cyto_plot(gs[[4]],
#'   parent = "CD4 T Cells",
#'   alias = "CD69+ CD4 T Cells",
#'   channels = "7-AAD-A"
#' )
#' @importFrom flowWorkspace getGate getData sampleNames getTransformations
#'   sampleNames pData getNodes
#' @importFrom flowCore flowSet identifier
#' @importFrom openCyto templateGen
#' @importFrom grDevices recordPlot
#' @importFrom methods formalArgs
#' @importFrom purrr transpose pmap
#'
#' @seealso \code{\link{cyto_plot,flowFrame-method}}
#' @seealso \code{\link{cyto_plot,flowSet-method}}
#' @seealso \code{\link{cyto_plot,GatingHierarchy-method}}
#'
#' @author Dillon Hammill, \email{Dillon.Hammill@anu.edu.au}
#'
#' @export
cyto_plot.GatingHierarchy <- function(x,
                                      parent,
                                      alias = NA,
                                      channels,
                                      axes_trans = NA,
                                      overlay = NA,
                                      gate = NA,
                                      limits = "machine",
                                      display = 1,
                                      popup = FALSE,
                                      xlim = NA,
                                      ylim = NA,
                                      xlab,
                                      ylab,
                                      title,
                                      negate = FALSE,
                                      density_modal = TRUE,
                                      density_smooth = 0.6,
                                      density_stack = 0.5,
                                      density_cols = NA,
                                      density_fill = NA,
                                      density_fill_alpha = 1,
                                      density_line_type = 1,
                                      density_line_width = 1,
                                      density_line_col = "black",
                                      point_shape = ".",
                                      point_size = 2,
                                      point_col_scale = NA,
                                      point_cols = NA,
                                      point_col = NA,
                                      point_col_alpha = 1,
                                      contour_lines = 0,
                                      contour_line_type = 1,
                                      contour_line_width = 1,
                                      contour_line_col = "black",
                                      axes_text = c(TRUE, TRUE),
                                      axes_text_font = 1,
                                      axes_text_size = 1,
                                      axes_text_col = "black",
                                      axes_label_text_font = 1,
                                      axes_label_text_size = 1.1,
                                      axes_label_text_col = "black",
                                      title_text_font = 2,
                                      title_text_size = 1.1,
                                      title_text_col = "black",
                                      legend = FALSE,
                                      legend_text = NA,
                                      legend_text_font = 1,
                                      legend_text_size = 1,
                                      legend_text_col = "black",
                                      legend_line_type = NA,
                                      legend_line_width = NA,
                                      legend_line_col = NA,
                                      legend_box_fill = NA,
                                      legend_point_col = NA,
                                      gate_line_type = 1,
                                      gate_line_width = 2.5,
                                      gate_line_col = "red",
                                      gate_fill = "white",
                                      gate_fill_alpha = 0,
                                      label,
                                      label_text,
                                      label_stat,
                                      label_position = "auto",
                                      label_text_x = NA,
                                      label_text_y = NA,
                                      label_text_font = 2,
                                      label_text_size = 1,
                                      label_text_col = "black",
                                      label_fill = "white",
                                      label_fill_alpha = 0.6,
                                      border_line_type = 1,
                                      border_line_width = 1,
                                      border_line_col = "black",
                                      border_fill = "white",
                                      border_fill_alpha = 1, ...) {
  
  # Checks ---------------------------------------------------------------------
  
  # Set plot method - determine when dev.off should be called when saving
  if (is.null(getOption("CytoRSuite_cyto_plot_method"))) {
    options("CytoRSuite_cyto_plot_method" = "GatingHierarchy")
  }
  
  # Reset saved label co-ordinates
  options("CytoRSuite_cyto_plot_label_coords")
  
  # No parent supplied
  if (missing(parent)) {
    stop("Supply the name of the 'parent' population to plot.")
  }
  
  # Check if channels are supplied
  if (missing(channels)) {
    stop("Supply channel/marker(s) to construct the plot.")
  }
  
  # cyto_plot_theme ------------------------------------------------------------
  
  # Remember all missing arguments now converted to "" (use .empty())
  
  # Pull down arguments to named list
  args <- .args_list()
  
  # Inherit arguments from cyto_plot_theme
  args <- .cyto_plot_theme_inherit(args)
  
  # Update arguments
  .args_update(args)
  
  # cyto_plot_save -------------------------------------------------------------
  
  # Turn off popup if cyto_plot_save is activated
  if (getOption("CytoRSuite_cyto_plot_save") == TRUE) {
    popup <- FALSE
  }
  
  # Extract channels & transformations -----------------------------------------
  
  # Get valid channel names if markers are supplied
  channels <- cyto_channels_extract(x, channels, plot = TRUE)
  
  # Get transformations
  if(.all_na(axes_trans)){
    # Extract transformerList from GatingHierarchy
    axes_trans <- x@transformation
  }else if(!.all_na(axes_trans)){
    # transformerList is required
    if(inherits(axes_trans, "transformList")){
      axes_trans <- NA
      message("Supply a transformerList object to axes_trans to transform axes.")
    }
  }
  
  # Extract & format data for plotting (list of flowFrames) ---------------
  
  # Names of each flowFrame is parent and overlay
  if (!.all_na(overlay)) {
    if (is.character(overlay)) {
      if (.all_na(legend_text)) {
        legend_text <- c(parent, overlay)
      }
    }
  }
  
  # Extract data from GatingHierachy
  fr <- cyto_extract(x, parent)
  
  # Add fr to named list
  fr_list <- list(fr)
  names(fr_list) <- identifier(fr)
  
  # Add overlay to list and group if necessary
  if (!.all_na(overlay)) {
    
    # overlay must be list of flowFrames
    
    # Overlay is the names of populations -> list of flowFrames
    if (is.character(overlay)) {
      if (all(overlay %in% basename(getNodes(x)))) {
        
        # Overlay should be added to label_text
        if(.empty(label_text)){
          if(!.all_na(alias)){
            if(length(channels) == 1){
                label_text <- c(alias, overlay)
            }else if(length(channels) == 2){
              label_text <- alias
            }
          }
        }
        
        # Pull out list of flowFrames
        nms <- overlay
        overlay <- lapply(overlay, function(z) {
          cyto_extract(x, z)
        })
        names(overlay) <- nms
      }
    # Overlay is not the names of populations - labels are NA for histograms
    }else{
      
      # Overlay should be added to label_text
      if(.empty(label_text)){
        if(!.all_na(alias)){
          label_text <- rep(alias, length.out = length(overlay) + 1)
        }
      }
      
    }
    
    # flowFrame overlay added to list
    if (inherits(overlay, "flowFrame")) {
      overlay_list <- list(overlay)
      
      # flowSet overlay convert to list of flowFrames
    } else if (inherits(overlay, "flowSet")) {
      overlay_list <- cyto_convert(overlay, "list of flowFrames")
      
      # flowFrame list overlay as is - flowSet list overlay use overlay[[1]]
    } else if (inherits(overlay, "list")) {
      
      # overlay should be list of flowFrames
      if (all(LAPPLY(overlay, function(z) {
        inherits(z, "flowFrame")
      }))) {
        overlay_list <- overlay
        # overlay list of flowSets - use first fs convert to list of flowFrames
      } else if (all(LAPPLY(overlay, function(z) {
        inherits(z, "flowSet")
      }))) {
        overlay <- overlay[[1]]
        overlay_list <- cyto_convert(overlay, "list of flowFrames")
        # overlay not supported
      } else {
        stop(paste(
          "'overlay' should be either the names of the populations to",
          "overlay, a flowFrame, a flowSet or a list of flowFrames."
        ))
      }
    }
  # No overlays
  }else if(.all_na(overlay)){
   
    # Label text
    if(.empty(label_text)){
      if(!.all_na(alias)){
        label_text <- NA
      }else{
        label_text <- alias
      }
    }
     
  }
  
  # Combine base layers with overlay into list of flowFrames
  if (!.all_na(overlay)) {
    fr_list <- c(fr_list, overlay_list)
  }
  
  # Extract gate objects -------------------------------------------------------
  
  # Allow alias = "" to plot all appropriate gates
  if (.empty(alias)) {
    # Plot all appropriate gates if alias is an empty character string
    if (all(alias == "")) {
      gt <- templateGen(x)
      gt <- gt[basename(gt$parent) == parent, ]
      
      # Match both channels for 2D plots
      if (length(channels) == 2) {
        alias <- gt$alias[gt$dims == paste(channels, collapse = ",")]
        
        # At least 1 channel match
      } else if (length(channels) == 1) {
        ind <- lapply(gt$dims, function(z) {
          grep(channels, z)
        })
        ind <- LAPPLY(ind, "length") != 0
        alias <- gt$alias[ind]
      }
      
      # No gates constructed in the supplied channels
      if (length(alias) == 0) {
        alias <- NA
      }
    }
  }
  
  # Extract gate objects directly from x
  if (!.all_na(alias)) {
    gate <- lapply(alias, function(z) {
      getGate(x, paste(parent, z, sep = "/"))
    })
    names(gate) <- alias
  }
  
  # Prepare arguments for plotting ---------------------------------------------
  
  # Legend text - names of fr_list[[i]]
  if (.all_na(legend_text)) {
    legend_text <- LAPPLY(fr_list, function(z) {
      identifier(z)
    })
  }
  
  # Title
  if (.empty(title)) {
    
    # Extract plot title from names of fr_list
    title <- identifier(fr)
    
    # Add parent name to each plot
    title <- LAPPLY(title, function(z) {
      
      # Parent name
      if (parent == "root") {
        pt <- "All Events"
      } else {
        pt <- parent
      }
      
      # All samples grouped together
      if (z == "anonymous") {
        z <- "Combined Events"
      }
      
      # Stacked 1D plots lack sampleNames in titles if no overlay
      if (length(channels) == 1 &
          .all_na(overlay) &
          density_stack != 0) {
        pt
        # Stacked with overlay display sampleNames only
      } else if (length(channels) == 1 &
                 !.all_na(overlay) &
                 density_stack != 0) {
        z
        # Paste together sampleName and parent name
      } else {
        paste(z, "\n", pt, sep = " ")
      }
    })
  }
  
  # X axis breaks and labels - pass through axes_text argument
  if (axes_text[1] == TRUE) {
    axes_text_x <- .cyto_plot_axes_text(x,
                                        channels = channels
    )[[1]]
  } else {
    axes_text_x <- FALSE
  }
  
  # Y axis breaks and labels - pass through axes_text argument
  if (axes_text[2] == TRUE) {
    if (length(channels) == 2) {
      axes_text_y <- .cyto_plot_axes_text(x,
                                          channels = channels[2]
      )[[1]]
    } else {
      axes_text_y <- NA
    }
  } else {
    axes_text_y <- FALSE
  }
  axes_text <- list(axes_text_x, axes_text_y)
  
  # X axis limits
  if (.all_na(xlim)) {
    xlim <- .cyto_range(fr_list,
                        channels = channels[1],
                        limits = limits,
                        plot = TRUE
    )[, 1]
  }
  
  # Y axis limits - 1D y limit calculated downstream
  if (.all_na(ylim) & length(channels) != 1) {
    ylim <- .cyto_range(fr_list,
                        channels = channels[2],
                        limits = limits,
                        plot = TRUE
    )[, 1]
  }
  
  # GRAPHICS DEVICE
  if(popup == TRUE){
    cyto_plot_new(popup)
  }

  # Repeat arguments as required -----------------------------------------------
  
  # Pull down arguments to named list - missing converted to ""
  args <- .args_list()
  
  # Repeat arguments as required using .cyto_plot_args_split
  args <- .cyto_plot_args_split(args,
                                channels = channels,
                                n = length(fr_list),
                                plots = 1,
                                layers = length(fr_list),
                                gates = length(unlist(gate))
  )
  
  # Unlist arguments modified by .cyto_plot_args_split
  lapply(.cyto_plot_args(), function(z){
    args[[z]] <<- args[[z]][[1]]
  })
  
  # Update arguments
  .args_update(args)

  # Calls to .cyto_plot internal -----------------------------------------------
  
  # Pass arguments to .cyto_plot to construct plot
  .cyto_plot(fr_list,
             channels = channels,
             gate = gate,
             axes_trans = axes_trans,
             limits = limits,
             display = display,
             popup = popup,
             xlim = xlim,
             ylim = ylim,
             xlab = xlab,
             ylab = ylab,
             title = title,
             negate = negate,
             title_text_font = title_text_font,
             title_text_size = title_text_size,
             title_text_col = title_text_col,
             density_modal = density_modal,
             density_smooth = density_smooth,
             density_stack = density_stack,
             density_cols = density_cols,
             density_fill = density_fill,
             density_fill_alpha = density_fill_alpha,
             density_line_type = density_line_type,
             density_line_width = density_line_width,
             density_line_col = density_line_col,
             point_shape = point_shape,
             point_size = point_size,
             point_col_scale = point_col_scale,
             point_cols = point_cols,
             point_col = point_col,
             point_col_alpha = point_col_alpha,
             contour_lines = contour_lines,
             contour_line_type = contour_line_type,
             contour_line_width = contour_line_width,
             contour_line_col = contour_line_col,
             axes_text = axes_text,
             axes_text_font = axes_text_font,
             axes_text_size = axes_text_size,
             axes_text_col = axes_text_col,
             axes_label_text_font = axes_label_text_font,
             axes_label_text_size = axes_label_text_size,
             axes_label_text_col = axes_label_text_col,
             legend = legend,
             legend_text = legend_text,
             legend_text_font = legend_text_font,
             legend_text_size = legend_text_size,
             legend_text_col = legend_text_col,
             legend_line_type = legend_line_type,
             legend_line_width = legend_line_width,
             legend_line_col = legend_line_col,
             legend_box_fill = legend_box_fill,
             legend_point_col = legend_point_col,
             gate_line_type = gate_line_type,
             gate_line_width = gate_line_width,
             gate_line_col = gate_line_col,
             gate_fill = gate_fill,
             gate_fill_alpha = gate_fill_alpha,
             label = label,
             label_text = label_text,
             label_stat = label_stat,
             label_position = label_position,
             label_text_x = label_text_x,
             label_text_y = label_text_y,
             label_text_font = label_text_font,
             label_text_size = label_text_size,
             label_text_col = label_text_col,
             label_fill = label_fill,
             label_fill_alpha = label_fill_alpha,
             border_line_type = border_line_type,
             border_line_width = border_line_width,
             border_line_col = border_line_col,
             border_fill = border_fill,
             border_fill_alpha = border_fill_alpha
  )

  # Record and/or save ---------------------------------------------------------
  
  # Turn off graphics device for saving
  if (getOption("CytoRSuite_cyto_plot_save")) {
    if (inherits(x, getOption("CytoRSuite_cyto_plot_method"))) {
      if (!getOption("CytoRSuite_cyto_plot_custom")) {
        
        # Close graphics device
        dev.off()
      }
      
      # Reset CytoRSuite_cyto_plot_save
      options("CytoRSuite_cyto_plot_save" = FALSE)
      
      # Reset CytoRSuite_cyto_plot_method
      options("cytoRSuite_cyto_plot_method" = NULL)
      
      # Reset custom plotting flag
      options("CytoRSuite_cyto_plot_custom")
    }
  }
  
  # Record plot for assignment
  invisible(recordPlot())
  
}

#' cyto_plot - GatingSet Method
#'
#' Explore & visualise a GatingSet.
#'
#' @param x object of class
#'   \code{\link[flowWorkspace:GatingSet-class]{GatingSet}}.
#' @param parent name of the population containing the events to plot.
#' @param alias name of the gated population for which the gate should be drawn
#'   on the plot. Setting \code{alias} to "" will automatically plot any gates
#'   contructed in the supplied channels.
#' @param channels name of the channel(s) or marker(s) to be used to construct
#'   the plot. The length of channels determines the type of plot to be
#'   constructed, either a 1-D density distribution for a single channel or a
#'   2-D scatterplot with blue-red colour scale for two channels.
#' @param axes_trans object of class
#'   \code{\link[flowCore:transformList-class]{transformList}} or
#'   \code{\link[flowWorkspace]{transformerList}} generated by
#'   \code{\link[flowCore:logicleTransform]{estimateLogicle}} which was used to
#'   transform the fluorescent channels of the supplied flowFrame. This
#'   transformation object will be used internally to ensure that the axes
#'   labels of the plot are appropriately transformed. The transformation object
#'   will NOT be applied to the flowFrame internally and should be applied to
#'   the flowFrame prior to plotting.
#' @param group_by a vector of pData variables to sort and merge samples into
#'   groups prior to plotting, set to NULL by default to prevent merging. To
#'   merge all samples set this argument to \code{TRUE} or \code{"all"}.
#' @param overlay name(s) of the populations to overlay or a \code{flowFrame},
#'   \code{flowSet}, \code{list of flowFrames}, \code{list of flowSets} or
#'   \code{list of flowFrame lists} containing populations to be overlaid onto
#'   the plot(s).
#' @param gate gate object(s) to be added to plot.  For \code{cyto_1d_plot} only
#'   gate objects of class
#'   \code{\link[flowCore:rectangleGate-class]{rectangleGate}} in either 1 or 2
#'   dimensions are supported. Multiple gates can be supplied either as a
#'   \code{list} or \code{\link[flowCore:filters-class]{filters}} object.
#' @param limits indicates whether the axes limits should be based on the
#'   \code{"data"} or \code{"machine"}, set to "machine" by default to show
#'   complete axes ranges. This argument will only alter the upper axis limits,
#'   to modify the lower limits use \code{xlim} and \code{ylim}.
#' @param display numeric [0,1] to control the percentage of events to be
#'   plotted. Specifying a value for \code{display} can substantial improve
#'   plotting speed for less powerful machines.
#' @param layout a vector of the length 2 indicating the dimensions of the grid
#'   for plotting \code{c(#rows, #columns)}.
#' @param popup logical indicating whether the plot should be constructed in a
#'   pop-up window, set to FALSE by default. \code{popup} will open OS-specific
#'   graphic device prior to plotting. Mac users will need to install
#'   \href{https://www.xquartz.org/}{XQuartz} for this functionality.
#' @param xlim lower and upper limits of x axis (e.g. c(0,5)).
#' @param ylim lower and upper limits of y axis (e.g. c(0,5)).
#' @param xlab x axis label.
#' @param ylab y axis label.
#' @param title title to use for the plot, set to the name of the sample by
#'   default. Title can be removed by setting this argument to \code{NA}.
#' @param negate logical indicating whether a label should be included for the
#'   negated population when gate objects are supplied, set to FALSE by default.
#' @param density_modal logical indicating whether density should be normalised
#'   to mode and presented as a percentage for 1-D plots. Set to \code{TRUE} by
#'   default.
#' @param density_smooth smoothing parameter passed to
#'   \code{\link[stats:density]{density}} to adjust kernel density for 1-D
#'   plots.
#' @param density_stack numeric [0,1] indicating the degree of offset for 1-D
#'   density distributions with overlay, set to 0.5 by default.
#' @param density_layers numeric indicating the number of samples to stack in
#'   each plot, set to all samples by default.
#' @param density_cols vector colours to draw from when selecting density fill
#'   colours if none are supplied to density_fill.
#' @param density_fill fill colour(s) for 1-D density distributions.
#' @param density_fill_alpha numeric [0,1] used to control 1-D density fill
#'   colour transparency, set to 1 by default for solid colours.
#' @param density_line_type line type(s) to use for 1-D density lines, set to 1
#'   by default to use solid lines. See \code{\link[graphics:par]{lty}} for
#'   alternatives.
#' @param density_line_width numeric to control line width(s) for 1-D density
#'   lines, set to 1 by default.
#' @param density_line_col colour(s) for 1-D density lines, set to
#'   \code{"black"} by default.
#' @param point_shape shape(s) to use for points in 2-D scatterplots, set to
#'   \code{"."} by default to maximise plotting speed.  See
#'   \code{\link[graphics:par]{pch}} for alternatives.
#' @param point_size numeric to control the size of points in 2-D scatter plots
#'   set to 2 by default.
#' @param point_col_scale vector of ordered colours to use for the density
#'   colour gradient of points.
#' @param point_cols vector colours to draw from when selecting colours for
#'   points if none are supplied to point_col.
#' @param point_col colour(s) to use for points in 2-D scatter plots, set to NA
#'   by default to use a blue-red density colour scale.
#' @param point_col_alpha numeric [0,1] to control point colour transparency in
#'   2-D scatter plots, set to 1 by default to use solid colours.
#' @param contour_lines numeric indicating the number of levels to use for
#'   contour lines in 2-D scatter plots, set to 0 by default to turn off contour
#'   lines.
#' @param contour_line_type integer [0,6] to control the line type of contour
#'   lines in 2-D scatter plots, set to \code{1} to draw solid lines by default.
#'   See \code{\link[graphics:par]{lty}} for alternatives.
#' @param contour_line_width numeric to control line width(s) for contour lines
#'   in 2-D scatter plots, set to 2 by default.
#' @param contour_line_col colour(s) to use for contour lines in 2-D scatter
#'   plots, set to \code{"black"} by default.
#' @param axes_text logical vector of length 2 indicating whether axis text
#'   should be included for the x and y axes respectively, set to
#'   \code{c(TRUE,TRUE)} by default to display axes text on both axes.
#' @param axes_text_font numeric to control the font of axes text, set to 1 for
#'   plain font by default. See \code{\link[graphics:par]{font}} for
#'   alternatives.
#' @param axes_text_size numeric to control the size of axes text, set to 1 by
#'   default.
#' @param axes_text_col colour to use for axes text, set to \code{"black"} by
#'   default.
#' @param axes_label_text_font numeric to control the font axes labels, set to 1
#'   for plain font by default. See \code{\link[graphics:par]{font}} for
#'   alternatives.
#' @param axes_label_text_size numeric to control the text size of axes labels,
#'   set to 1.1 by default.
#' @param axes_label_text_col colour to use for axes labels text, set to
#'   \code{"black"} by default.
#' @param title_text_font numeric to control the font of title text, set to 2
#'   for bold font by default. See \code{\link[graphics:par]{font}} for
#'   alternatives.
#' @param title_text_size numeric to control the text size of the plot title,
#'   set to 1.1 by default.
#' @param title_text_col colour to use for plot title text, set to
#'   \code{"black"} by default.
#' @param legend can be either \code{"line"} or \code{"fill"} to indicate
#'   whether a legend should be constructed based on the density \code{"line"}
#'   or \code{"fill"}, set to FALSE by default to remove the legend.
#' @param legend_text vector of labels to use in the legend.
#' @param legend_text_font numeric to control the font of legend text, set to 1
#'   for plain font by default. See \code{\link[graphics:par]{font}} for
#'   alternatives.
#' @param legend_text_size numeric to control the size of text in the legend,
#'   set to 1 by default.
#' @param legend_text_col colour(s) to use for text in legend, set to
#'   \code{"black"} by default.
#' @param legend_line_col colour(s) to use for the lines in 1-D plot legends
#'   when legend is set to \code{"line"}.
#' @param legend_box_fill fill colour(s) to use for the boxes in 1-D plot
#'   legends when legend is set to \code{"fill"}.
#' @param legend_point_col colour(s) to use for points in 2-D scatter plot
#'   legend.
#' @param gate_line_type integer [0,6] to control the line type of gates, set to
#'   \code{1} to draw solid lines by default. See
#'   \code{\link[graphics:par]{lty}} for alternatives.
#' @param gate_line_width numeric to control the line width(s) of gates, set to
#'   \code{2.5} by default.
#' @param gate_line_col colour(s) to use for gates, set to \code{"red"} by
#'   default.
#' @param gate_fill fill colour(s) to use for gates, set to "white by default.
#' @param gate_fill_alpha numeric to control the fill transparency of gates, set
#'   to 0 by default to remove fill colour(s).
#' @param label logical indicating whether gated populations should be labelled.
#'   To include the names of the populations in these labels, supply the
#'   population names to the \code{label_text} argument. The default statistic
#'   is \code{"percent"} for gated data and \code{"count"} for un-gated data.
#'   This argument must be set to TRUE in order to add labels with gates.
#' @param label_text vector of population names to use in the labels.The exclude
#'   the population names set this argument to NA.
#' @param label_stat indicates the type of statistic to include in the plot
#'   labels, can be \code{"percent"}, \code{"count"}, \code{"mean"},
#'   \code{"median"}, \code{"mode"} or \code{"geo mean"}, set to
#'   \code{"percent"} for gated data or \code{NA} to exclude statistics for
#'   un-gated data. Currently, only \code{"percent"} and \code{"count"} are
#'   supported for 2-D scatter plots.
#' @param label_position either "auto" or "manual". The "auto" option (default)
#'   positions labels will be placed in the center of gates and offset if
#'   necessary. The "manual" option will allow label positioning by mouse click.
#'   Label positions are set on a per gate basis, all samples in the same group
#'   will have the same label positions. To individually label plots users must
#'   manually supply the co-ordinates to label_text_x and label_text_y.
#' @param label_text_x vector of x co-ordinate(s) to manually adjust the
#'   position plot label(s) on the plot. To interactively position labels set
#'   either \code{label_text_x} or \code{label_text_y} to "select".
#' @param label_text_y vector of y co-ordinate(s) to manually adjust the
#'   position plot label(s) on the plot. To interactively position labels set
#'   either \code{label_text_x} or \code{label_text_y} to "select".
#' @param label_text_font numeric to control the font of text in plot labels,
#'   set to 2 for bold font by default. See \code{\link[graphics:par]{font}} for
#'   alternatives.
#' @param label_text_size numeric to control the size of text in the plot
#'   labels, set to 1 by default.
#' @param label_text_col colour(s) to use for text in plot labels, set to
#'   \code{"black"} by default.
#' @param label_fill fill colour(s) to use for labels, set to "white" by
#'   default.
#' @param label_fill_alpha numeric to control background fill transparency of
#'   label, set to 0.6 by default to introduce some transparency.
#' @param border_line_type integer [0,6] to control the line type of plot
#'   border, set to \code{1} by default for a solid border. See
#'   \code{\link[graphics:par]{lty}} for alternatives.
#' @param border_line_width numeric to control line width for the plot border,
#'   set to 1 by default.
#' @param border_line_col colour to use for the plot border, set to "black" by
#'   default.
#' @param border_fill border_fill fill colour to use inside the plot border
#'   (i.e. background colour), set to "white" by default.
#' @param border_fill_alpha transparency to use for border_fill colour, set to 1
#'   by default for no transparency.
#' @param ... additional arguments not currently in use.
#'
#' @examples
#' library(CytoRSuiteData)
#'
#' # Load samples into GatingSet
#' fs <- Activation
#' gs <- GatingSet(fs)
#'
#' # Apply coompensation
#' gs <- compensate(gs, fs[[1]]@description$SPILL)
#'
#' # Transform fluorescent channels
#' trans <- estimateLogicle(gs[[4]], cyto_fluor_channels(gs))
#' gs <- transform(gs, trans)
#'
#' # Apply gatingTemplate
#' gt <- Activation_gatingTemplate
#' gating(gt, gs)
#'
#' # 2-D scatter plot with overlay & Gates
#' cyto_plot(gs,
#'   parent = "CD4 T Cells",
#'   alias = "CD69+ CD4 T Cells",
#'   channels = c("Alexa Fluor 647-A", "7-AAD-A"),
#'   overlay = "CD8 T Cells"
#' )
#'
#' # 2-D Scatter Plots with Back-Gating & Gates
#' cyto_plot(gs,
#'   parent = "T Cells",
#'   alias = c("CD4 T Cells", "CD8 T Cells"),
#'   channels = c("Alexa Fluor 488-A", "Alexa Fluor 700-A"),
#'   overlay = c("CD69+ CD4 T Cells", "CD69+ CD8 T Cells")
#' )
#' @importFrom flowWorkspace getGate getData sampleNames getTransformations
#'   sampleNames pData getNodes
#' @importFrom flowCore flowSet identifier
#' @importFrom openCyto templateGen
#' @importFrom grDevices recordPlot
#' @importFrom methods formalArgs
#' @importFrom purrr transpose pmap
#'
#' @seealso \code{\link{cyto_plot,flowFrame-method}}
#' @seealso \code{\link{cyto_plot,flowSet-method}}
#' @seealso \code{\link{cyto_plot,GatingHierarchy-method}}
#'
#' @author Dillon Hammill, \email{Dillon.Hammill@anu.edu.au}
#'
#' @export
cyto_plot.GatingSet <- function(x,
                                parent,
                                alias = NA,
                                channels,
                                axes_trans = NA,
                                group_by = NA,
                                overlay = NA,
                                gate = NA,
                                limits = "machine",
                                display = 1,
                                layout,
                                popup = FALSE,
                                xlim = NA,
                                ylim = NA,
                                xlab,
                                ylab,
                                title,
                                negate = FALSE,
                                density_modal = TRUE,
                                density_smooth = 0.6,
                                density_stack = 0.5,
                                density_layers = NA,
                                density_cols = NA,
                                density_fill = NA,
                                density_fill_alpha = 1,
                                density_line_type = 1,
                                density_line_width = 1,
                                density_line_col = "black",
                                point_shape = ".",
                                point_size = 2,
                                point_col_scale = NA,
                                point_cols = NA,
                                point_col = NA,
                                point_col_alpha = 1,
                                contour_lines = 0,
                                contour_line_type = 1,
                                contour_line_width = 1,
                                contour_line_col = "black",
                                axes_text = c(TRUE, TRUE),
                                axes_text_font = 1,
                                axes_text_size = 1,
                                axes_text_col = "black",
                                axes_label_text_font = 1,
                                axes_label_text_size = 1.1,
                                axes_label_text_col = "black",
                                title_text_font = 2,
                                title_text_size = 1.1,
                                title_text_col = "black",
                                legend = FALSE,
                                legend_text = NA,
                                legend_text_font = 1,
                                legend_text_size = 1,
                                legend_text_col = "black",
                                legend_line_type = NA,
                                legend_line_width = NA,
                                legend_line_col = NA,
                                legend_box_fill = NA,
                                legend_point_col = NA,
                                gate_line_type = 1,
                                gate_line_width = 2.5,
                                gate_line_col = "red",
                                gate_fill = "white",
                                gate_fill_alpha = 0,
                                label,
                                label_text,
                                label_stat,
                                label_position = "auto",
                                label_text_x = NA,
                                label_text_y = NA,
                                label_text_font = 2,
                                label_text_size = 1,
                                label_text_col = "black",
                                label_fill = "white",
                                label_fill_alpha = 0.6,
                                border_line_type = 1,
                                border_line_width = 1,
                                border_line_col = "black",
                                border_fill = "white",
                                border_fill_alpha = 1, ...) {
  
  # Checks ---------------------------------------------------------------------
  
  # Set plot method - determine when dev.off should be called when saving
  if (is.null(getOption("CytoRSuite_cyto_plot_method"))) {
    options("CytoRSuite_cyto_plot_method" = "GatingSet")
  }

  # Reset saved label co-ordinates
  options("CytoRSuite_cyto_plot_label_coords" = NULL)
  
  # No parent supplied
  if (missing(parent)) {
    stop("Supply the name of the 'parent' population to plot.")
  }
  
  # Check if channels are supplied
  if (missing(channels)) {
    stop("Supply channel/marker(s) to construct the plot.")
  }
  
  # Graphics parameters --------------------------------------------------------
  
  # Current graphics parameters
  old_pars <- par(c("mar", "mfrow"))
  
  # Reset graphics parameters on exit
  on.exit(par(old_pars))
  
  # cyto_plot_theme ------------------------------------------------------------
  
  # Remember all missing arguments now converted to "" (use .empty())
  
  # Pull down arguments to named list
  args <- .args_list()
  
  # Inherit arguments from cyto_plot_theme
  args <- .cyto_plot_theme_inherit(args)
  
  # Update arguments
  .args_update(args)
  
  # cyto_plot_save -------------------------------------------------------------
  
  # Turn off popup if cyto_plot_save is activated
  if (getOption("CytoRSuite_cyto_plot_save") == TRUE) {
    popup <- FALSE
  }
  
  # Extract channels & transformations -----------------------------------------
  
  # Get valid channel names if markers are supplied
  channels <- cyto_channels_extract(x, channels, plot = TRUE)
  
  # Get transformations
  if(.all_na(axes_trans)){
    # Extract transformerList from GatingHierarchy
    axes_trans <- x[[1]]@transformation
  }else if(!.all_na(axes_trans)){
    # transformerList is required
    if(inherits(axes_trans, "transformList")){
      axes_trans <- NA
      message("Supply a transformerList object to axes_trans to transform axes.")
    }
  }
  
  # Extract experiment details & add grouping ----------------------------------
  
  # Extract experiment details
  pd <- cyto_details(x)
  
  # Add group_by column if group_by supplied
  if (!.all_na(group_by)) {
    if (length(group_by) == 1) {
      if (group_by == "all") {
        pd$group_by <- rep("all", nrow(pd))
      } else {
        pd$group_by <- pd[, group_by]
      }
    } else {
      pd$group_by <- do.call("paste", pd[, group_by])
    }
  }
  
  # Extract & format data for plotting (list of flowFrame lists) ---------------
  
  # Names of each flowFrame is parent and overlay
  if (!.all_na(overlay)) {
    if (is.character(overlay)) {
      if (.all_na(legend_text)) {
        legend_text <- c(parent, overlay)
      }
    }
  }
  
  # Extract data from GatingSet
  fs <- cyto_extract(x, parent)
  
  # Add data to list and group if necessary - convert groups to flowFrames
  if (!.all_na(group_by)) {
    fs_list <- cyto_group_by(fs, group_by)
    fr_list <- lapply(fs_list, function(z) {
      cyto_convert(z, "flowFrame")
    })
  } else {
    fr_list <- cyto_convert(fs, "list of flowFrames")
    names(fr_list) <- sampleNames(x)
  }
  
  # Add overlay to list and group if necessary
  if (!.all_na(overlay)) {
    
    # overlay must be list of flowFrame lists
    
    # Overlay is the names of populations
    if (is.character(overlay)) {
      if (all(overlay %in% basename(getNodes(x)))) {
        
        # Overlay should be added to label_text
        if(.empty(label_text)){
          if(!.all_na(alias)){
            if(length(channels) == 1){
              label_text <- c(alias, overlay)
            }else if(length(channels) == 2){
              label_text <- alias
            }
          }
        }
        
        # Pull out list of flowSets
        nms <- overlay
        overlay <- lapply(overlay, function(z) {
          cyto_extract(x, z)
        })
        names(overlay) <- nms
      }
      # Overlay is not the names of populations - labels are NA for histograms
    }else{
      
      # Overlay should be added to label_text
      if(.empty(label_text)){
        if(!.all_na(alias)){
          label_text <- rep(alias, length.out = length(overlay) + 1)
        }
      }
      
    }
    
    # Repeat flowFrame once per plot - no grouping
    if (inherits(overlay, "flowFrame")) {
      overlay_list <- rep(list(list(overlay)), length(fr_list))
      # Convert to list of flowFrame lists
    } else if (inherits(overlay, "flowSet")) {
      
      # Apply same grouping to overlay
      if (!.all_na(group_by)) {
        overlay_list <- cyto_group_by(overlay, group_by)
        overlay_list <- lapply(overlay_list, function(z) {
          cyto_convert(z, "flowFrame")
        })
      } else {
        overlay_list <- cyto_convert(overlay, "list of flowFrames")
      }
      
      overlay_list <- lapply(overlay_list, function(z) {
        list(z)
      })
      # Convert list of flowSets to list of flowFrame lists
    } else if (inherits(overlay, "list")) {
      
      # Allow list of flowFrame lists of length fr_list
      if (all(LAPPLY(unlist(overlay), function(z) {
        inherits(z, "flowFrame")
      }))) {
        
        # Must be of same length as fr_list
        if (length(overlay) != length(fr_list)) {
          stop(paste(
            "'overlay' must be a list of flowFrame lists -",
            "one flowFrame list per plot."
          ))
        }
        
        # No grouping is applied internally for these types of overlays
        overlay_list <- overlay
        
        # list of flowSet lists
      } else if (all(LAPPLY(overlay, function(z) {
        inherits(z, "flowSet")
      }))) {
        
        # Apply same grouping to overlay
        if (!.all_na(group_by)) {
          overlay_list <- lapply(overlay, function(z) {
            cyto_group_by(z, group_by)
          })
          overlay_list <- lapply(overlay_list, function(z) {
            lapply(z, function(y) {
              cyto_convert(y, "flowFrame")
            })
          })
        } else {
          overlay_list <- lapply(overlay, function(z) {
            cyto_convert(z, "list of flowFrames")
          })
        }
        
        overlay_list <- overlay_list %>% transpose()
        
        # Overlay is not supported
      } else {
        stop(paste(
          "'overlay' should be either the names of the populations to",
          "overlay, a flowFrame, a flowSet, list of flowFrame lists",
          "or list of flowSet lists."
        ))
      }
    }
    
    # No overlay
  } else if (.all_na(overlay)) {
    nms <- names(fr_list)
    fr_list <- lapply(seq(1, length(fr_list)), function(z) {
      lst <- list(fr_list[[z]])
      names(lst) <- nms[z]
      return(lst)
    })
    
    # Label text
    if(.empty(label_text)){
      if(!.all_na(alias)){
        label_text <- NA
      }else{
        label_text <- alias
      }
    }
    
  }
  
  # Combine base layers with overlay into list of flowFrame lists
  if (!.all_na(overlay)) {
    nms <- names(fr_list)
    fr_list <- lapply(seq_len(length(fr_list)), function(z) {
      c(fr_list[z], overlay_list[[z]])
    })
    names(fr_list) <- nms
  }
  
  # Support splitting stacked samples without overlay
  if (length(channels) == 1 & .all_na(overlay) & density_stack != 0) {
    
    # Convert list of individual flowFrame lists into list(list of flowFrames)
    fr_list <- list(unlist(fr_list))
    
    # Change legend text to sampleNames
    if (.all_na(legend_text)) {
      legend_text <- nms
    }
    
    # Support splitting into separate plots by density_layers
    if (!.all_na(density_layers)) {
      
      # Only supported if same number of layers in each plot
      if (length(fr_list[[1]]) %% density_layers != 0) {
        stop("Each plot must have the same number of layers!")
      }
      
      ind <- rep(seq_len(length(fr_list[[1]])),
                 each = density_layers,
                 length.out = length(fr_list[[1]])
      )
      fr_list <- lapply(unique(ind), function(z) {
        fr_list[[1]][ind == z]
      })
    }
  }
  
  # Extract gate objects -------------------------------------------------------
  
  # Allow alias = "" to plot all appropriate gates
  if (.empty(alias)) {
    # Plot all appropriate gates if alias is an empty character string
    if (all(alias == "")) {
      gt <- templateGen(x[[1]])
      gt <- gt[basename(gt$parent) == parent, ]
      
      # Match both channels for 2D plots
      if (length(channels) == 2) {
        alias <- gt$alias[gt$dims == paste(channels, collapse = ",")]
        
        # At least 1 channel match
      } else if (length(channels) == 1) {
        ind <- lapply(gt$dims, function(z) {
          grep(channels, z)
        })
        ind <- LAPPLY(ind, "length") != 0
        alias <- gt$alias[ind]
      }
      
      # No gates constructed in the supplied channels
      if (length(alias) == 0) {
        alias <- NA
      }
    }
  }
  
  # Extract gate objects directly from x
  if (!.all_na(alias)) {
    if (!.all_na(group_by)) {
      gate <- lapply(nms, function(nm) {
        gt <- lapply(alias, function(z) {
          getGate(x[[match(nm, pd$group_by)]], paste(parent, z, sep = "/"))
        })
        names(gt) <- alias
        return(gt)
      })
    } else {
      gate <- lapply(seq_len(length(x)), function(z) {
        gt <- lapply(alias, function(y) {
          getGate(x[[z]], paste(parent, y, sep = "/"))
        })
        names(gt) <- alias
        return(gt)
      })
    }
    # Gates manually supplied are added to list
  }else if(!.all_na(gate)){
    gate <- rep(list(gate), length(fr_list))
  }
  
  # Organise gates for stacked 1D without overlay
  if (length(channels) == 1 & .all_na(overlay) & density_stack != 0) {
    
    # Can't plot per sample 1D gates - must all be the same
    # Repeated in mapply as required
    # Must be selected from non-empty sample - co-ordinates modified to -Inf Inf
    ind <- LAPPLY(fr_list[[1]], function(z){
      BiocGenerics::nrow(z)
    })
    ind <- which(ind > 0)
    gate <- list(gate[[ind[1]]]) # uses gates from first sample only
  }
  
  # Prepare arguments for plotting ---------------------------------------------
  
  # Legend text - names of fr_list[[i]]
  if (.all_na(legend_text)) {
    legend_text <- LAPPLY(fr_list, function(z) {
      lapply(z, function(y) {
        identifier(y)
      })
    })
  }
  
  # Title
  if (.empty(title)) {
    
    # Extract plot title from names of fr_list
    title <- nms
    
    # Add parent name to each plot
    title <- LAPPLY(title, function(z) {
      
      # Parent name
      if (parent == "root") {
        pt <- "All Events"
      } else {
        pt <- parent
      }
      
      # All samples grouped together
      if (z %in% c("all","anonymous")) {
        z <- "Combined Events"
      }
      
      # Stacked 1D plots lack sampleNames in titles if no overlay
      if (length(channels) == 1 & 
          .all_na(overlay) & 
          density_stack != 0) {
        pt
        # Stacked with overlay display sampleNames only
      } else if (length(channels) == 1 & 
                 !.all_na(overlay) & 
                 density_stack != 0) {
        z
        # Paste together sampleName and parent name
      } else {
        paste(z, "\n", pt, sep = " ")
      }
    })
  }
  
  # X axis breaks and labels - pass through axes_text argument
  if (axes_text[1] == TRUE) {
    axes_text_x <- .cyto_plot_axes_text(x[[1]],
                                        channels = channels
    )[[1]]
  } else {
    axes_text_x <- FALSE
  }
  
  # Y axis breaks and labels - pass through axes_text argument
  if (axes_text[2] == TRUE) {
    if (length(channels) == 2) {
      axes_text_y <- .cyto_plot_axes_text(x[[1]],
                                          channels = channels[2]
      )[[1]]
    } else {
      axes_text_y <- NA
    }
  } else {
    axes_text_y <- FALSE
  }
  axes_text <- list(axes_text_x, axes_text_y)
  axes_text <- rep(axes_text, length(fr_list))
  
  # X axis limits
  if (.all_na(xlim)) {
    xlim <- .cyto_range(fr_list,
                        channels = channels[1],
                        limits = limits,
                        plot = TRUE
    )[, 1]
  }
  
  # Y axis limits - 1D y limit calculated downstream
  if (.all_na(ylim) & length(channels) != 1) {
    ylim <- .cyto_range(fr_list,
                        channels = channels[2],
                        limits = limits,
                        plot = TRUE
    )[, 1]
  }
  
  # GRAPHICS DEVICE
  if(popup == TRUE){
    cyto_plot_new(popup)
  }
  
  # Layout - missing/off/supplied
  if (.empty(layout)) {
    
    # Layout dimensions
    layout <- .cyto_plot_layout(fr_list,
                                layout = layout,
                                density_stack = density_stack,
                                density_layers = density_layers
    )
  } else if (all(layout == FALSE) | .all_na(layout)) {
    
    # Use current dimensions
    layout <- par("mfrow")
  }
  par("mfrow" = layout)
  np <- layout[1] * layout[2]
  
  # Repeat arguments as required -----------------------------------------------
  
  # Pull down arguments to named list - missing converted to ""
  args <- .args_list()
  
  # Repeat arguments as required using .cyto_plot_args_split
  args <- .cyto_plot_args_split(args,
                                channels = channels,
                                n = length(fr_list[[1]]) * length(fr_list),
                                plots = length(fr_list),
                                layers = length(fr_list[[1]]),
                                gates = length(unlist(gate[[1]]))
  )
  
  # Update arguments
  .args_update(args)
  
  # Calls to .cyto_plot internal -----------------------------------------------
  
  # Pass arguments to .cyto_plot to construct plot
  cnt <- 0
  mapply(
    function(x,
             gate,
             limits,
             display,
             xlab,
             ylab,
             title,
             title_text_font,
             title_text_size,
             title_text_col,
             density_modal,
             density_smooth,
             density_stack,
             density_fill,
             density_fill_alpha,
             density_line_type,
             density_line_width,
             density_line_col,
             point_shape,
             point_size,
             point_col,
             point_col_alpha,
             contour_lines,
             contour_line_type,
             contour_line_width,
             contour_line_col,
             axes_text,
             axes_text_font,
             axes_text_size,
             axes_text_col,
             axes_label_text_font,
             axes_label_text_size,
             axes_label_text_col,
             legend,
             legend_text,
             legend_text_font,
             legend_text_size,
             legend_text_col,
             legend_line_type,
             legend_line_width,
             legend_line_col,
             legend_box_fill,
             legend_point_col,
             gate_line_type,
             gate_line_width,
             gate_line_col,
             gate_fill,
             gate_fill_alpha,
             label,
             label_text,
             label_stat,
             label_text_x,
             label_text_y,
             label_text_font,
             label_text_size,
             label_text_col,
             label_fill,
             label_fill_alpha,
             border_line_type,
             border_line_width,
             border_line_col,
             border_fill,
             border_fill_alpha) {
      cnt <<- cnt + 1
      
      .cyto_plot(x,
                 channels = channels,
                 gate = gate,
                 axes_trans = axes_trans,
                 limits = limits,
                 display = display,
                 popup = FALSE,
                 xlim = xlim,
                 ylim = ylim,
                 xlab = xlab,
                 ylab = ylab,
                 title = title,
                 negate = negate,
                 title_text_font = title_text_font,
                 title_text_size = title_text_size,
                 title_text_col = title_text_col,
                 density_modal = density_modal,
                 density_smooth = density_smooth,
                 density_stack = density_stack,
                 density_cols = density_cols,
                 density_fill = density_fill,
                 density_fill_alpha = density_fill_alpha,
                 density_line_type = density_line_type,
                 density_line_width = density_line_width,
                 density_line_col = density_line_col,
                 point_shape = point_shape,
                 point_size = point_size,
                 point_col_scale = point_col_scale,
                 point_cols = point_cols,
                 point_col = point_col,
                 point_col_alpha = point_col_alpha,
                 contour_lines = contour_lines,
                 contour_line_type = contour_line_type,
                 contour_line_width = contour_line_width,
                 contour_line_col = contour_line_col,
                 axes_text = axes_text,
                 axes_text_font = axes_text_font,
                 axes_text_size = axes_text_size,
                 axes_text_col = axes_text_col,
                 axes_label_text_font = axes_label_text_font,
                 axes_label_text_size = axes_label_text_size,
                 axes_label_text_col = axes_label_text_col,
                 legend = legend,
                 legend_text = legend_text,
                 legend_text_font = legend_text_font,
                 legend_text_size = legend_text_size,
                 legend_text_col = legend_text_col,
                 legend_line_type = legend_line_type,
                 legend_line_width = legend_line_width,
                 legend_line_col = legend_line_col,
                 legend_box_fill = legend_box_fill,
                 legend_point_col = legend_point_col,
                 gate_line_type = gate_line_type,
                 gate_line_width = gate_line_width,
                 gate_line_col = gate_line_col,
                 gate_fill = gate_fill,
                 gate_fill_alpha = gate_fill_alpha,
                 label = label,
                 label_text = label_text,
                 label_stat = label_stat,
                 label_position = label_position,
                 label_text_x = label_text_x,
                 label_text_y = label_text_y,
                 label_text_font = label_text_font,
                 label_text_size = label_text_size,
                 label_text_col = label_text_col,
                 label_fill = label_fill,
                 label_fill_alpha = label_fill_alpha,
                 border_line_type = border_line_type,
                 border_line_width = border_line_width,
                 border_line_col = border_line_col,
                 border_fill = border_fill,
                 border_fill_alpha = border_fill_alpha
      )
      
      # New plot
      if (popup == TRUE &
          cnt %% np == 0 &
          length(fr_list) > cnt) {
        cyto_plot_new(popup = popup)
        par("mfrow" = layout)
      }
      
    },
    fr_list,
    gate,
    limits,
    display,
    xlab,
    ylab,
    title,
    title_text_font,
    title_text_size,
    title_text_col,
    density_modal,
    density_smooth,
    density_stack,
    density_fill,
    density_fill_alpha,
    density_line_type,
    density_line_width,
    density_line_col,
    point_shape,
    point_size,
    point_col,
    point_col_alpha,
    contour_lines,
    contour_line_type,
    contour_line_width,
    contour_line_col,
    axes_text,
    axes_text_font,
    axes_text_size,
    axes_text_col,
    axes_label_text_font,
    axes_label_text_size,
    axes_label_text_col,
    legend,
    legend_text,
    legend_text_font,
    legend_text_size,
    legend_text_col,
    legend_line_type,
    legend_line_width,
    legend_line_col,
    legend_box_fill,
    legend_point_col,
    gate_line_type,
    gate_line_width,
    gate_line_col,
    gate_fill,
    gate_fill_alpha,
    label,
    label_text,
    label_stat,
    label_text_x,
    label_text_y,
    label_text_font,
    label_text_size,
    label_text_col,
    label_fill,
    label_fill_alpha,
    border_line_type,
    border_line_width,
    border_line_col,
    border_fill,
    border_fill_alpha
  )
  
  # Record and/or save ---------------------------------------------------------
  
  # Turn off graphics device for saving
  if (getOption("CytoRSuite_cyto_plot_save")) {
    if (inherits(x, getOption("CytoRSuite_cyto_plot_method"))) {
      if (!getOption("CytoRSuite_cyto_plot_custom")) {
        
        # Close graphics device
        dev.off()
      }
      
      # Reset CytoRSuite_cyto_plot_save
      options("CytoRSuite_cyto_plot_save" = FALSE)
      
      # Reset CytoRSuite_cyto_plot_method
      options("cytoRSuite_cyto_plot_method" = NULL)
      
      # Reset custom plotting flag
      options("CytoRSuite_cyto_plot_custom")
    }
  }
  
  # Record plot for assignment
  invisible(recordPlot())
}