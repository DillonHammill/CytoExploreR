## CYTO_SPILLOVER_SPREAD_COMPUTE -----------------------------------------------

#' Compute Spillover Spreading Matrix
#'
#' \code{spillover_spread} computes the spillover spreading matrix as described
#' by Nguyen et al. (2013) using gated and compensated compensation controls.
#'
#' @param x object of class \code{\link[flowCore:flowSet-class]{flowSet}} or
#'   \code{\link[flowWorkspace:GatingSet-class]{GatingSet}} containing pre-gated
#'   single stain compensation controls.
#' @param parent name of the population to use for downstream calculations when
#'   a \code{GatingSet} object is supplied, set to the last gated population by
#'   default (e.g. "Single Cells").
#' @param axes_trans object of class
#'   \code{\link[flowWorkspace:transformerList]{transformerList}}
#'   generated by a \code{cyto_transformer} which contains the transformer
#'   definitions to be used internally to transform the fluorescent channels of
#'   the samples as required.
#' @param channel_match name of csv file to associate a fluorescent channel with
#'   each of the compensation controls. The \code{channel_match} file should
#'   contain a "name" column with the names of the compensation controls and a
#'   "channel" column to associate a fluorescent channel with each compensation
#'   control. Users need not generate this file by hand as it will be created
#'   following the channel selection process.
#' @param compensated logical indicating whether the supplied compensation
#'   controls have been compensated. Compensation controls must be compensated
#'   prior tro calculation of spillover spreading matrix. If \code{compensated}
#'   is set to FALSE, the compensation controls will be compensated internally
#'   using the supplied \code{spillover} matrix.
#' @param spillover name of the output spillover matrix csv file to be used
#'   internally to compensate the compensation controls. If no spillover matrix
#'   is supplied \code{spillover_spread_compute}, the spillover matrix
#'   attached to compensation controls will be applied.
#' @param spillover_spread name of the csv file to which the spillover spreading
#'   matrix will be saved, set to \code{"date-Spillover-Spread-Matrix.csv"} by
#'   default.
#' @param ... additional arguments passed to \code{\link{cyto_plot}}.
#'
#' @references Nguyen R, Perfetto S, Mahnke YD, Chattopadhyay P & Roederer M,
#'   (2013). Quantifying spillover spreading for comparing instrument
#'   performance and aiding in multicolor panel design. Cytometry A,
#'   83(3):306-15.
#'
#' @importFrom flowWorkspace pData
#' @importFrom flowCore Subset parameters exprs
#' @importFrom stats quantile na.omit
#' @importFrom grDevices graphics.off dev.new
#' @importFrom methods is
#'
#' @author Dillon Hammill, \email{Dillon.Hammill@anu.edu.au}
#'
#' @seealso \code{\link{cyto_spillover_compute}}
#' @seealso \code{\link{cyto_spillover_edit}}
#'
#' @name cyto_spillover_spread_compute
NULL

#' @noRd
#' @export
cyto_spillover_spread_compute <- function(x, ...){
  UseMethod("cyto_spillover_spread_compute")
}

#' @rdname cyto_spillover_spread_compute
#' @export
cyto_spillover_spread_compute.GatingSet <- function(x,
                                                    parent = NULL,
                                                    axes_trans = NULL,
                                                    channel_match = NULL,
                                                    compensated = FALSE,
                                                    spillover = NULL,
                                                    spillover_spread = NULL,
                                                    ...){
  
  # Assign x to gs
  gs <- x
  
  # Extract fluorescent channels
  channels <- cyto_fluor_channels(gs)
  
  # Extract Population for Downstream Analyses
  if (!is.null(parent)) {
    fs <- cyto_extract(gs, parent)
  } else if (is.null(parent)) {
    fs <- cyto_extract(gs, cyto_nodes(gs)[length(cyto_nodes(gs))])
  }
  
  # Get complete transformerList
  axes_trans <- .cyto_transformer_complete(gs, axes_trans) 
  
  # Extract transformations applied to the GatingSet
  trans <- gs[[1]]@transformation
  
  # Data should be linear (and compensated)
  if(any(channels %in% names(trans))){
    # Reverse transformations
    gs_trans <- cyto_transformer_combine(trans[channels %in% names(trans)])
    fs <- cyto_transform(fs,
                         gs_trans,
                         inverse = TRUE,
                         plot = FALSE)
  }
  
  # Compensation has been applied
  if(!is.null(gs@compensation[[1]])){
    spillover <- gs@compensation[[1]]
    compensated <- TRUE
  # No compensation has been applied
  }else{
    # Spillover
    if(is.null(spillover)){
      spillover <- fs[[1]]@description$SPILL
    }
    # Apply compensation
    fs <- cyto_compensate(fs, spillover)
    compensated <- TRUE
  }
  
  # Call to flowSet method - data is linear & compensated
  cyto_spillover_spread_compute(
    x = fs,
    axes_trans = axes_trans,
    channel_match = channel_match,
    compensated = compensated,
    spillover = spillover,
    spillover_spread = spillover_spread,
    ...
  )
  
}

#' @rdname cyto_spillover_spread_compute
#' @export
cyto_spillover_spread_compute.flowSet <- function(x,
                                                  axes_trans = NULL,
                                                  channel_match = NULL,
                                                  compensated = FALSE,
                                                  spillover = NULL,
                                                  spillover_spread = NULL,
                                                  ...){
  
  # Assign x to fs - assumed to be LINEAR
  fs <- x
  
  # Data requires compensation
  if(compensated == FALSE){
    fs <- cyto_compensate(fs, spillover)
  }
  
  # Extract pData information
  pd <- cyto_details(fs)
  
  # Extract fluorescent channels
  channels <- cyto_fluor_channels(fs)
  
  # Select a fluorescent channel for each compensation control
  if (is.null(channel_match)) {
    pd$channel <- paste(cyto_channel_select(fs))
    write.csv(pd, paste0(format(Sys.Date(),"%d%m%y"), 
                         "-", "Channel-Match.csv"), row.names = FALSE)
  } else {
    if (is(channel_match, "data.frame") |
        is(channel_match, "matrix") |
        is(channel_match, "tibble")) {
      if (!all(c("name", "channel") %in% colnames(channel_match))) {
        stop("channel_match should contains columns 'name' and 'channel'.")
      }
      cm <- channel_match
      chans <- cm$channel[match(cyto_names(fs), rownames(cm))]
      pd$channel <- paste(chans)
    } else {
      if (getOption("CytoExploreR_wd_check") == TRUE) {
        if (file_wd_check(channel_match)) {
          cm <- read.csv(channel_match, 
                         header = TRUE, 
                         row.names = 1,
                         stringsAsFactors = FALSE)
          chans <- cm$channel[match(cyto_names(fs), row.names(cm))]
          pd$channel <- paste(chans)
        } else {
          stop(paste(channel_match, "is not in this working directory."))
        }
      } else {
        cm <- read.csv(channel_match,
                       header = TRUE, 
                       row.names = 1,
                       stringsAsFactors = FALSE)
        chans <- cm$channel[match(cyto_names(fs), row.names(cm))]
        pd$channel <- paste(chans)
      }
    }
  }

  # Multiple controls per channel
  if(length(unique(pd$channel)) != length(pd$name)){
    lapply(unique(pd$channel), function(z){
      if(nrow(pd[pd$channel == z, ]) > 1){
        # PULL OUT SAMPLES
        fs_copy <- x[pd[pd$channel == z, "name"]]
        # CALCULATE MEDFI
        MEDFI <- suppressMessages(
          cyto_stats_compute(fs_copy,
                             channels = z,
                             stat = "median")[, z]
        )
        # MAXIMUM SIGNAL
        max <- max(MEDFI)
        ind <- which(MEDFI != max)
        remove_names <- MEDFI[ind, "name"]
        # REMOVE SAMPLES - LOW SIGNAL
        fs <<- fs[-match(remove_names, pd$name)]
      }
    })
  }
  
  # Extract summary statistics
  sm <- pData(parameters(fs[[1]]))
  
  # Get complete transformerList
  axes_trans <- .cyto_transformer_complete(fs, axes_trans)
  
  # Get transformed data
  fs <- cyto_transform(fs, 
                       axes_trans,
                       plot = FALSE)
  
  # Universal unstained reference
  if("Unstained" %in% pd$channel){
    
    # Extract unstained control based on selected channels in pData(fs)
    NIL <- fs[[match("Unstained", pd$channel)]]
    fs <- fs[-match("Unstained", pd$channel)]
    
    # Names
    nms <- cyto_names(fs)
    
    # Samples
    smp <- length(fs)
    
    # Remove NIL from pd
    pd <- pd[!pd$channel == "Unstained", ]
    
    # Gate positive populations
    pops <- lapply(seq(1, smp, 1), function(x) {
      
      # Extract flowFrame
      fr <- fs[[x]]
      
      # Channel
      chan <- pd$channel[x]
      
      # Plot
      cyto_plot(NIL,
                channels = chan,
                overlay = fr,
                density_stack = 0,
                axes_trans = axes_trans,
                popup = TRUE,
                density_fill = c("red", "dodgerblue"),
                legend = FALSE,
                density_fill_alpha = 0.6,
                title = nms[x], ...)
      
      # Call cyto_gate_draw on each flowFrame - gate +ve signal selected channel
      gt <- cyto_gate_draw(
        x = fr,
        alias = paste(chan, "+"),
        channels = chan,
        type = "interval",
        density_smooth = 1.5,
        plot = FALSE
      )
      fr <- Subset(fr, gt[[1]])
      
      return(fr)
    })
    names(pops) <- nms
    pops <- flowSet(pops)
    
    # Repeat NIL and convert to flowSet
    NIL <- flowSet(rep(list(NIL), smp))
  
  # Internal reference populations    
  }else{
    
    # Names
    nms <- cyto_names(fs)
    
    # Samples 
    smp <- length(fs)
    
    # List of negative populations
    NIL <- list()
    
    # List of positive populations
    pops <- list()
    
    # Gate positive and negative populations for each control
    lapply(seq(1, smp, 1), function(z){
      
      # Extract flowFrame
      fr <- fs[[z]]
      
      # Channel
      chan <- pd$channel[z]
      
      # Plot
      cyto_plot(fr,
                channels = chan,
                density_stack = 0,
                axes_trans = axes_trans,
                popup = TRUE,
                density_fill = "dodgerblue",
                legend = FALSE,
                density_fill_alpha = 0.6,
                title = nms[z], ...)
      
      # Gate negative population
      gt <- cyto_gate_draw(x = fr,
                           alias = paste(chan, "-"),
                           channels = chan,
                           type = "interval",
                           plot = FALSE)
      NIL[[z]] <<- Subset(fr, gt[[1]])
      
      # Gate positive population
      gt <- cyto_gate_draw(
        x = fr,
        alias = paste(chan, "+"),
        channels = chan,
        type = "interval",
        plot = FALSE
      )
      pops[[z]] <<- Subset(fr, gt[[1]])
      
    })
    
    # Add names to pop lists
    names(NIL) <- nms
    names(pops) <- nms
    
    # Convert NIL and pops to flowSets
    NIL <- flowSet(NIL)
    pops <- flowSet(pops)
    
  }
    
  # Inverse transformations - data should be LINEAR
  pops <- cyto_transform(pops, 
                         axes_trans,
                         inverse = TRUE,
                         plot = FALSE)
  NIL <- cyto_transform(NIL,
                        axes_trans, 
                        inverse = TRUE,
                        plot = FALSE)
    
  # Calculate spillover spread for each compensation control
  SSM <- lapply(seq_len(smp), function(z){
      
    # Extract NIL and pop
    NIL <- NIL[[z]]
    pop <- pops[[z]]
      
    # Channel
    chan <- pd$channel[pd$name == cyto_names(pop)]
      
    # Calculate 50th and 84th percentile for NIL
    NIL_50 <- LAPPLY(channels, function(channel){
      quantile(exprs(NIL)[,channel], 0.5)
    })
    names(NIL_50) <- channels
      
    NIL_84 <- LAPPLY(channels, function(channel){
      quantile(exprs(NIL)[,channel], 0.84)
    })
    names(NIL_84) <- channels
      
    # Combine into a list - NIL_stats
    NIL_stats <- list("50%" = NIL_50, "84%" = NIL_84)
      
    # Calculate 50th and 84th percentile for pop
    pop_50 <- LAPPLY(channels, function(channel){
      quantile(exprs(pop)[,channel], 0.5)
    })
    names(pop_50) <- channels
      
    pop_84 <- LAPPLY(channels, function(channel){
      quantile(exprs(pop)[,channel], 0.84)
    })
    names(pop_84) <- channels
      
    # Combine into a list - pop_stats
    pop_stats <- list("50%" = pop_50, "84%" = pop_84)
    
    # Calculate pop SD
    pop_SD <- pop_stats[[2]] - pop_stats[[1]]
    pop_VAR <- pop_SD^2
    
    # Calculate NIL SD
    NIL_SD <- NIL_stats[[2]] - NIL_stats[[1]]
    NIL_VAR <- NIL_SD^2

    # Difference in VAR of NIL and pop in other detectors
    VAR_diff <- pop_VAR - NIL_VAR
    
    # Replace negative numbers with 0 - stain has less spread than reference
    if(any(VAR_diff < 0)){
      VAR_diff[VAR_diff < 0] <- 0
    }
    
    # Difference in SD of NIL and pop in other detectors
    SD_diff <- sqrt(VAR_diff)

    # Change in fluorescence in primary detector
    signal <- pop_stats[[1]][match(chan, channels)] - 
      NIL_stats[[1]][match(chan, channels)]

    # Spillover spread values
    return(SD_diff/sqrt(signal))
      
  })
    
  # Make matrix
  SSM <- do.call("rbind", SSM)
    
  # Add rownames (channel associated with each control)
  rownames(SSM) <- pd$channel[match(cyto_names(pops), pd$name)]
  
  # Replace diagonal with NA
  lapply(seq(1, nrow(SSM), 1), function(x) {
    SSM[x, match(rownames(SSM)[x], colnames(SSM))] <<- NA
  })
    
  # Sort SSM by column names
  ind <- na.omit(match(colnames(SSM), rownames(SSM)))
  SSM <- SSM[ind, ]
    
  # Turn off pop-up graphics device
  graphics.off()
  dev.new()
    
  # Heatmap label size
  ylab_width <- max(nchar(rownames(SSM))) * 0.02
  xlab_width <- max(nchar(colnames(SSM))) * 0.04  
  
  # Plot heatmap
  superheat::superheat(SSM,
                       title = "Spillover Spreading Matrix \n",
                       title.size = 6,
                       title.alignment = "center",
                       left.label.size = ylab_width,
                       left.label.col = "white",
                       left.label.text.alignment = "right",
                       bottom.label.text.angle = 90,
                       bottom.label.size = xlab_width,
                       bottom.label.col = "white",
                       bottom.label.text.alignment = "right",
                       legend.height = 0.2,
                       legend.vspace = 0,
                       row.title = "Fluorochrome \n",
                       row.title.size = 6,
                       heat.na.col = "grey",
                       heat.pal = c("white",
                                    "steelblue",
                                    "steelblue2",
                                    "steelblue3",
                                    "steelblue4",
                                    "purple",
                                    "mediumorchid",
                                    "orchid",
                                    "magenta",
                                    "deeppink2",
                                    "deeppink4",
                                    "red"),
                       heat.pal.values = c(0,
                                           1,
                                           2,
                                           3,
                                           6,
                                           10,
                                           20,
                                           30,
                                           65,
                                           100,
                                           200,
                                           300))
  
  # Default spillover spread file name
  if(is.null(spillover_spread)){
    spillover_spread <- paste0(format(Sys.Date(), "%d%m%y"),
                               "-Spillover-Spread.csv")
  }
  
  # Write to csv file
  if (!is(spillover_spread, "character")) {
    stop("'spillover_spread' should be the name of a csv file.")
  } else {
    if (!file_ext(spillover_spread) == "csv") {
      paste0(spillover_spread, ".csv")
    }
    write.csv(SSM, spillover_spread)
  }
  
  return(SSM)
}
