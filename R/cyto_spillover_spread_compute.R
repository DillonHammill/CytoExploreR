# CYTO_SPILLOVER_SPREAD_COMPUTE ------------------------------------------------

#' Compute Spillover Spreading Matrix
#'
#' \code{spillover_spread} computes the spillover spreading matrix as described
#' by Nguyen et al. (2013) using gated and compensated compensation controls.
#'
#' @param x object of class \code{\link[flowCore:flowSet-class]{flowSet}} or
#'   \code{\link[flowWorkspace:GatingSet-class]{GatingSet}} containing pre-gated
#'   single stain compensation controls.
#' @param parent name of the population to use for downstream calculations when
#'   a \CODE{GatingSet} object is supplied, set to the last gated population by
#'   default (e.g. "Single Cells").
#' @param axes_trans object of class
#'   \code{\link[flowWorkspace:transformerList-class]{transformerList}}
#'   generated by a \code{cyto_transformer} which contains the transformer
#'   definitions to be used internally to transform the fluorescent channels of
#'   the samples as required.
#' @param channel_match name of csv file to associate a fluorescent channel with
#'   each of the compensation controls. The \code{channel_match} file should
#'   contain a "name" column with the names of the compensation controls and a
#'   "channel" column to associate a fluorescent channel with each compensation
#'   control. Users need not generate this file by hand as it will be created
#'   following the channel selection process.
#' @param compensated logical indicating whether the supplied compensation
#'   controls have been compensated. Compensation controls must be compensated
#'   prior tro calculation of spillover spreading matrix. If \code{compensated}
#'   is set to FALSE, the compensation controls will be compensated internally
#'   using the supplied \code{spillover}.
#' @param spillover name of the output spillover matrix csv file to be used
#'   internally to compensate the compensation controls. If no spillover matrix
#'   is supplied \code{spillover_spread_compute} will look for a
#'   "Spillover-Matrix.csv" file or as a last resort use the spillover matrix
#'   attached to compensation controls.
#' @param spillover_spread name of the csv file to which the spillover spreading
#'   matrix will be saved, set to \code{"date-Spillover-Spread-Matrix.csv"} by
#'   default.
#' @param ... additional arguments passed to \code{\link{cyto_plot}}.
#'
#' @references Nguyen R, Perfetto S, Mahnke YD, Chattopadhyay P & Roederer M,
#'   (2013). Quantifying spillover spreading for comparing instrument
#'   performance and aiding in multicolor panel design. Cytometry A,
#'   83(3):306-15.
#'
#' @author Dillon Hammill, \email{Dillon.Hammill@anu.edu.au}
#'
#' @name cyto_spillover_spread_compute
NULL

#' @noRd
#' @export
cyto_spillover_spread_compute <- function(x, ...){
  UseMethod("cyto_spillover_spread_compute")
}

#' @rdname cyto_spillover_spread_compute
#' @export
cyto_spillover_spread_compute.GatingSet <- function(x,
                                                    parent = NULL,
                                                    axes_trans = NULL,
                                                    channel_match = NULL,
                                                    compensated = FALSE,
                                                    spillover = NULL,
                                                    spillover_spread = NULL,
                                                    ...){
  
  # Assign x to gs
  gs <- x
  
  # Extract fluorescent channels
  channels <- cyto_fluor_channels(gs)
  
  # Extract Population for Downstream Analyses
  if (!is.null(parent)) {
    fs <- cyto_extract(gs, parent)
  } else if (is.null(parent)) {
    fs <- cyto_extract(gs, cyto_nodes(gs)[length(cyto_nodes(gs))])
  }
  
  # Get complete transformerList
  axes_trans <- .cyto_transformer_complete(gs, axes_trans) 
  
  # Extract transformations applied to the GatingSet
  trans <- gs[[1]]@transformation
  
  # Data should be linear (and compensated)
  if(any(channels %in% names(trans))){
    # Reverse transformations
    gs_trans <- cyto_transformer_combine(trans[channels %in% names(trans)])
    fs <- cyto_transform(fs,
                         gs_trans,
                         inverse = TRUE,
                         plot = FALSE)
  }
  
  # Compensation has been applied
  if(!is.null(gs@compensation[[1]])){
    spillover <- gs@compensation[[1]]
    compensated <- TRUE
  # No compensation has been applied
  }else{
    # Spillover
    if(is.null(spillover)){
      if(grepl("Spillover-Matrix.csv", list.files(), ignore.case = TRUE)){
        spillover <- list.files()[grepl("Spillover-Matrix.csv",
                                        list.files(),
                                        ignore.case = TRUE)]
      }else{
        spillover <- fs[[1]]@description$SPILL
      }
    }
    # Apply compensation
    fs <- cyto_compensate(fs, spillover)
    compensated <- TRUE
  }
  
  # Call to flowSet method - data is linear & compensated
  spillover_spread_compute(
    x = fs,
    axes_trans = axes_trans,
    channel_match = channel_match,
    compensated = compensated,
    spillover = spillover,
    spillover_spread = spillover_spread,
    ...
  )
  
}

#' @rdname cyto_spillover_spread_compute
#' @export
cyto_spillover_spread_compute.flowSet <- function(x,
                                                  axes_trans = NULL,
                                                  channel_match = NULL,
                                                  compensated = FALSE,
                                                  spillover = NULL,
                                                  spillover_spread = NULL,
                                                  ...){
  
  # Assign x to fs
  fs <- x
  
  # Compensate samples
  if(compensated == FALSE){
    # Extract spillover matrix
    if(!is.null(spillover)){
      if(getOption("CytoRSuite_wd_check")){
        if(!file_wd_check(spillover)){
          stop(paste(spillover, "does not exist in this working directory."))
        }
      }
      spill <- read.csv(spillover, header = TRUE, row.names = 1)
      colnames(spill) <- rownames(spill)
    }else{
      # Check if Spillover-Matrix.csv exists in wd
      if(length(grep("Spillover-Matrix.csv", list.files())) != 0){
        message("Using file 'Spillover-Matrix.csv' to compensate samples.")
        spill <- read.csv(list.files()[grep("Spillover-Matrix.csv",
                                            list.files())[1]],
                          header = TRUE, row.names = 1)
        colnames(spill) <- rownames(spill)
      }else{
        spill <- fs[[1]]@description$SPILL
      }
    }
    
    # Apply compensation
    if (inherits(fs, "ncdfFlowSet")) {
      fs <- suppressMessages(ncfsApply(fs, function(fr) {
        compensate(fr, spill)
      }))
    } else if (inherits(fs, "flowSet")) {
      fs <- suppressMessages(fsApply(fs, function(fr) {
        compensate(fr, spill)
      }))
    }
  }
  
  # Extract pData information
  pd <- pData(fs)
  
  # Extract fluorescent channels
  channels <- cyto_fluor_channels(fs)
  
  # Select a fluorescent channel for each compensation control
  if (is.null(channel_match)) {
    pd$channel <- paste(cyto_channel_select(fs))
    write.csv(pd, "Compensation-Channels.csv", row.names = FALSE)
  } else {
    if (inherits(channel_match, "data.frame") |
        inherits(channel_match, "matrix") |
        inherits(channel_match, "tibble")) {
      if (!all(c("name", "channel") %in% colnames(channel_match))) {
        stop("channel_match should contains columns 'name' and 'channel'.")
      }
      cm <- channel_match
      chans <- cm$channel[match(cyto_names(fs), rownames(cm))]
      pd$channel <- paste(chans)
    } else {
      if (getOption("CytoRSuite_wd_check") == TRUE) {
        if (file_wd_check(channel_match)) {
          cm <- read.csv(channel_match, header = TRUE, row.names = 1)
          chans <- cm$channel[match(cyto_names(fs), row.names(cm))]
          pd$channel <- paste(chans)
        } else {
          stop(paste(channel_match, "is not in this working directory."))
        }
      } else {
        cm <- read.csv(channel_match, header = TRUE, row.names = 1)
        chans <- cm$channel[match(cyto_names(fs), row.names(cm))]
        pd$channel <- paste(chans)
      }
    }
  }
  
  # Merge files for use with estimateLogicle
  fr <- as(fs, "flowFrame")
  
  # Extract summary statistics
  sm <- pData(parameters(fs[[1]]))
  
  # Get complete transformList object
  axes_trans <- .getCompleteTransList(fr, axes_trans)
  
  # Get transformed data - all fluorescent channels transformed
  fs <- .getTransformedData(fs, axes_trans)
  
  # Extract unstained control based on selected channels in pData(fs)
  NIL <- fs[[match("Unstained", pd$channel)]]
  fs <- fs[-match("Unstained", pd$channel)]
  
  # Names
  nms <- cyto_names(fs)
  
  # Samples
  smp <- length(fs)
  
  # Remove NIL from pd
  pd <- pd[!pd$channel == "Unstained", ]
  
  # Gate positive populations
  pops <- lapply(seq(1, smp, 1), function(x) {
    
    # Extract flowFrame
    fr <- fs[[x]]
    
    # Channel
    chan <- pd$channel[x]
    
    # Plot
    if (getOption("CytoRSuite_interact") == TRUE) {
      cyto_plot(NIL,
                channels = chan,
                overlay = fr,
                density_stack = 0,
                axes_trans = axes_trans,
                popup = TRUE,
                density_fill = c("red", "dodgerblue"),
                legend = FALSE,
                density_fill_alpha = 0.6,
                title = nms[x], ...
      )
    } else {
      cyto_plot(NIL,
                channels = chan,
                overlay = fr,
                density_stack = 0,
                axes_trans = axes_trans,
                density_fill = c("red", "dodgerblue"),
                legend = FALSE,
                density_fill_alpha = 0.6,
                title = nms[x], ...
      )
    }
    
    # Call gate_draw on each flowFrame using interval gate on selected channel
    if (getOption("CytoRSuite_interact") == TRUE) {
      gt <- gate_draw(
        x = fr,
        alias = paste(chan, "+"),
        channels = chan,
        type = "interval",
        density_smooth = 1.5,
        plot = FALSE
      )
      fr <- Subset(fr, gt[[1]])
    }
    
    return(fr)
  })
  names(pops) <- nms
  pops <- flowSet(pops)
  
  # Inverse logicle transformation
  inv <- cyto_transform_extract(axes_trans, inverse = TRUE)
  pops <- suppressMessages(transform(pops, inv))
  NIL <- suppressMessages(transform(NIL, inv))
  
  # Calculate 50th & 80th percentile in all channels for NIL
  NIL_50 <- LAPPLY(channels, function(channel){
    quantile(exprs(NIL)[,channel], 0.5)
  })
  names(NIL_50) <- channels
  
  NIL_84 <- LAPPLY(channels, function(channel){
    quantile(exprs(NIL)[,channel], 0.84)
  })
  names(NIL_84) <- channels
  
  # Combine into a list - NIL_stats
  NIL_stats <- list("50%" = NIL_50, "84%" = NIL_84)
  
  # Calculate 50th and 84th percentile in all channels for each control
  POS_stats <- lapply(seq_len(length(pops)), function(x){
    
    # Calculate 50th & 80th percentile in all channels
    POP_50 <- LAPPLY(channels, function(channel){
      quantile(exprs(pops[[x]])[,channel], 0.5)
    })
    names(POP_50) <- channels
    
    POP_84 <- LAPPLY(channels, function(channel){
      quantile(exprs(pops[[x]])[,channel], 0.84)
    })
    names(POP_84) <- channels
    
    # Combine into a list - NIL_stats
    POP_stats <- list("50%" = POP_50, "84%" = POP_84)
    
    return(POP_stats)
    
  })
  names(POS_stats) <- pd$channel
  
  # Calculate POS signal in other detectors
  POS_signal <- lapply(seq_len(length(POS_stats)), function(x){
    
    POS_stats[[x]][[2]] - POS_stats[[x]][[1]]
    
  })
  names(POS_signal) <- pd$channel
  
  # Calculate NIL signal in other detectors
  NIL_signal <- NIL_stats[[2]] - NIL_stats[[1]] 
  names(NIL_signal) <- pd$channel
  
  # Difference
  DIFF <- lapply(seq_len(length(POS_signal)), function(x){
    sqrt(POS_signal[[x]]^2) - sqrt(NIL_signal^2)
  })
  names(DIFF) <- pd$channel
  
  # Brightness
  BRGHT <- lapply(seq_len(length(POS_signal)), function(x){
    POS_signal[[x]][match(names(POS_signal[x]), channels)] - 
      NIL_stats[[1]][match(names(POS_signal[x]),channels)]
  })
  names(BRGHT) <- pd$channel
  
  # SSM
  SSM <- lapply(DIFF, function(x){
    
    x/(sqrt(BRGHT[[1]]))
    
  })
  
  # Make matrix
  SSM <- do.call("rbind", SSM)
  
  # Replace diagonal with NA
  lapply(seq(1, nrow(SSM), 1), function(x) {
    SSM[x, match(rownames(SSM)[x], colnames(SSM))] <<- NA
  })
  
  # Sort SSM by column names
  ind <- na.omit(match(colnames(SSM), rownames(SSM)))
  SSM <- SSM[ind, ]
  
  # Turn off pop-up graphics device
  graphics.off()
  dev.new()
  
  # Heatmap label size
  ylab_width <- max(nchar(rownames(SSM))) * 0.02
  xlab_width <- max(nchar(colnames(SSM))) * 0.04               
  
  # Plot heatmap
  superheat::superheat(SSM,
                       title = "Spillover Spreading Matrix \n",
                       title.size = 6,
                       title.alignment = "center",
                       bottom.label.text.angle = 90,
                       left.label.size = ylab_width,
                       bottom.label.size = xlab_width,
                       left.label.text.alignment = "center",
                       legend.height = 0.2,
                       legend.vspace = 0.2,
                       row.title = "Fluorochrome \n",
                       row.title.size = 6,
                       heat.na.col = "white",
                       heat.pal =)
  
  # Write to csv file
  if (!inherits(spillover_spread, "character")) {
    stop("'spillover_spread' should be the name of a csv file.")
  } else {
    if (!file_ext(spillover_spread) == "csv") {
      paste0(spillover_spread, ".csv")
    }
    write.csv(SSM, spillover_spread)
  }
  
  return(SSM)
}
