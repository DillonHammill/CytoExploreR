#' Add boxed text labels to cyto_plot
#'
#' Interactively label existing plots with boxed labels containing text and
#' statistics.
#'
#' @param x object of class \code{"flowFrame"}.
#' @param channels a vector indicating the fluorescent channel(s) to be used for
#'   gating.
#' @param gate object of class
#'   \code{\link[flowCore:rectangleGate-class]{rectangleGate}},
#'   \code{\link[flowCore:polygonGate-class]{polygonGate}},
#'   \code{\link[flowCore:ellipsoidGate-class]{ellipsoidGate}}, \code{"list"} or
#'   \code{\link[flowCore:filters-class]{filters}}.
#' @param label_text character string to include in the label above the
#'   statistic (e.g. population name(s)).
#' @param label_stat indicates the type of statistic to include in the label,
#'   can be either code{"count"}, \code{"median"}, \code{"mean"}, \code{"mode"},
#'   \code{"geo mean"} or \code{"CV"}. Only count and percent statistics are
#'   supported for 2D plots.
#' @param label_text_x vector containing the x co-ordinates for the plot labels.
#'   Label positions can be interactively selected if no co-ordinates are
#'   manually supplied.
#' @param label_text_y vector containing the x co-ordinates for the plot labels.
#'   Label positions can be interactively selected if no co-ordinates are
#'   manually supplied.
#' @param trans object of class
#'   \code{\link[flowWorkspace]{transformerList}} which was used to
#'   transform the fluorescent channels of the supplied flowFrame.
#' @param negate logical indicating whether a label should be included for the
#'   neagted population (i.e. events outside the gate). Set to FALSE by default
#'   to only calculate statistics for events within the gate.
#' @param label_text_font integer [1,2,3,4] passed to \code{text} to alter the
#'   font, set to \code{2} by default for a bold font.
#' @param label_text_size numeric character expansion used to control the size
#'   of the text in the labels, set to \code{0.8} by default. See \code{?text}
#'   for details.
#' @param label_text_col specify text colour in label for each gate, defaults to
#'   \code{"black"} for all gates.
#' @param label_fill fill colour to use for labels, set to "white" by default.
#' @param label_fill_alpha numeric [0,1] controls the transparency of the fill
#'   colour, set to \code{0.6} by default.
#' @param display numeric [0,1] to control the percentage of events to be
#'   plotted. Specifying a value for \code{display} can substantial improve
#'   plotting speed for less powerful machines.
#' @param density_smooth smoothing parameter passed to
#'   \code{\link[stats:density]{density}} to adjust kernel density for mode
#'   calculation.
#'
#' @return add a boxed text label to an existing cyto_plot.
#'
#' @importFrom flowCore Subset
#'
#' @examples
#' library(CytoRSuiteData)
#'
#' # Load in samples
#' fs <- Activation
#' gs <- GatingSet(fs)
#'
#' # Apply compensation
#' gs <- compensate(gs, fs[[1]]@description$SPILL)
#'
#' # Transform fluorescent channels
#' trans <- estimateLogicle(gs[[4]], cyto_fluor_channels(fs))
#' gs <- transform(gs, trans)
#'
#' # Gate using gate_draw
#' gating(Activation_gatingTemplate, gs)
#'
#' # Plot
#' cyto_plot(gs[[32]],
#'   parent = "CD4 T Cells",
#'   channels = c("CD69")
#' )
#'
#' # Label - median fluorescent intensity
#' cyto_plot_label2(getData(gs, "CD4 T Cells")[[32]],
#'   channels = "CD69",
#'   label_stat = "median",
#'   label_text = "MedFI",
#'   trans = trans,
#'   label_text_x = 3,
#'   label_text_y = 50
#' )
#'
#' # Label - no statistic
#' cyto_plot_label2(
#'   label_text = "Activated \n Cells",
#'   label_text_x = 3,
#'   label_text_y = 25,
#'   label_fill = "red"
#' )
#' @author Dillon Hammill (Dillon.Hammill@anu.edu.au)
#'
#' @export
cyto_plot_label2 <- function(x,
                             channels,
                             gate = NA,
                             label_text = NA,
                             label_stat = NA,
                             label_text_x = NA,
                             label_text_y = NA,
                             trans = NA,
                             negate = FALSE,
                             display = 1,
                             label_text_font = 2,
                             label_text_size = 0.8,
                             label_text_col = "black",
                             label_fill = "white",
                             label_fill_alpha = 0.6,
                             density_smooth = 0.6) {

  # x must be a flowFrame
  if (!missing(x)) {
    if (!inherits(x, "flowFrame")) {
      stop("'x' must be a flowFrame object.")
    }
  }

  # Sample if required to get sampled statistics
  if(display != 1){
    x <- cyto_sample(x, display = display, seed = 56)
  }
  
  # Convert to valid statistic
  if (!.all_na(label_stat)) {
    label_stat <- LAPPLY(label_stat, function(z) {
      .cyto_stat_check(z)
    })
  }

  # Check for statistics
  if (!.all_na(label_stat)) {

    # Only 'count' valid for 2D plots without gates
    if (length(channels) == 2 & .all_na(gate) & !all(label_stat == "count")) {
      stop("Only 'count' is supported for 2D plots without gates.")
    }

    # Only count, freq and CV are supported in 2D plots
    if (length(channels) == 2 & !all(label_stat %in% c("count", "freq"))) {
      stop("Only 'count' and 'frequency' are supported in 2D plots.")
    }

    # Freq only supported if gates supplied
    if (label_stat == "freq" & .all_na(gate)) {
      stop("Supply gate objects to 'gate' to calculate frequency.")
    }
  }

  # Convert gate to list of gate objects
  if (!.all_na(gate)) {
    if (!inherits(gate, "list")) {
      if (inherits(gate, "rectangleGate") |
        inherits(gate, "polygonGate") |
        inherits(gate, "ellipsoidGate")) {
        gate <- list(gate)
      } else if (inherits(gate, "filters")) {
        gate <- unlist(gate)
      }
    } else {
      gate <- unlist(gate)
    }
  }

  # Gates supplied - pull out populations
  if (!.all_na(label_stat)) {
    if (!.all_na(gate)) {
      if (negate == FALSE) {
        pops <- lapply(seq_len(length(gate)), function(z) {
          Subset(x, gate[[z]])
        })
      } else if (negate == TRUE) {
        gate_filter <- do.call("|", gate)
        pops <- list(split(x, gate_filter)[[2]])
      }
    } else {
      pops <- list(x)
    }
  }

  # Calculate statistics per gate
  if (!.all_na(label_stat)) {
    st <- LAPPLY(pops, function(z) {
      if (label_stat == "freq") {
        sts <- .cyto_count(z) / .cyto_count(x) * 100
        sts <- .round(sts, 2)
        sts <- paste(sts, "%")
      } else {
        sts <- cyto_stats_compute(z,
          channels = channels,
          trans = trans,
          stat = label_stat,
          format = "long",
          density_smooth = density_smooth
        )
        sts <- LAPPLY(sts[, ncol(sts)], function(x){.round(x, 2)})
      }
      return(sts)
    })
  } else {
    st <- NA
  }
  
  # PLOT LABELS ----------------------------------------------------------------
  label_text_xy <- mapply(
    function(label_text,
                 st,
                 label_text_x,
                 label_text_y,
                 label_text_font,
                 label_text_size,
                 label_text_col,
                 label_fill,
                 label_fill_alpha) {

      # Co-ordinates can be interactively selected
      if (any(.all_na(c(label_text_x, label_text_y)))) {
        message("Select a location on the plot the position the label.")
        label_text_xy <- locator(n = 1)
        label_text_x <- label_text_xy[[1]]
        label_text_y <- label_text_xy[[2]]
      }

      # Add labels to plot
      if (!.all_na(label_text) & !.all_na(label_stat)) {
        .boxed.labels(
          x = label_text_x,
          y = label_text_y,
          labels = paste(label_text, st, sep = "\n"),
          border = FALSE,
          font = label_text_font,
          cex = label_text_size,
          col = label_text_col,
          bg = label_fill,
          alpha.bg = label_fill_alpha
        )
      } else if (!.all_na(label_text) & .all_na(label_stat)) {
        .boxed.labels(
          x = label_text_x,
          y = label_text_y,
          labels = label_text,
          border = FALSE,
          font = label_text_font,
          cex = label_text_size,
          col = label_text_col,
          bg = label_fill,
          alpha.bg = label_fill_alpha
        )
      } else if (.all_na(label_text) & !.all_na(label_stat)) {
        .boxed.labels(
          x = label_text_x,
          y = label_text_y,
          labels = st,
          border = FALSE,
          font = label_text_font,
          cex = label_text_size,
          col = label_text_col,
          bg = box_fill,
          alpha.bg = box_alpha
        )
      }
      
      # RETURN LABEL CO-ORDINATES
      return(c(label_text_X, label_text_y))
      
    },
    label_text,
    st,
    label_text_x,
    label_text_y,
    label_text_font,
    label_text_size,
    label_text_col,
    label_fill,
    label_fill_alpha,
    SIMPLIFY = FALSE
  )
  
  # RETURN LABEL CO-ORDINATES --------------------------------------------------
  
  # LABEL CO-ORDINATES IN MATRIX
  label_text_xy <- do.call("rbind", label_text_xy)
  colnames(label_text_xy) <- c("x","y")
  label_text_xy <- as.matrix(label_text_xy)
  
  # RETURN LABEL CO-ORDINATES
  invisible(label_text_xy)
  
}
