## CYTO_PLOT_EMPTY -------------------------------------------------------------

#' Create an empty cyto_plot
#'
#' \code{cyto_plot_empty} generates to base for cyto_plot by creating an empty
#' plot with border, axes, axes_text and titles. Data is subsequently added to
#' this base layer with \code{cyto_plot_point} or \code{cyto_plot_hist}.
#'
#' @param x object of class \code{\link[flowCore:flowFrame-class]{flowFrame}}.
#' @param channels name of the channel(s) or marker(s) to be used to construct
#'   the plot. The length of channels determines the type of plot to be
#'   constructed, either a 1-D density distribution for a single channel or a
#'   2-D scatterplot with blue-red colour scale for two channels.
#' @param axes_trans object of class
#'   \code{\link[flowCore:transformList-class]{transformList}} or
#'   \code{\link[flowWorkspace]{transformerList}} generated by
#'   \code{\link[flowCore:logicleTransform]{estimateLogicle}} which was used to
#'   transform the fluorescent channels of the supplied flowFrame. This
#'   transformation object will be used internally to ensure that the axes
#'   labels of the plot are appropriately transformed. The transformation object
#'   will NOT be applied to the flowFrame internally and should be applied to
#'   the flowFrame prior to plotting.
#' @param overlay a list of flowFrames to overlay onto the plot.
#' @param gate list of gate objects to be plotted, used internlaly to ensure
#'   gate co-ordinates are taken into account when computing axes limits.
#' @param xlim lower and upper limits of x axis (e.g. c(0,5)).
#' @param ylim lower and upper limits of y axis (e.g. c(0,5)).
#' @param axes_limits options include \code{"auto"}, \code{"data"} or
#'   \code{"machine"} to use optimised, data or machine limits respectively. Set
#'   to \code{"auto"} by default to use optimised axes ranges. Fine control over
#'   axes limits can be obtained by altering the \code{xlim} and \code{ylim}
#'   arguments.
#' @param axes_limits_buffer decimal indicating the percentage of buffering to
#'   add to either end of the axes limits, set to 0.03 by default.
#' @param title title to use for the plot, set to the name of the sample by
#'   default. Title can be removed by setting this argument to \code{NA}.
#' @param xlab x axis label.
#' @param ylab y axis label.
#' @param margins a vector of length 4 to control the margins around the bottom,
#'   left, top and right of the plot, set to c(NA, NA, NA, NA) by default to let
#'   `cyto_plot` compute optimal margins.
#' @param hist_stat can be either \code{"count"}, \code{"percent"} or
#'   \code{"density"} to indicate the statistic to display on histograms, set to
#'   \code{"percent"} by default. The \code{"percent"} option applies modal
#'   normalisation and expresses the result as a percentage.
#' @param hist_smooth smoothing parameter passed to
#'   \code{\link[stats:density]{density}} to adjust the smoothness of the kernel
#'   density for histograms, set to \code{0.6} by default.
#' @param hist_stack numeric [0,1] indicating the degree of stacking for
#'   histograms, set to \code{0} by default.
#' @param hist_layers numeric indicating the number of histograms to stack in
#'   each plot, set to all samples by default. Each plot must contain the same
#'   number of histograms.
#' @param hist_cols vector colours to draw from when selecting histogram fill
#'   colours if none are supplied to \code{hist_fill}.
#' @param hist_fill fill colour(s) for histograms, select from \code{hist_cols}
#'   if not supplied.
#' @param hist_fill_alpha numeric [0,1] used to control histogram fill colour
#'   transparency, set to \code{1} by default for solid colours.
#' @param hist_line_type line type(s) to use for histogram borders, set to 1 by
#'   default to use solid lines. See \code{\link[graphics:par]{lty}} for
#'   alternatives.
#' @param hist_line_width numeric to control line width(s) for histogram borders
#'   lines, set to 1 by default.
#' @param hist_line_col colour(s) for histogram borders, set to \code{"black"}
#'   by default.
#' @param point_shape shape(s) to use for points in 2-D scatterplots, set to
#'   \code{"."} by default to maximise plotting speed.  See
#'   \code{\link[graphics:par]{pch}} for alternatives.
#' @param point_size numeric to control the size of points in 2-D scatter plots
#'   set to 2 by default.
#' @param point_col_scale vector of colours to use for density gradient.
#' @param point_cols vector colours to draw from when selecting colours for
#'   points if none are supplied to point_col.
#' @param point_col colour(s) to use for points in 2-D scatter plots, set to NA
#'   by default to use a blue-red density colour scale.
#' @param point_col_alpha numeric [0,1] to control point colour transparency in
#'   2-D scatter plots, set to 1 by default to use solid colours.
#' @param axes_text logical vector of length 2 indicating whether axis text
#'   should be included for the x and y axes respectively, set to
#'   \code{c(TRUE,TRUE)} by default to display axes text on both axes.
#' @param axes_text_font numeric indicating the font to use for axes, set to 1
#'   for plain font by default. See \code{\link[graphics:par]{?par}} font for
#'   details.
#' @param axes_text_size character expansion for axis text.
#' @param axes_text_col colour of axis text.
#' @param axes_label_text_font numeric indicating the font to use for title, set
#'   to 1 for plain font by default. See \code{\link[graphics:par]{?par}} font
#'   for details.
#' @param axes_label_text_size character expansion for axis labels.
#' @param axes_label_text_col colour of axis labels.
#' @param title_text_font numeric indicating the font to use for title, set to 2
#'   for bold font by default. See \code{\link[graphics:par]{?par}} font for
#'   details.
#' @param title_text_size character expansion for plot title.
#' @param title_text_col colour for plot title.
#' @param border_line_type line type to use for plot border, set to 1 by default
#'   for a sold border.
#' @param border_line_width line width for plot border, set to 1 by default.
#' @param border_line_col line colour for plot border, set to "black" by
#'   default.
#' @param border_fill colour to use for the plot background, set to "white" by
#'   default.
#' @param border_fill_alpha transparency to use for border_fill colour, set to 1
#'   by default to add no transparency.
#' @param legend can be either \code{"line"} or \code{"fill"} to indicate
#'   whether a legend should be constructed based on the density \code{"line"}
#'   or \code{"fill"}, set to FALSE by default to remove the legend.
#' @param legend_text vector of labels to use in the legend.
#' @param legend_text_font numeric to control the font of legend text, set to 1
#'   for plain font by default. See \code{\link[graphics:par]{font}} for
#'   alternatives.
#' @param legend_text_size numeric to control the size of text in the legend,
#'   set to 1 by default.
#' @param legend_text_col colour(s) to use for text in legend, set to
#'   \code{"black"} by default.
#' @param legend_line_type numeric to control the line type for line legends,
#'   set to 1 by default. Refer to \code{lty} in \code{\link[graphics:par]{par}}
#'   for alternatives.
#' @param legend_line_width numeric to control the line width in line legend,
#'   set to 1 by default. Refer to \code{lwd} in \code{\link[graphics:par]{par}}
#'   for alternatives.
#' @param legend_line_col colour(s) to use for the lines in 1-D plot legends
#'   when legend is set to \code{"line"}.
#' @param legend_box_fill fill colour(s) to use for the boxes in 1-D plot
#'   legends when legend is set to \code{"fill"}.
#' @param legend_point_col colour(s) to use for points in 2-D scatter plot
#'   legend.
#' @param grid logical indicating whether to include grid lines in the plot
#'   background, set to TRUE by default. Alternatively, users can supply a
#'   integer to indicate the number of equally spaced quantiles to used for the
#'   grid lines.
#' @param grid_line_type integer [0,6] to control the line type of grid lines,
#'   set to \code{1} to draw solid lines by default. See
#'   \code{\link[graphics:par]{lty}} for alternatives.
#' @param grid_line_width numeric to control the line width(s) of grid lines,
#'   set to \code{1} by default.
#' @param grid_line_col colour to use for grid lines, set to \code{"grey95"} by
#'   default.
#' @param grid_line_alpha numeric [0,1] to control the transparency of grid
#'   lines, set to 1 by default to remove transparency.
#' @param ... not in use.
#'
#' @importFrom grDevices adjustcolor rgb colorRamp
#' @importFrom graphics plot box axis title par rect axTicks abline
#' @importFrom methods formalArgs is
#'
#' @author Dillon Hammill (Dillon.Hammill@anu.edu.au)
#'
#' @examples
#' library(CytoExploreRData)
#'
#' # Construct an empty 2D plot with black background
#' cyto_plot_empty(Activation[[32]],
#'   channels = c("FSC-A", "SSC-A"),
#'   border_fill = "black"
#' )
#'
#' # Construct an empty 1D plot
#' cyto_plot_empty(Activation[[32]],
#'   channels = c("FSC-A"),
#'   overlay = Activation[1:2]
#' )
#' @export
cyto_plot_empty <- function(x,
                            channels,
                            axes_trans = NA,
                            overlay = NA,
                            gate = NA,
                            xlim = c(NA, NA),
                            ylim = c(NA, NA),
                            axes_limits = "auto",
                            axes_limits_buffer = 0.03,
                            title,
                            xlab,
                            ylab,
                            margins = c(NA, NA, NA, NA),
                            hist_stat = "count",
                            hist_smooth = 1.5,
                            hist_stack = 0.5,
                            hist_cols = NA,
                            hist_fill = NA,
                            hist_fill_alpha = 1,
                            hist_line_type = 1,
                            hist_line_width = 1,
                            hist_line_col = "black",
                            point_shape = ".",
                            point_size = 2,
                            point_col_scale = NA,
                            point_cols = NA,
                            point_col = NA,
                            point_col_alpha = 1,
                            axes_text = c(TRUE, TRUE),
                            axes_text_font = 1,
                            axes_text_size = 1,
                            axes_text_col = "black",
                            axes_label_text_font = 1,
                            axes_label_text_size = 1.1,
                            axes_label_text_col = "black",
                            title_text_font = 2,
                            title_text_size = 1.1,
                            title_text_col = "black",
                            border_line_type = 1,
                            border_line_width = 1,
                            border_line_col = "black",
                            border_fill = "white",
                            border_fill_alpha = 1,
                            legend = FALSE,
                            legend_text,
                            legend_text_font = 1,
                            legend_text_size = 1,
                            legend_text_col = "black",
                            legend_line_type = NA,
                            legend_line_width = NA,
                            legend_line_col = NA,
                            legend_box_fill = NA,
                            legend_point_col = NA,
                            grid = TRUE,
                            grid_line_type = 1,
                            grid_line_width = 1,
                            grid_line_col = "grey95",
                            grid_line_alpha = 1,
                            ...) {

  # PREPARE X ------------------------------------------------------------------

  # X CAN BE EITHER FLOWFRAME/FLOWFRAME LIST/CYTO_PLOT ARGUMENTS

  # HISTOGRAMS - CYTO_PLOT ARGUMENTS
  d <- NULL

  # FLOWFRAME
  if (is(x, "flowFrame")) {
    overlay <- cyto_list(overlay)
    if (!.all_na(overlay)) {
      x <- c(
        structure(list(x), names = cyto_names(x)),
        overlay
      )
    }
    # CYTO_PLOT ARGUMENTS
  } else if (class(x) == "cyto_plot") {
    .args_update(x)
  }

  # GRAPHICAL PARAMETERS -------------------------------------------------------

  # Prevent scientific notation on axes - reset on exit
  scipen <- getOption("scipen")
  options(scipen = 100000000)
  on.exit(options(scipen = scipen))

  # Extract current graphics parameters
  pars <- par("mar")

  # Reset graphics parameters on exit
  on.exit(par(pars))

  # ARGUMENTS ------------------------------------------------------------------

  # Pull down arguments to named list
  args <- .args_list()

  # Inherit arguments from cyto_plot_theme
  args <- .cyto_plot_theme_inherit(args)

  # Update arguments
  .args_update(args)

  # CHANNELS -------------------------------------------------------------------

  # Check channels
  channels <- cyto_channels_extract(
    x[[1]],
    channels
  )

  # AXES LIMITS ----------------------------------------------------------------

  # XLIM
  if (any(is.na(xlim))) {
    # XLIM
    xlim[is.na(xlim)] <- .cyto_plot_axes_limits(x,
      channels = channels[1],
      axes_limits = axes_limits,
      buffer = axes_limits_buffer,
      plot = TRUE
    )[, 1][is.na(xlim)]
  }

  # YLIM
  if (any(is.na(ylim))) {
    # 1D PLOT
    if (length(channels) == 1) {
      if (is.null(d)) {
        d <- .cyto_plot_hist(x,
          hist_stat = hist_stat,
          hist_smooth = hist_smooth,
          hist_bandwidth = hist_bandwidth,
          hist_stack = hist_stack
        )
      }
      # YLIM
      ymin <- as.numeric(unlist(strsplit(names(d)[1], "-"))[1])
      ymax <- max(
        LAPPLY(names(d), function(z) {
          as.numeric(unlist(strsplit(z, "-"))[2])
        }),
        na.rm = TRUE
      )
      yrng <- c(ymin, ymax)
      ylim[is.na(ylim)] <- yrng[is.na(ylim)]
      # 2D PLOT
    } else if (length(channels) == 2) {
      # YLIM
      ylim[is.na(ylim)] <- .cyto_plot_axes_limits(x,
        channels = channels[2],
        axes_limits = axes_limits,
        buffer = axes_limits_buffer,
        plot = TRUE
      )[, 1][is.na(ylim)]
    }
  }

  # GATE COORDS MUST BE WITHIN AXES LIMITS
  if (!.all_na(gate)) {
    # GATE COORDS
    gate_coords <- .cyto_gate_coords(gate, channels)
  }

  # XLIM GATE COORD ADJUSTMENT
  if (!.all_na(gate)) {
    # MIN & MAX GATE COORDS
    gate_xcoords <- gate_coords[, channels[1]]
    gate_xcoords <- c(min(gate_xcoords), max(gate_xcoords))
    # GATE COORDS BELOW XMIN
    if (is.finite(gate_xcoords[1]) & gate_xcoords[1] < xlim[1]) {
      xlim[1] <- gate_xcoords[1]
    }
    # GATE COORDS ABOVE XMAX
    if (is.finite(gate_xcoords[2]) & gate_xcoords[2] > xlim[2]) {
      xlim[2] <- gate_xcoords[2]
    }
  }

  # YLIM GATE COORD ADJUSTMENT
  if (length(channels) == 2) {
    # GATE COORDS
    if (!.all_na(gate)) {
      # MIN & MAX GATE COORDS
      gate_ycoords <- gate_coords[, channels[2]]
      gate_ycoords <- c(min(gate_ycoords), max(gate_ycoords))
      # GATE COORDS BELOW YMIN
      if (is.finite(gate_ycoords[1]) & gate_ycoords[1] < ylim[1]) {
        ylim[1] <- gate_ycoords[1]
      }
      # GATE COORDS ABOVE YMAX
      if (is.finite(gate_ycoords[2]) & gate_ycoords[2] > ylim[2]) {
        ylim[2] <- gate_ycoords[2]
      }
    }
  }

  # AXES TEXT ------------------------------------------------------------------

  # Convert axes_text to list - allows inheritance from cyto_plot
  if (!is(axes_text, "list")) {
    axes_text <- list(axes_text[1], axes_text[2])
  }

  # X axis breaks and labels -  can be inherited from cyto_plot
  if (!is(axes_text[[1]], "list")) {
    if (.all_na(axes_text[[1]])) {
      # NA == TRUE returns NA not T/F
    } else if (axes_text[[1]] == TRUE) {
      lims <- list(xlim)
      names(lims) <- channels[1]
      axes_text[[1]] <- .cyto_plot_axes_text(x,
        channels = channels[1],
        axes_trans = axes_trans,
        axes_range = lims,
        axes_limits = axes_limits
      )[[1]]
    }
  }

  # Y axis breaks and labels - can be inherited from cyto_plot
  if (!is(axes_text[[2]], "list")) {
    if (.all_na(axes_text[[2]])) {
      # NA == TRUE returns NA not T/F
    } else if (axes_text[[2]] == TRUE) {
      if (length(channels) == 2) {
        lims <- list(ylim)
        names(lims) <- channels[2]
        axes_text[[2]] <- .cyto_plot_axes_text(x,
          channels = channels[2],
          axes_trans = axes_trans,
          axes_range = lims,
          axes_limits = axes_limits
        )[[1]]
      } else {
        axes_text[[2]] <- NA
      }
    }
  }

  # Turn off y axis labels for stacked overlays
  if (length(x) > 1 &
    hist_stack != 0 &
    length(channels) == 1) {
    axes_text <- list(axes_text[[1]], FALSE)
  }

  # AXES LABELS ----------------------------------------------------------------

  # AXES LABELS - missing replaced - NA removed
  axes_labels <- .cyto_plot_axes_label(x,
    channels = channels,
    xlab = xlab,
    ylab = ylab,
    hist_stat
  )
  xlab <- axes_labels[[1]]
  ylab <- axes_labels[[2]]

  # TITLE ----------------------------------------------------------------------

  # TITLE - missing replaced - NA removed
  title <- .cyto_plot_title(x,
    channels = channels,
    title = title
  )

  # MARGINS --------------------------------------------------------------------

  # Set plot margins - set par("mar")
  .cyto_plot_margins(x,
    channels = channels,
    legend = legend,
    legend_text = legend_text,
    legend_text_size = legend_text_size,
    title = title,
    axes_text = axes_text,
    margins = margins,
    point_col = point_col
  )

  # PLOT CONSTRUCTION ----------------------------------------------------------

  # Plot
  graphics::plot(1,
    type = "n",
    axes = FALSE,
    xlim = xlim,
    ylim = ylim,
    xlab = "",
    ylab = "",
    bty = "n"
  )

  # X AXIS - TRANSFORMED
  if (is(axes_text[[1]], "list")) {
    # MINOR TICKS
    x_mnr_ind <- which(as.character(axes_text[[1]]$label) == "")
    axis(1,
      at = axes_text[[1]]$at[x_mnr_ind],
      labels = axes_text[[1]]$label[x_mnr_ind],
      tck = -0.015
    )

    # MAJOR TICKS - MUST BE >2% XRANGE FROM ZERO
    x_mjr_ind <- which(as.character(axes_text[[1]]$label) != "")
    x_mjr <- list(
      "at" = axes_text[[1]]$at[x_mjr_ind],
      "label" = axes_text[[1]]$label[x_mjr_ind]
    )
    # Zero included on plot
    if (any(as.character(x_mjr$label) == "0")) {
      zero <- which(as.character(x_mjr$label) == "0")
      zero_break <- x_mjr$at[zero]
      zero_buffer <- c(
        zero_break - 0.02 * (xlim[2] - xlim[1]),
        zero_break + 0.02 * (xlim[2] - xlim[1])
      )
      x_mjr_ind <- c(
        zero,
        which(x_mjr$at < zero_buffer[1] |
          x_mjr$at > zero_buffer[2])
      )
    } else {
      x_mjr_ind <- seq_len(length(x_mjr$label))
    }

    axis(1,
      at = x_mjr$at[x_mjr_ind],
      labels = x_mjr$label[x_mjr_ind],
      font.axis = axes_text_font,
      col.axis = axes_text_col,
      cex.axis = axes_text_size,
      tck = -0.03
    )
    # X AXIS - UNTRANSFORMED
  } else if (.all_na(axes_text[[1]])) {
    axis(1,
      font.axis = axes_text_font,
      col.axis = axes_text_col,
      cex.axis = axes_text_size,
      tck = -0.03
    )
  }

  # Y AXIS - TRANSFORMED
  if (is(axes_text[[2]], "list")) {
    # MINOR TICKS
    y_mnr_ind <- which(as.character(axes_text[[2]]$label) == "")
    axis(2,
      at = axes_text[[2]]$at[y_mnr_ind],
      labels = axes_text[[2]]$label[y_mnr_ind],
      tck = -0.015
    )
    # MAJOR TICKS - MUST BE >2% yrange FROM ZERO
    y_mjr_ind <- which(as.character(axes_text[[2]]$label) != "")
    y_mjr <- list(
      "at" = axes_text[[2]]$at[y_mjr_ind],
      "label" = axes_text[[2]]$label[y_mjr_ind]
    )
    # Zero included on plot
    if (any(as.character(y_mjr$label) == "0")) {
      zero <- which(as.character(y_mjr$label) == "0")
      zero_break <- y_mjr$at[zero]
      zero_buffer <- c(
        zero_break - 0.02 * (ylim[2] - ylim[1]),
        zero_break + 0.02 * (ylim[2] - ylim[1])
      )
      y_mjr_ind <- c(
        zero,
        which(y_mjr$at < zero_buffer[1] |
          y_mjr$at > zero_buffer[2])
      )
    } else {
      y_mjr_ind <- seq_len(length(y_mjr$label))
    }
    axis(2,
      at = y_mjr$at[y_mjr_ind],
      labels = y_mjr$label[y_mjr_ind],
      font.axis = axes_text_font,
      col.axis = axes_text_col,
      cex.axis = axes_text_size,
      tck = -0.03
    )
    # Y AXIS - LINEAR
  } else if (.all_na(axes_text[[2]])) {
    axis(2,
      font.axis = axes_text_font,
      col.axis = axes_text_col,
      cex.axis = axes_text_size,
      tck = -0.03
    )
  }

  # BORDER_FILL
  if (border_fill != "white") {
    rect(par("usr")[1], par("usr")[3], par("usr")[2], par("usr")[4],
      col = adjustcolor(border_fill, border_fill_alpha),
      border = NA
    )
  }

  # GRID LINES
  if (grid != FALSE) {
    # AXES BREAKS GRID LINES
    if (grid == TRUE) {
      if (length(channels) == 2) {
        axes_grid <- lapply(axes_text, `[[`, "at")
      } else {
        axes_grid <- list(axes_text[[1]]$at)
      }
      # QUANTILE GRID LINES - BASE LAYER ONLY
    } else {
      if (!is.numeric(grid)) {
        grid <- 10
      }
      axes_grid <- lapply(channels, function(z) {
        cyto_apply(x[[1]],
          "cyto_stat_quantile",
          channels = z,
          input = "matrix",
          copy = FALSE,
          inverse = FALSE,
          probs = seq(0, 1, ifelse(grid > 1, 1 / grid, grid))
        )[, 1]
      })
      names(axes_grid) <- channels
    }
    # X AXIS GRID LINES
    lapply(seq_along(axes_grid), function(z) {
      # VERTICAL LINES
      if (z == 1) {
        abline(
          v = axes_grid[[z]],
          lty = grid_line_type,
          lwd = grid_line_width,
          col = adjustcolor(grid_line_col, grid_line_alpha)
        )
        # HORIZONTAL LINES
      } else {
        abline(
          h = axes_grid[[z]],
          lty = grid_line_type,
          lwd = grid_line_width,
          col = adjustcolor(grid_line_col, grid_line_alpha)
        )
      }
    })
  }

  # BORDER
  box(
    which = "plot",
    lty = border_line_type,
    lwd = border_line_width,
    col = border_line_col
  )

  # TITLE
  if (!.all_na(title)) {
    title(
      main = title,
      cex.main = title_text_size,
      col.main = title_text_col,
      font.main = title_text_font
    )
  }

  # XLAB - position labels closer if axes text is missing
  if (!.all_na(xlab)) {
    if (is(axes_text[[1]], "list")) {
      title(
        xlab = xlab,
        font.lab = axes_label_text_font,
        col.lab = axes_label_text_col,
        cex.lab = axes_label_text_size
      )
    } else if (.all_na(axes_text[[1]])) {
      title(
        xlab = xlab,
        font.lab = axes_label_text_font,
        col.lab = axes_label_text_col,
        cex.lab = axes_label_text_size
      )
    } else if (axes_text[[1]] == FALSE) {
      title(
        xlab = xlab,
        font.lab = axes_label_text_font,
        col.lab = axes_label_text_col,
        cex.lab = axes_label_text_size,
        mgp = c(2, 0, 0)
      )
    }
  }

  # YLAB - position labels closer if axes text is missing
  if (!.all_na(ylab)) {
    if (is(axes_text[[2]], "list")) {
      title(
        ylab = ylab,
        font.lab = axes_label_text_font,
        col.lab = axes_label_text_col,
        cex.lab = axes_label_text_size
      )
    } else if (.all_na(axes_text[[2]])) {
      title(
        ylab = ylab,
        font.lab = axes_label_text_font,
        col.lab = axes_label_text_col,
        cex.lab = axes_label_text_size
      )
    } else if (axes_text[[2]] == FALSE) {
      title(
        ylab = ylab,
        font.lab = axes_label_text_font,
        col.lab = axes_label_text_col,
        cex.lab = axes_label_text_size,
        mgp = c(2, 0, 0)
      )
    }
  }

  # LEGEND ---------------------------------------------------------------------
  
  # POINT_COL_SCALE
  if (length(channels) == 2 &
    (is.na(point_col)[1] |
      any(point_col %in% c(cyto_channels(x), cyto_markers(x))))) {
    # LEGEND
    point_col_scale <- .cyto_plot_point_col_scale(point_col_scale)
    legend_col_ramp <- colorRamp(point_col_scale)
    legend_cols <- seq(0, 1, 1 / 50) # 50 boxes
    legend_cols <- legend_col_ramp(legend_cols)
    legend_cols <- rgb(legend_cols[, 1],
      legend_cols[, 2],
      legend_cols[, 3],
      maxColorValue = 255
    )
    legend_cols <- adjustcolor(legend_cols, point_col_alpha[1])

    # LEGEND LOCATION
    legend_x <- c(
      par("usr")[2] + 0.005 * (par("usr")[2] - par("usr")[1]),
      par("usr")[2] + 0.035 * (par("usr")[2] - par("usr")[1])
    )
    legend_y <- c(par("usr")[3], par("usr")[4])

    # LEGEND BORDER
    rect(legend_x[1],
      legend_y[1],
      legend_x[2],
      legend_y[2],
      xpd = TRUE,
      lwd = 1
    )

    # LEGEND BOXES
    legend_box_x <- legend_x
    legend_box_y <- seq(
      par("usr")[3],
      par("usr")[4],
      (par("usr")[4] - par("usr")[3]) / 50
    )
    lapply(seq_len(50), function(z) {
      rect(legend_box_x[1],
        legend_box_y[z],
        legend_box_x[2],
        legend_box_y[z + 1],
        xpd = TRUE,
        col = legend_cols[z],
        border = NA
      )
    })
  }

  # LEGEND - FALSE/"fill"/"line"
  if (legend != FALSE) {
    .cyto_plot_legend(x,
      channels = channels,
      legend = legend,
      legend_text = legend_text,
      legend_text_font = legend_text_font,
      legend_text_size = legend_text_size,
      legend_text_col = legend_text_col,
      legend_line_type = legend_line_type,
      legend_line_width = legend_line_width,
      legend_line_col = legend_line_col,
      legend_box_fill = legend_box_fill,
      legend_point_col = legend_point_col,
      hist_cols = hist_cols,
      hist_fill = hist_fill,
      hist_fill_alpha = hist_fill_alpha,
      hist_line_type = hist_line_type,
      hist_line_width = hist_line_width,
      hist_line_col = hist_line_col,
      point_shape = point_shape,
      point_size = point_size,
      point_col_scale = point_col_scale,
      point_cols = point_cols,
      point_col = point_col,
      point_col_alpha = point_col_alpha
    )
  }
}

## CYTO_PLOT_NEW ---------------------------------------------------------------

#' Open new graphics device for cyto_plot
#'
#' \code{cyto_plot_new} is used internally by cyto_plot to open an OS-specific
#' interactive garphics device to facilitate gate drawing. Mac users will need
#' to install \href{https://www.xquartz.org/}{XQuartz} for this functionality.
#'
#' @param popup logical indicating whether a popup graphics device should be
#'   opened.
#' @param layout passed to \code{\link{cyto_plot_layout}} to set the layout of
#'   the new graphics device as it is opened, set to NULL by default to simply
#'   open the device without setting the layout.
#' @param outer_margins vector of length 4 indicating the number of lines of
#'   text to place around the \code{c(bottom, left, top, right)} outer borders
#'   of the plot, set to NULL by default to use \code{par("oma")}.
#' @param ... additional arguments passed to
#'   \code{\link[grDevices:dev]{dev.new}}:
#'
#' @importFrom grDevices dev.cur dev.new dev.list dev.set graphics.off
#'
#' @examples
#' \dontrun{
#' # Open platform-specific graphics device
#' cyto_plot_new()
#' }
#'
#' @author Dillon Hammill, \email{Dillon.Hammill@anu.edu.au}
#'
#' @export
cyto_plot_new <- function(popup = TRUE,
                          layout = NULL,
                          outer_margins = NULL,
                          ...) {
  # NULL -> RSTUDIOGD
  if (dev.cur() == 1) {
    dev.new(...)
  }
  
  # NO CYTO_PLOT_SAVE  
  if(!getOption("cyto_plot_save")) {
    # CURRENT DEVICE - RSTUDIO
    if(any(grepl("rstudio", names(dev.cur()), ignore.case = TRUE))) {
      # REQUIRE - POPUP
      if(popup == TRUE) {
        # NEW POPUP DEVICE REQUIRED
        new_device <- "popup"
        # REQUIRE - RSTUDIO  
      } else {
        # PRESET LAYOUT
        if(ifelse(is.null(layout), FALSE, all(layout == FALSE))) {
          new_device <- FALSE
          # NEW LAYOUT  
        } else {
          new_device <- "rstudio"
        }
      }
      # CURRENT DEVICE - POPUP
    } else {
      # REQUIRE POPUP
      if(popup == TRUE) {
        # PRESET LAYOUT
        if(ifelse(is.null(layout), FALSE, all(layout == FALSE))) {
          new_device <- FALSE
          # NEW LAYOUT  
        } else {
          new_device <- "popup"
        }
        # REQUIRE - RSTUDIO
      } else {
        # NEW RSTUDIO DEVICE REQUIRED
        new_device <- "rstudio"
      }
    }
    
    # OPEN NEW GRAPHICS DEVICE
    if(new_device != FALSE) {
      # POPUP DEVICE
      if(new_device == "popup") {
        if(interactive() & getOption("CytoExploreR_interactive")) {
          if (.Platform$OS.type == "windows") {
            suppressWarnings(dev.new(...))
          } else if (.Platform$OS.type == "unix") {
            if (Sys.info()["sysname"] == "Linux") {
              # Cairo needed for semi-transparency
              suppressWarnings(dev.new(type = "cairo", ...))
            } else if (Sys.info()["sysname"] == "Darwin") {
              suppressWarnings(dev.new(...))
            }
          }
        }
        # RSTUDIO DEVICE  
      } else if(new_device == "rstudio") {
        dev.ind <- which(grepl("rstudio", 
                               names(dev.list()), 
                               ignore.case = TRUE))
        if(length(dev.ind) != 0) {
          dev.set(dev.list()[dev.ind])
        } else {
          graphics.off()
          dev.new(..., noRStudioGD = FALSE)
        }
      }
    }
  }

  # OUTER MARGINS
  cyto_plot_outer_margins(outer_margins)
  
  # LAYOUT
  cyto_plot_layout(layout)
  
}

## CYTO_PLOT_RESET -------------------------------------------------------------

#' Reset all cyto_plot related settings
#'
#' @author Dillon Hammill (Dillon.Hammill@anu.edu.au)
#'
#' @importFrom grDevices dev.off dev.cur
#' @export
cyto_plot_reset <- function() {

  # Create custom theme for cyto_plot
  options("cyto_plot_theme" = NULL)

  # Signal cyto_plot_save method has been called
  options("cyto_plot_save" = FALSE)

  # Signal which cyto_plot method has been called
  options("cyto_plot_method" = NULL)

  # Signal if a custom plot is being constructed - require cyto_plot_complete
  options("cyto_plot_custom" = FALSE)

  # Signal when cyto_plot_grid method is being called
  options("cyto_plot_grid" = FALSE)

  # Signal set layout
  options("cyto_plot_layout" = NULL)
  
  # Signal set outer margins
  options("cyto_plot_outer_margins"= NULL)
  
  # Reset memory
  .cyto_plot_args_remove()

  # Turn off graphics device
  if (dev.cur() != 1) {
    dev.off()
  }

  invisible(NULL)
}

## CYTO_PLOT_RECORD ------------------------------------------------------------

#' Record an existing cyto_plot
#'
#' \code{cyto_plot_record} will record an existing plot such that it can be
#' saved to an R object for future reference.
#'
#' @importFrom grDevices recordPlot
#'
#' @author Dillon Hammill (Dillon.Hammill@anu.edu.au)
#'
#' @examples
#' \dontrun{
#'
#' # Load CytoExploreRData to acces data
#' library(CytoExploreRData)
#'
#' # Activation flowSet
#' fs <- Activation
#'
#' # Construct cyto_plot
#' cyto_plot(fs[[1]],
#'   channels = c("FSC-A", "SSC-A")
#' )
#'
#' # Record plot and save to object called p
#' p <- cyto_plot_record()
#'
#' # Calling p will bring back the recorded plot
#' p
#' }
#'
#' @export
cyto_plot_record <- function() {
  recordPlot()
}

## CYTO_PLOT_SAVE --------------------------------------------------------------

#' Save High Resolution cyto_plot Images
#'
#' @param save_as name of the file to which the plot should be saved (including
#'   the file extension). Supported file formats include png, tiff, jpeg, svg
#'   and pdf.
#' @param width numeric indicating the width of exported plot in \code{units},
#'   set to 7 by default for image with width of 7 inches.
#' @param height numeric indicating the height of the exported plot in
#'   \code{units}, set to 7 by default for image with height of 7 inches.
#' @param units units to be used to set plot size, can be either pixels
#'   (\code{px}), inches (\code{inches}), centimetres (\code{cm}) or millimetres
#'   (\code{mm}). Set to \code{"in"} by default. Units cannot be altered for
#'   \code{svg} and \code{pdf} graphics devices.
#' @param res resolution in ppi, set to 300 by default.
#' @param multiple logical indicating whether multiple pages should be saved to
#'   separate numbered files, set to \code{FALSE} by default.
#' @param layout a vector or matrix defining the custom layout of the plot to be
#'   created using `cyto_plot_layout`, set to NULL by default to use standard
#'   `cyto_plot` layout. Custom layouts are required when making multiple
#'   `cyto_plot` calls in the same image.
#' @param outer_margins vector of length 4 indicating the number of lines of
#'   text to place around the \code{c(bottom, left, top, right)} outer borders
#'   of the plot, set to NULL by default to use \code{par("oma")}.
#' @param ... additional arguments for the appropriate \code{png()},
#'   \code{tiff()}, \code{jpeg()}, \code{svg()} or \code{pdf} graphics devices.
#'
#' @importFrom grDevices png tiff jpeg pdf svg
#'
#' @author Dillon Hammill (Dillon.Hammill@anu.edu.au)
#'
#' @examples
#' \dontrun{
#' library(CytoExploreRData)
#'
#' # Load samples into GatingSet
#' fs <- Activation
#' gs <- GatingSet(fs)
#'
#' # Apply compensation
#' gs <- cyto_compensate(gs)
#'
#' # Transform fluorescent channels
#' gs <- cyto_transform(gs)
#'
#' # Apply gatingTemplate
#' cyto_gatingTemplate_apply(gs, Activation_gatingTemplate)
#'
#' # Save png image of gating scheme after plotting
#' cyto_plot_save("Gating-Scheme.png",
#'   width = 20,
#'   height = 16
#' )
#' cyto_plot_gating_scheme(gs[[1]])
#'
#' # Save multiple pages to the same pdf file
#' cyto_plot_save("CD4-T-Cells.pdf",
#'   height = 8,
#'   width = 16,
#'   multiple = TRUE
#' )
#' cyto_plot(gs,
#'   parent = "CD4 T Cells",
#'   alias = "",
#'   channels = c("Alexa Fluor 647-A", "7-AAD-A"),
#'   layout = c(1, 2)
#' )
#' }
#' @seealso \code{\link[grDevices:cairo]{cairo}}
#' @seealso \code{\link[grDevices:png]{png}}
#'
#' @export
cyto_plot_save <- function(save_as,
                           width = 7,
                           height = 7,
                           units = "in",
                           res = 300,
                           multiple = FALSE,
                           layout = NULL,
                           outer_margins = NULL,
                           ...) {

  # APPEND FILE EXTENSION
  save_as <- file_ext_append(save_as, ".png")

  # Save separate pages to separate number files
  if (multiple == TRUE & file_ext(save_as) != "pdf") {
    save_as <- paste0(
      file_ext_remove(save_as),
      "_", "%03d", ".",
      file_ext(save_as)
    )
  }

  # PNG DEVICE
  if (file_ext(save_as) == "png") {
    png(
      filename = save_as,
      width = width,
      height = height,
      units = units,
      res = res,
      ...
    )
    # TIFF DEVICE
  } else if (file_ext(save_as) == "tiff") {
    tiff(
      filename = save_as,
      width = width,
      height = height,
      units = units,
      res = res,
      ...
    )
    # JPEG DEVICE
  } else if (file_ext(save_as) == "jpeg") {
    jpeg(
      filename = save_as,
      width = width,
      height = height,
      units = units,
      res = res,
      ...
    )
    # PDF DEVICE
  } else if (file_ext(save_as) == "pdf") {
    pdf(
      file = save_as,
      width = width,
      height = height,
      onefile = multiple,
      ...
    )
  } else if (file_ext(save_as) == "svg") {
    svg(
      filename = save_as,
      width = width,
      height = height,
      ...
    )
  } else {
    stop(paste("Can't save file to", file_ext(save_as), "format."))
  }

  # Set global option to notify cyto_plot when dev.off() is required for saving
  options("cyto_plot_save" = TRUE)

  # CYTO_PLOT_CUSTOM
  if (!is.null(layout)) {
    cyto_plot_custom(layout = layout,
                     outer_margins = outer_margins)
  }
}

## CYTO_PLOT_SAVE_RESET --------------------------------------------------------

#' Revert unwanted cyto_plot_save call
#'
#' @importFrom grDevices dev.off
#'
#' @examples
#'
#' # Unwanted cyto_plot_save call
#' cyto_plot_save("Mistake.png")
#'
#' # Revert unwanted cyto_plot_save call
#' cyto_plot_save_reset()
#' @author Dillon Hammill (Dillon.Hammill@anu.edu.au)
#'
#' @export
cyto_plot_save_reset <- function() {
  # TURN OFF GLOBAL OPTION
  options("cyto_plot_save" = FALSE)
  # TURN OFF GRAPHICS DEVICE
  dev.off()
}

## CYTO_PLOT_LAYOUT ------------------------------------------------------------

#' Set Panel Layout for cyto_plot
#'
#' \code{cyto_plot_layout()} sets the panel layout dimensions for combining
#' different types of cyto_plot plots. Make a call to \code{cyto_plot_layout()}
#' prior to making multiple calls to \code{cyto_plot()}.
#'
#' @param layout either a vector of the form c(nrow, ncol) defining the
#'   dimensions of the plot or a matrix defining a more sophisticated layout
#'   (see \code{\link[graphics]{layout}}). Vectors can optionally contain a
#'   third element to indicate whether plots should be placed in row (1) or
#'   column (2) order, set to row order by default. Resorts to
#'   \code{options("cyto_plot_layout")} if not manually specified.
#'
#' @importFrom graphics par layout
#'
#' @author Dillon Hammill (Dillon.Hammill@anu.edu.au)
#'
#' @examples
#' library(CytoExploreRData)
#'
#' # Load samples into GatingSet
#' fs <- Activation
#' gs <- GatingSet(fs)
#'
#' # Apply compensation
#' gs <- compensate(gs, fs[[1]]@description$SPILL)
#'
#' # Transform fluorescent channels
#' trans <- estimateLogicle(gs[[4]], cyto_fluor_channels(gs))
#' gs <- transform(gs, trans)
#'
#' # Apply gatingTemplate
#' gt <- Activation_gatingTemplate
#' gt_gating(gt, gs)
#'
#' # Set out plot layout
#' cyto_plot_layout(c(1, 2))
#'
#' # Add 2D plot
#' cyto_plot(gs[[4]],
#'   parent = "CD4 T Cells",
#'   alias = "",
#'   channels = c("Alexa Fluor 647-A", "7-AAD-A"),
#'   layout = FALSE
#' )
#'
#' # Add 1D plot
#' cyto_plot(gs,
#'   parent = "CD4 T Cells",
#'   alias = "",
#'   channels = "7-AAD-A",
#'   hist_stack = 0.6,
#'   layout = FALSE
#' )
#' @export
cyto_plot_layout <- function(layout = NULL) {

  # MESSAGE
  if (is.null(layout) | .empty(layout) | all(layout == FALSE)) {
    if(!is.null(getOption("cyto_plot_layout"))) {
      layout  <- getOption("cyto_plot_layout")
    } else {
      return(NULL) # layout as current device
    }
  }
  
  # MATRIX
  if (is.matrix(layout)) {
    layout(layout)
    # VECTOR
  } else {
    # BYPASS LAYOUT
    if (!all(layout == FALSE)) {
      # ROW ORDER
      if (length(layout) == 2) {
        layout <- c(layout, 1)
      }
      # ROWS
      if (layout[3] == 1) {
        par(mfrow = c(layout[1], layout[2]))
        # COLUMNS
      } else if (layout[3] == 2) {
        par(mfcol = c(layout[1], layout[2]))
      }
    }
  }
  
  # SAVE LAYOUT PLOT/CUSTOM
  options("cyto_plot_layout" = layout)
  
}

## CYTO_PLOT_OUTER_MARGINS -----------------------------------------------------

#' Set outer margins for cyto_plot layout
#' 
#' @param outer_margins vector of length 4 indicating the number of lines of
#'   text to place around the \code{c(bottom, left, top, right)} outer borders
#'   of the plot, set to NULL by default to use \code{par("oma")}.
#' 
#' @importFrom graphics par
#' 
#' @author Dillon Hammill (Dillon.Hammill@anu.edu.au)
#' 
#' @export
cyto_plot_outer_margins <- function(outer_margins = NULL) {
  
  # GET OUTER MARGINS
  if(is.null(outer_margins)) {
    outer_margins <- getOption("cyto_plot_margins")
  }
  
  # SET OUTER MARGINS
  if(!is.null(outer_margins)) {
    par("oma" = outer_margins)
    options("cyto_plot_margins" = outer_margins)
  }
  
}

## CYTO_PLOT_CUSTOM ------------------------------------------------------------

#' Create custom cyto_plot
#'
#' Signal to \code{cyto_plot} that a custom plot is being created to ensure that
#' plots are appropriately saved with \code{cyto_plot_save}.
#' \code{cyto_plot_custom} calls must be made before \code{cyto_plo_save} calls
#' and \code{cyto_plot} calls should be followed by a call to
#' \code{cyto_plot_complete} to indicate when the plot is complete and should be
#' saved.
#'
#' @param layout either a vector of the form c(nrow, ncol) defining the
#'   dimensions of the plot or a matrix defining a more sophisticated layout
#'   (see \code{\link[graphics]{layout}}). Vectors can optionally contain a
#'   third element to indicate whether plots should be placed in row (1) or
#'   column (2) order, set to row order by default.
#' @param outer_margins vector of length 4 indicating the number of lines of
#'   text to place around the \code{c(bottom, left, top, right)} outer borders
#'   of the plot, set to NULL by default to use \code{par("oma")}.
#'
#' @author Dillon Hammill (Dillon.Hammill@anu.edu.au)
#'
#' @examples
#' \dontrun{
#' library(CytoExploreRData)
#'
#' # Activation flowSet
#' fs <- Activation
#'
#' # Save plot
#' cyto_plot_save("Test.png",
#'   height = 7,
#'   width = 14
#' )
#'
#' # Create custom plot - 1D & 2D plot panels
#' cyto_plot_custom(layout = c(1, 2))
#' cyto_plot(fs[[32]],
#'   channels = "FSC-A"
#' )
#' cyto_plot(fs[[32]],
#'   channels = c("FSC-A", "SSC-A")
#' )
#'
#' # Signal plot is complete and save
#' cyto_plot_complete()
#' }
#' @export
cyto_plot_custom <- function(layout = NULL,
                             outer_margins = NULL) {

  # Tell CytoExploreR - cyto_plot_save and layout resets
  options("cyto_plot_custom" = TRUE)

  # Set plot method
  options("cyto_plot_method" = "custom")

  # Set layout
  cyto_plot_layout(layout)
  
  # Set outer margins
  cyto_plot_outer_margins(outer_margins)
  
  # Reset memory
  if(!getOption("cyto_plot_save")) {
    .cyto_plot_args_remove()
  }
  
}

## CYTO_PLOT_COMPLETE ----------------------------------------------------------

#' Indicate Completion of Custom cyto_plot Layout for Saving
#'
#' @param layout either a vector of the form c(nrow, ncol) defining the
#'   dimensions of the plot or a matrix defining a more sophisticated layout
#'   (see \code{\link[graphics]{layout}}). Vectors can optionally contain a
#'   third element to indicate whether plots should be placed in row (1) or
#'   column (2) order, set to row order by default.
#' @param outer_margins vector of length 4 indicating the number of lines of
#'   text to place around the \code{c(bottom, left, top, right)} outer borders
#'   of the plot, set to NULL by default to use \code{par("oma")}.
#'
#' @importFrom graphics par
#'
#' @author Dillon Hammill (Dillon.Hammill@anu.edu.au)
#'
#' @examples
#' library(CytoExploreRData)
#'
#' # Load samples into GatingSet
#' fs <- Activation
#' gs <- GatingSet(fs)
#'
#' # Apply compensation
#' gs <- compensate(gs, fs[[1]]@description$SPILL)
#'
#' # Transform fluorescent channels
#' trans <- estimateLogicle(gs[[4]], cyto_fluor_channels(gs))
#' gs <- transform(gs, trans)
#'
#' # Apply gatingTemplate
#' gt <- Activation_gatingTemplate
#' gt_gating(gt, gs)
#'
#' # Save custom plot
#' cyto_plot_save("Custom.png",
#'   height = 8,
#'   width = 16
#' )
#'
#' # Set out plot layout
#' cyto_plot_layout(c(1, 2))
#'
#' # Add 2D plot
#' cyto_plot(gs[[4]],
#'   parent = "CD4 T Cells",
#'   alias = "",
#'   channels = c("Alexa Fluor 647-A", "7-AAD-A"),
#'   layout = FALSE
#' )
#'
#' # Add 1D plot
#' cyto_plot(gs,
#'   parent = "CD4 T Cells",
#'   alias = "",
#'   channels = "7-AAD-A",
#'   hist_stack = 0.6,
#'   layout = FALSE
#' )
#'
#' # Signal that the plot is complete
#' cyto_plot_complete()
#' @export
cyto_plot_complete <- function(layout = NULL,
                               outer_margins = NULL) {

  # Close graphics device (not RStudioGD or X11)
  if (!names(dev.cur()) %in% c(
    "RStudioGD",
    "windows",
    "X11",
    "x11",
    "quartz"
  )) {
    dev.off()
  }

  # Reset cyto_plot_custom
  options("cyto_plot_custom" = FALSE)

  # Reset plot method
  options("cyto_plot_method" = NULL)

  # Turn off saving
  options("cyto_plot_save" = FALSE)

  # Reset layout - 1 x 1
  if(is.null(layout)) {
    layout <- c(1, 1, 1)
  }
  cyto_plot_layout(layout)
  options("cyto_plot_layout" = NULL)
  
  # Reset cyto_plot_outer_margins
  if(is.null(outer_margins)) {
    outer_margins <- c(0,0,0,0)
  }
  cyto_plot_outer_margins(outer_margins)
  options("cyto_plot_outer_margins" = NULL)

}

## CYTO_PLOT_THEME -------------------------------------------------------------

#' Create custom themes for cyto_plot
#'
#' \code{cyto_plot_theme} provides an easy way to alter the theme used by
#' \code{cyto_plot}. By calling \code{cyto_plot_theme} prior to plotting,
#' subsequent plots will inherit these arguments so there is no need to supply
#' them manually each time. For a complete list of supported arguments see
#' \code{cyto_plot_theme_args}.
#'
#' @param ... arguments supported by cyto_plot_theme.
#'
#' @examples
#' # Make all plots have a black background
#' cyto_plot_theme(border_fill = "black")
#'
#' # Black ground with custom colour scale for points and purple gates
#' cyto_plot_theme(
#'   border_fill = "black",
#'   point_col_scale = c(
#'     "cyan",
#'     "green",
#'     "yellow",
#'     "orange",
#'     "red",
#'     "darkred"
#'   ),
#'   gate_line_col = "magenta"
#' )
#'
#' # Reset to default setting
#' cyto_plot_theme_reset()
#' @author Dillon Hammill (Dillon.Hammill@anu.edu.au)
#'
#' @export
cyto_plot_theme <- function(...) {

  # cyto_plot will pull down these arguments

  # Arguments as named list
  args <- list(...)

  # Empty list set theme to NULL
  if (length(args) == 0) {
    args <- NULL
  } else {
    # Check supplied arguments are supported.
    if (!all(names(args) %in% cyto_plot_theme_args())) {
      lapply(names(args), function(x) {
        if (!x %in% cyto_plot_theme_args()) {
          message(paste(x, "is not a supported argument for cyto_plot_theme."))
        }
      })
    }

    # Restrict list to supported arguments only
    args <- args[names(args) %in% cyto_plot_theme_args()]
  }

  # Assign arguments to cyto_plot_theme option
  options("cyto_plot_theme" = args)
}

## CYTO_PLOT_THEME_RESET -------------------------------------------------------

#' Reset cyto_plot_theme to default settings
#'
#' @author Dillon Hammill (Dillon.Hammill@anu.edu.au)
#'
#' @export
cyto_plot_theme_reset <- function() {

  # Set cyto_plot_theme option to NULL
  options("cyto_plot_theme" = NULL)
}

## .CYTO_PLOT_THEME_ARGS -------------------------------------------------------

#' Get supported cyto_plot_theme arguments
#'
#' @return vector of argument names supported by cyto_plot_theme.
#'
#' @examples
#' cyto_plot_theme_args()
#' @author Dillon Hammill (Dillon.Hammill@anu.edu.au)
#'
#' @export
cyto_plot_theme_args <- function() {
  c(
    "axes_limits",
    "axes_limits_buffer",
    "margins",
    "popup",
    "hist_stat",
    "hist_bins",
    "hist_smooth",
    "hist_stack",
    "hist_cols",
    "hist_fill_alpha",
    "hist_line_type",
    "hist_line_width",
    "hist_line_col",
    "axes_text",
    "axes_text_font",
    "axes_text_size",
    "axes_text_col",
    "axes_label_text_font",
    "axes_label_text_size",
    "axes_label_text_col",
    "title_text_font",
    "title_text_size",
    "title_text_col",
    "legend",
    "legend_text_font",
    "legend_text_size",
    "legend_text_col",
    "legend_line_col",
    "legend_box_fill",
    "gate_line_type",
    "gate_line_width",
    "gate_line_col",
    "gate_fill",
    "gate_fill_alpha",
    "label",
    "label_position",
    "label_text_font",
    "label_text_size",
    "label_text_col",
    "label_fill",
    "label_fill_alpha",
    "border_fill",
    "border_fill_alpha",
    "border_line_type",
    "border_line_width",
    "border_line_col",
    "point_shape",
    "point_size",
    "point_col_scale",
    "point_cols",
    "point_col_alpha",
    "point_fast",
    "contour_lines",
    "contour_line_type",
    "contour_line_width",
    "contour_line_col",
    "contour_line_alpha",
    "grid",
    "grid_line_type",
    "grid_line_width",
    "grid_line_col",
    "grid_line_alpha"
  )
}
