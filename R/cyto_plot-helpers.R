## CYTO_PLOT_EMPTY -------------------------------------------------------------

#' Create an empty cyto_plot
#'
#' \code{cyto_plot_empty} generates to base for cyto_plot by creating an empty
#' plot with border, axes, axes_text and titles. Data is subsequently added to
#' this base layer with \code{cyto_plot_point} or \code{cyto_plot_hist}.
#'
#' @param x object of class \code{\link[flowCore:flowFrame-class]{flowFrame}}.
#' @param channels name of the channel(s) or marker(s) to be used to construct
#'   the plot. The length of channels determines the type of plot to be
#'   constructed, either a 1-D density distribution for a single channel or a
#'   2-D scatterplot with blue-red colour scale for two channels.
#' @param axes_trans object of class
#'   \code{\link[flowCore:transformList-class]{transformList}} or
#'   \code{\link[flowWorkspace]{transformerList}} generated by
#'   \code{\link[flowCore:logicleTransform]{estimateLogicle}} which was used to
#'   transform the fluorescent channels of the supplied flowFrame. This
#'   transformation object will be used internally to ensure that the axes
#'   labels of the plot are appropriately transformed. The transformation object
#'   will NOT be applied to the flowFrame internally and should be applied to
#'   the flowFrame prior to plotting.
#' @param overlay a list of flowFrames to overlay onto the plot.
#' @param gate list of gate objects to be plotted, used internlaly to ensure
#'   gate co-ordinates are taken into account when computing axes limits.
#' @param xlim lower and upper limits of x axis (e.g. c(0,5)).
#' @param ylim lower and upper limits of y axis (e.g. c(0,5)).
#' @param axes_limits options include \code{"auto"}, \code{"data"} or
#'   \code{"machine"} to use optimised, data or machine limits respectively. Set
#'   to \code{"auto"} by default to use optimised axes ranges. Fine control over
#'   axes limits can be obtained by altering the \code{xlim} and \code{ylim}
#'   arguments.
#' @param axes_limits_buffer decimal indicating the percentage of buffering to
#'   add to either end of the axes limits, set to 0.03 by default.
#' @param title title to use for the plot, set to the name of the sample by
#'   default. Title can be removed by setting this argument to \code{NA}.
#' @param xlab x axis label.
#' @param ylab y axis label.
#' @param margins a vector of length 4 to control the margins around the bottom,
#'   left, top and right of the plot, set to c(NA, NA, NA, NA) by default to let
#'   `cyto_plot` compute optimal margins.
#' @param hist_stat can be either \code{"count"}, \code{"percent"} or
#'   \code{"density"} to indicate the statistic to display on histograms, set to
#'   \code{"percent"} by default. The \code{"percent"} option applies modal
#'   normalisation and expresses the result as a percentage.
#' @param hist_smooth smoothing parameter passed to
#'   \code{\link[stats:density]{density}} to adjust the smoothness of the kernel
#'   density for histograms, set to \code{1} by default.
#' @param hist_bins number of bins to use for histograms, set to 256 by default.  
#' @param hist_stack numeric [0,1] indicating the degree of stacking for
#'   histograms, set to \code{0} by default.
#' @param hist_layers numeric indicating the number of histograms to stack in
#'   each plot, set to all samples by default. Each plot must contain the same
#'   number of histograms.
#' @param hist_cols vector colours to draw from when selecting histogram fill
#'   colours if none are supplied to \code{hist_fill}.
#' @param hist_fill fill colour(s) for histograms, select from \code{hist_cols}
#'   if not supplied.
#' @param hist_fill_alpha numeric [0,1] used to control histogram fill colour
#'   transparency, set to \code{1} by default for solid colours.
#' @param hist_line_type line type(s) to use for histogram borders, set to 1 by
#'   default to use solid lines. See \code{\link[graphics:par]{lty}} for
#'   alternatives.
#' @param hist_line_width numeric to control line width(s) for histogram borders
#'   lines, set to 1 by default.
#' @param hist_line_col colour(s) for histogram borders, set to \code{"black"}
#'   by default.
#' @param point_shape shape(s) to use for points in 2-D scatterplots, set to
#'   \code{"."} by default to maximise plotting speed.  See
#'   \code{\link[graphics:par]{pch}} for alternatives.
#' @param point_size numeric to control the size of points in 2-D scatter plots
#'   set to 2 by default.
#' @param point_col_scale vector of colours to use for density gradient.
#' @param point_cols vector colours to draw from when selecting colours for
#'   points if none are supplied to point_col.
#' @param point_col colour(s) to use for points in 2-D scatter plots, set to NA
#'   by default to use a blue-red density colour scale.
#' @param point_col_alpha numeric [0,1] to control point colour transparency in
#'   2-D scatter plots, set to 1 by default to use solid colours.
#' @param axes_text logical vector of length 2 indicating whether axis text
#'   should be included for the x and y axes respectively, set to
#'   \code{c(TRUE,TRUE)} by default to display axes text on both axes.
#' @param axes_text_font numeric indicating the font to use for axes, set to 1
#'   for plain font by default. See \code{\link[graphics:par]{?par}} font for
#'   details.
#' @param axes_text_size character expansion for axis text.
#' @param axes_text_col colour of axis text.
#' @param axes_label_text_font numeric indicating the font to use for title, set
#'   to 1 for plain font by default. See \code{\link[graphics:par]{?par}} font
#'   for details.
#' @param axes_label_text_size character expansion for axis labels.
#' @param axes_label_text_col colour of axis labels.
#' @param title_text_font numeric indicating the font to use for title, set to 2
#'   for bold font by default. See \code{\link[graphics:par]{?par}} font for
#'   details.
#' @param title_text_size character expansion for plot title.
#' @param title_text_col colour for plot title.
#' @param border_line_type line type to use for plot border, set to 1 by default
#'   for a sold border.
#' @param border_line_width line width for plot border, set to 1 by default.
#' @param border_line_col line colour for plot border, set to "black" by
#'   default.
#' @param border_fill colour to use for the plot background, set to "white" by
#'   default.
#' @param border_fill_alpha transparency to use for border_fill colour, set to 1
#'   by default to add no transparency.
#' @param legend can be either \code{"line"} or \code{"fill"} to indicate
#'   whether a legend should be constructed based on the density \code{"line"}
#'   or \code{"fill"}, set to FALSE by default to remove the legend.
#' @param legend_text vector of labels to use in the legend.
#' @param legend_text_font numeric to control the font of legend text, set to 1
#'   for plain font by default. See \code{\link[graphics:par]{font}} for
#'   alternatives.
#' @param legend_text_size numeric to control the size of text in the legend,
#'   set to 1 by default.
#' @param legend_text_col colour(s) to use for text in legend, set to
#'   \code{"black"} by default.
#' @param legend_line_type numeric to control the line type for line legends,
#'   set to 1 by default. Refer to \code{lty} in \code{\link[graphics:par]{par}}
#'   for alternatives.
#' @param legend_line_width numeric to control the line width in line legend,
#'   set to 1 by default. Refer to \code{lwd} in \code{\link[graphics:par]{par}}
#'   for alternatives.
#' @param legend_line_col colour(s) to use for the lines in 1-D plot legends
#'   when legend is set to \code{"line"}.
#' @param legend_box_fill fill colour(s) to use for the boxes in 1-D plot
#'   legends when legend is set to \code{"fill"}.
#' @param legend_point_col colour(s) to use for points in 2-D scatter plot
#'   legend.
#' @param grid logical indicating whether to include grid lines in the plot
#'   background, set to TRUE by default. Alternatively, users can supply a
#'   integer to indicate the number of equally spaced quantiles to used for the
#'   grid lines.
#' @param grid_line_type integer [0,6] to control the line type of grid lines,
#'   set to \code{1} to draw solid lines by default. See
#'   \code{\link[graphics:par]{lty}} for alternatives.
#' @param grid_line_width numeric to control the line width(s) of grid lines,
#'   set to \code{1} by default.
#' @param grid_line_col colour to use for grid lines, set to \code{"grey95"} by
#'   default.
#' @param grid_line_alpha numeric [0,1] to control the transparency of grid
#'   lines, set to 1 by default to remove transparency.
#' @param ... not in use.
#'
#' @importFrom grDevices adjustcolor rgb colorRamp
#' @importFrom graphics plot box axis title par rect axTicks abline
#' @importFrom methods formalArgs is
#'
#' @author Dillon Hammill (Dillon.Hammill@anu.edu.au)
#'
#' @examples
#' library(CytoExploreRData)
#'
#' # Construct an empty 2D plot with black background
#' cyto_plot_empty(Activation[[32]],
#'   channels = c("FSC-A", "SSC-A"),
#'   border_fill = "black"
#' )
#'
#' # Construct an empty 1D plot
#' cyto_plot_empty(Activation[[32]],
#'   channels = c("FSC-A"),
#'   overlay = Activation[1:2]
#' )
#' @export
cyto_plot_empty <- function(x,
                            channels,
                            axes_trans = NA,
                            overlay = NA,
                            gate = NA,
                            xlim = c(NA, NA),
                            ylim = c(NA, NA),
                            axes_limits = "auto",
                            axes_limits_buffer = 0.03,
                            title,
                            xlab,
                            ylab,
                            margins = c(NA, NA, NA, NA),
                            hist_stat = "count",
                            hist_smooth = 1,
                            hist_bins = 256,
                            hist_stack = 0.5,
                            hist_cols = NA,
                            hist_fill = NA,
                            hist_fill_alpha = 1,
                            hist_line_type = 1,
                            hist_line_width = 1,
                            hist_line_col = "black",
                            point_shape = ".",
                            point_size = 2,
                            point_col_scale = NA,
                            point_cols = NA,
                            point_col = NA,
                            point_col_alpha = 1,
                            axes_text = c(TRUE, TRUE),
                            axes_text_font = 1,
                            axes_text_size = 1,
                            axes_text_col = "black",
                            axes_label_text_font = 1,
                            axes_label_text_size = 1.1,
                            axes_label_text_col = "black",
                            title_text_font = 2,
                            title_text_size = 1.1,
                            title_text_col = "black",
                            border_line_type = 1,
                            border_line_width = 1,
                            border_line_col = "black",
                            border_fill = "white",
                            border_fill_alpha = 1,
                            legend = FALSE,
                            legend_text,
                            legend_text_font = 1,
                            legend_text_size = 1,
                            legend_text_col = "black",
                            legend_line_type = NA,
                            legend_line_width = NA,
                            legend_line_col = NA,
                            legend_box_fill = NA,
                            legend_point_col = NA,
                            grid = TRUE,
                            grid_line_type = 1,
                            grid_line_width = 1,
                            grid_line_col = "grey95",
                            grid_line_alpha = 1,
                            ...) {
  
  # PREPARE X ------------------------------------------------------------------
  
  # X CAN BE EITHER FLOWFRAME/FLOWFRAME LIST/CYTO_PLOT ARGUMENTS
  
  # HISTOGRAMS - CYTO_PLOT ARGUMENTS
  d <- NULL
  
  # FLOWFRAME
  if (is(x, "flowFrame")) {
    overlay <- cyto_list(overlay)
    if (!.all_na(overlay)) {
      x <- c(
        structure(list(x), names = cyto_names(x)),
        overlay
      )
    }
    # CYTO_PLOT ARGUMENTS
  } else if (class(x) == "cyto_plot") {
    .args_update(x)
  }
  
  # GRAPHICAL PARAMETERS -------------------------------------------------------
  
  # Prevent scientific notation on axes - reset on exit
  scipen <- getOption("scipen")
  options(scipen = 100000000)
  on.exit(options(scipen = scipen))
  
  # Extract current graphics parameters
  pars <- par("mar")
  
  # Reset graphics parameters on exit
  on.exit(par(pars))
  
  # ARGUMENTS ------------------------------------------------------------------
  
  # Pull down arguments to named list
  args <- .args_list()
  
  # Inherit arguments from cyto_plot_theme
  args <- .cyto_plot_theme_inherit(args)
  
  # Update arguments
  .args_update(args)
  
  # CHANNELS -------------------------------------------------------------------
  
  # Check channels
  channels <- cyto_channels_extract(
    x[[1]],
    channels
  )
  
  # AXES LIMITS ----------------------------------------------------------------
  
  # XLIM
  if (any(is.na(xlim))) {
    # XLIM
    xlim[is.na(xlim)] <- .cyto_plot_axes_limits(x,
                                                channels = channels[1],
                                                axes_limits = axes_limits,
                                                buffer = axes_limits_buffer,
                                                plot = TRUE
    )[, 1][is.na(xlim)]
  }
  
  # YLIM
  if (any(is.na(ylim))) {
    # 1D PLOT
    if (length(channels) == 1) {
      if (is.null(d)) {
        d <- .cyto_plot_hist(x,
                             hist_stat = hist_stat,
                             hist_smooth = hist_smooth,
                             hist_bins = hist_bins,
                             hist_stack = hist_stack
        )
      }
      # YLIM
      ymin <- as.numeric(unlist(strsplit(names(d)[1], "-"))[1])
      ymax <- max(
        LAPPLY(names(d), function(z) {
          as.numeric(unlist(strsplit(z, "-"))[2])
        }),
        na.rm = TRUE
      )
      yrng <- c(ymin, ymax)
      ylim[is.na(ylim)] <- yrng[is.na(ylim)]
      # 2D PLOT
    } else if (length(channels) == 2) {
      # YLIM
      ylim[is.na(ylim)] <- .cyto_plot_axes_limits(x,
                                                  channels = channels[2],
                                                  axes_limits = axes_limits,
                                                  buffer = axes_limits_buffer,
                                                  plot = TRUE
      )[, 1][is.na(ylim)]
    }
  }
  
  # GATE COORDS MUST BE WITHIN AXES LIMITS
  if (!.all_na(gate)) {
    # GATE COORDS
    gate_coords <- .cyto_gate_coords(gate, channels)
  }
  
  # XLIM GATE COORD ADJUSTMENT
  if (!.all_na(gate)) {
    # MIN & MAX GATE COORDS
    gate_xcoords <- gate_coords[, channels[1]]
    gate_xcoords <- c(min(gate_xcoords), max(gate_xcoords))
    # GATE COORDS BELOW XMIN
    if (is.finite(gate_xcoords[1]) & gate_xcoords[1] < xlim[1]) {
      xlim[1] <- gate_xcoords[1]
    }
    # GATE COORDS ABOVE XMAX
    if (is.finite(gate_xcoords[2]) & gate_xcoords[2] > xlim[2]) {
      xlim[2] <- gate_xcoords[2]
    }
  }
  
  # YLIM GATE COORD ADJUSTMENT
  if (length(channels) == 2) {
    # GATE COORDS
    if (!.all_na(gate)) {
      # MIN & MAX GATE COORDS
      gate_ycoords <- gate_coords[, channels[2]]
      gate_ycoords <- c(min(gate_ycoords), max(gate_ycoords))
      # GATE COORDS BELOW YMIN
      if (is.finite(gate_ycoords[1]) & gate_ycoords[1] < ylim[1]) {
        ylim[1] <- gate_ycoords[1]
      }
      # GATE COORDS ABOVE YMAX
      if (is.finite(gate_ycoords[2]) & gate_ycoords[2] > ylim[2]) {
        ylim[2] <- gate_ycoords[2]
      }
    }
  }
  
  # AXES TEXT ------------------------------------------------------------------
  
  # Convert axes_text to list - allows inheritance from cyto_plot
  if (!is(axes_text, "list")) {
    axes_text <- list(axes_text[1], axes_text[2])
  }
  
  # X axis breaks and labels -  can be inherited from cyto_plot
  if (!is(axes_text[[1]], "list")) {
    if (.all_na(axes_text[[1]])) {
      # NA == TRUE returns NA not T/F
    } else if (axes_text[[1]] == TRUE) {
      lims <- list(xlim)
      names(lims) <- channels[1]
      axes_text[[1]] <- .cyto_plot_axes_text(x,
                                             channels = channels[1],
                                             axes_trans = axes_trans,
                                             axes_range = lims,
                                             axes_limits = axes_limits
      )[[1]]
    }
  }
  
  # Y axis breaks and labels - can be inherited from cyto_plot
  if (!is(axes_text[[2]], "list")) {
    if (.all_na(axes_text[[2]])) {
      # NA == TRUE returns NA not T/F
    } else if (axes_text[[2]] == TRUE) {
      if (length(channels) == 2) {
        lims <- list(ylim)
        names(lims) <- channels[2]
        axes_text[[2]] <- .cyto_plot_axes_text(x,
                                               channels = channels[2],
                                               axes_trans = axes_trans,
                                               axes_range = lims,
                                               axes_limits = axes_limits
        )[[1]]
      } else {
        axes_text[[2]] <- NA
      }
    }
  }
  
  # Turn off y axis labels for stacked overlays
  if (length(x) > 1 &
      hist_stack != 0 &
      length(channels) == 1) {
    axes_text <- list(axes_text[[1]], FALSE)
  }
  
  # AXES LABELS ----------------------------------------------------------------
  
  # AXES LABELS - missing replaced - NA removed
  axes_labels <- .cyto_plot_axes_label(x,
                                       channels = channels,
                                       xlab = xlab,
                                       ylab = ylab,
                                       hist_stat
  )
  xlab <- axes_labels[[1]]
  ylab <- axes_labels[[2]]
  
  # TITLE ----------------------------------------------------------------------
  
  # TITLE - missing replaced - NA removed
  title <- .cyto_plot_title(x,
                            channels = channels,
                            title = title
  )
  
  # MARGINS --------------------------------------------------------------------
  
  # Set plot margins - set par("mar")
  .cyto_plot_margins(x,
                     channels = channels,
                     legend = legend,
                     legend_text = legend_text,
                     legend_text_size = legend_text_size,
                     title = title,
                     axes_text = axes_text,
                     margins = margins,
                     point_col = point_col
  )
  
  # PLOT CONSTRUCTION ----------------------------------------------------------
  
  # Plot
  graphics::plot(1,
                 type = "n",
                 axes = FALSE,
                 xlim = xlim,
                 ylim = ylim,
                 xlab = "",
                 ylab = "",
                 bty = "n"
  )
  
  # X AXIS - TRANSFORMED
  if (is(axes_text[[1]], "list")) {
    # MINOR TICKS
    x_mnr_ind <- which(as.character(axes_text[[1]]$label) == "")
    axis(1,
         at = axes_text[[1]]$at[x_mnr_ind],
         labels = axes_text[[1]]$label[x_mnr_ind],
         tck = -0.015
    )
    
    # MAJOR TICKS - MUST BE >2% XRANGE FROM ZERO
    x_mjr_ind <- which(as.character(axes_text[[1]]$label) != "")
    x_mjr <- list(
      "at" = axes_text[[1]]$at[x_mjr_ind],
      "label" = axes_text[[1]]$label[x_mjr_ind]
    )
    # Zero included on plot
    if (any(as.character(x_mjr$label) == "0")) {
      zero <- which(as.character(x_mjr$label) == "0")
      zero_break <- x_mjr$at[zero]
      zero_buffer <- c(
        zero_break - 0.02 * (xlim[2] - xlim[1]),
        zero_break + 0.02 * (xlim[2] - xlim[1])
      )
      x_mjr_ind <- c(
        zero,
        which(x_mjr$at < zero_buffer[1] |
                x_mjr$at > zero_buffer[2])
      )
    } else {
      x_mjr_ind <- seq_len(length(x_mjr$label))
    }
    
    axis(1,
         at = x_mjr$at[x_mjr_ind],
         labels = x_mjr$label[x_mjr_ind],
         font.axis = axes_text_font,
         col.axis = axes_text_col,
         cex.axis = axes_text_size,
         tck = -0.03
    )
    # X AXIS - UNTRANSFORMED
  } else if (.all_na(axes_text[[1]])) {
    axis(1,
         font.axis = axes_text_font,
         col.axis = axes_text_col,
         cex.axis = axes_text_size,
         tck = -0.03
    )
  }
  
  # Y AXIS - TRANSFORMED
  if (is(axes_text[[2]], "list")) {
    # MINOR TICKS
    y_mnr_ind <- which(as.character(axes_text[[2]]$label) == "")
    axis(2,
         at = axes_text[[2]]$at[y_mnr_ind],
         labels = axes_text[[2]]$label[y_mnr_ind],
         tck = -0.015
    )
    # MAJOR TICKS - MUST BE >2% yrange FROM ZERO
    y_mjr_ind <- which(as.character(axes_text[[2]]$label) != "")
    y_mjr <- list(
      "at" = axes_text[[2]]$at[y_mjr_ind],
      "label" = axes_text[[2]]$label[y_mjr_ind]
    )
    # Zero included on plot
    if (any(as.character(y_mjr$label) == "0")) {
      zero <- which(as.character(y_mjr$label) == "0")
      zero_break <- y_mjr$at[zero]
      zero_buffer <- c(
        zero_break - 0.02 * (ylim[2] - ylim[1]),
        zero_break + 0.02 * (ylim[2] - ylim[1])
      )
      y_mjr_ind <- c(
        zero,
        which(y_mjr$at < zero_buffer[1] |
                y_mjr$at > zero_buffer[2])
      )
    } else {
      y_mjr_ind <- seq_len(length(y_mjr$label))
    }
    axis(2,
         at = y_mjr$at[y_mjr_ind],
         labels = y_mjr$label[y_mjr_ind],
         font.axis = axes_text_font,
         col.axis = axes_text_col,
         cex.axis = axes_text_size,
         tck = -0.03
    )
    # Y AXIS - LINEAR
  } else if (.all_na(axes_text[[2]])) {
    axis(2,
         font.axis = axes_text_font,
         col.axis = axes_text_col,
         cex.axis = axes_text_size,
         tck = -0.03
    )
  }
  
  # BORDER_FILL
  if (border_fill != "white") {
    rect(par("usr")[1], par("usr")[3], par("usr")[2], par("usr")[4],
         col = adjustcolor(border_fill, border_fill_alpha),
         border = NA
    )
  }
  
  # GRID LINES
  if (grid != FALSE) {
    # AXES BREAKS GRID LINES
    if (grid == TRUE) {
      if (length(channels) == 2) {
        axes_grid <- lapply(axes_text, `[[`, "at")
      } else {
        axes_grid <- list(axes_text[[1]]$at)
      }
      # QUANTILE GRID LINES - BASE LAYER ONLY
    } else {
      if (!is.numeric(grid)) {
        grid <- 10
      }
      axes_grid <- lapply(channels, function(z) {
        cyto_apply(x[[1]],
                   "cyto_stat_quantile",
                   channels = z,
                   input = "matrix",
                   copy = FALSE,
                   inverse = FALSE,
                   probs = seq(0, 1, ifelse(grid > 1, 1 / grid, grid))
        )[, 1]
      })
      names(axes_grid) <- channels
    }
    # X AXIS GRID LINES
    lapply(seq_along(axes_grid), function(z) {
      # VERTICAL LINES
      if (z == 1) {
        abline(
          v = axes_grid[[z]],
          lty = grid_line_type,
          lwd = grid_line_width,
          col = adjustcolor(grid_line_col, grid_line_alpha)
        )
        # HORIZONTAL LINES
      } else {
        abline(
          h = axes_grid[[z]],
          lty = grid_line_type,
          lwd = grid_line_width,
          col = adjustcolor(grid_line_col, grid_line_alpha)
        )
      }
    })
  }
  
  # BORDER
  box(
    which = "plot",
    lty = border_line_type,
    lwd = border_line_width,
    col = border_line_col
  )
  
  # TITLE
  if (!.all_na(title)) {
    title(
      main = title,
      cex.main = title_text_size,
      col.main = title_text_col,
      font.main = title_text_font
    )
  }
  
  # XLAB - position labels closer if axes text is missing
  if (!.all_na(xlab)) {
    if (is(axes_text[[1]], "list")) {
      title(
        xlab = xlab,
        font.lab = axes_label_text_font,
        col.lab = axes_label_text_col,
        cex.lab = axes_label_text_size
      )
    } else if (.all_na(axes_text[[1]])) {
      title(
        xlab = xlab,
        font.lab = axes_label_text_font,
        col.lab = axes_label_text_col,
        cex.lab = axes_label_text_size
      )
    } else if (axes_text[[1]] == FALSE) {
      title(
        xlab = xlab,
        font.lab = axes_label_text_font,
        col.lab = axes_label_text_col,
        cex.lab = axes_label_text_size,
        mgp = c(2, 0, 0)
      )
    }
  }
  
  # YLAB - position labels closer if axes text is missing
  if (!.all_na(ylab)) {
    if (is(axes_text[[2]], "list")) {
      title(
        ylab = ylab,
        font.lab = axes_label_text_font,
        col.lab = axes_label_text_col,
        cex.lab = axes_label_text_size
      )
    } else if (.all_na(axes_text[[2]])) {
      title(
        ylab = ylab,
        font.lab = axes_label_text_font,
        col.lab = axes_label_text_col,
        cex.lab = axes_label_text_size
      )
    } else if (axes_text[[2]] == FALSE) {
      title(
        ylab = ylab,
        font.lab = axes_label_text_font,
        col.lab = axes_label_text_col,
        cex.lab = axes_label_text_size,
        mgp = c(2, 0, 0)
      )
    }
  }
  
  # LEGEND ---------------------------------------------------------------------
  
  # POINT_COL_SCALE
  if (length(channels) == 2 &
      (is.na(point_col)[1] |
       any(point_col %in% c(cyto_channels(x), cyto_markers(x))))) {
    # LEGEND
    point_col_scale <- .cyto_plot_point_col_scale(point_col_scale)
    legend_col_ramp <- colorRamp(point_col_scale)
    legend_cols <- seq(0, 1, 1 / 50) # 50 boxes
    legend_cols <- legend_col_ramp(legend_cols)
    legend_cols <- rgb(legend_cols[, 1],
                       legend_cols[, 2],
                       legend_cols[, 3],
                       maxColorValue = 255
    )
    legend_cols <- adjustcolor(legend_cols, point_col_alpha[1])
    
    # LEGEND LOCATION
    legend_x <- c(
      par("usr")[2] + 0.005 * (par("usr")[2] - par("usr")[1]),
      par("usr")[2] + 0.035 * (par("usr")[2] - par("usr")[1])
    )
    legend_y <- c(par("usr")[3], par("usr")[4])
    
    # LEGEND BORDER
    rect(legend_x[1],
         legend_y[1],
         legend_x[2],
         legend_y[2],
         xpd = TRUE,
         lwd = 1
    )
    
    # LEGEND BOXES
    legend_box_x <- legend_x
    legend_box_y <- seq(
      par("usr")[3],
      par("usr")[4],
      (par("usr")[4] - par("usr")[3]) / 50
    )
    lapply(seq_len(50), function(z) {
      rect(legend_box_x[1],
           legend_box_y[z],
           legend_box_x[2],
           legend_box_y[z + 1],
           xpd = TRUE,
           col = legend_cols[z],
           border = NA
      )
    })
  }
  
  # LEGEND - FALSE/"fill"/"line"
  if (legend != FALSE) {
    .cyto_plot_legend(x,
                      channels = channels,
                      legend = legend,
                      legend_text = legend_text,
                      legend_text_font = legend_text_font,
                      legend_text_size = legend_text_size,
                      legend_text_col = legend_text_col,
                      legend_line_type = legend_line_type,
                      legend_line_width = legend_line_width,
                      legend_line_col = legend_line_col,
                      legend_box_fill = legend_box_fill,
                      legend_point_col = legend_point_col,
                      hist_cols = hist_cols,
                      hist_fill = hist_fill,
                      hist_fill_alpha = hist_fill_alpha,
                      hist_line_type = hist_line_type,
                      hist_line_width = hist_line_width,
                      hist_line_col = hist_line_col,
                      point_shape = point_shape,
                      point_size = point_size,
                      point_col_scale = point_col_scale,
                      point_cols = point_cols,
                      point_col = point_col,
                      point_col_alpha = point_col_alpha
    )
  }
}

## CYTO_PLOT_NEW ---------------------------------------------------------------

#' Open new graphics device for cyto_plot
#'
#' \code{cyto_plot_new} opens a new RStudio or pop-up graphics device and
#' accepts arguments to set the graphical parameters of the new device.
#' \code{cyto_plot_new()} is used internally by cyto_plot to open an OS-specific
#' interactive garphics device to facilitate gate drawing. Mac users will need
#' to install \href{https://www.xquartz.org/}{XQuartz} for this functionality.
#'
#' @param popup logical indicating whether a pop-up graphics device should be
#'   opened, set to TRUE by default if called outside of \code{cyto_plot()}.
#' @param ... additional graphical parameters supplied by name to be passed to
#'   \code{\link{cyto_plot_par}} to customise the new graphics device.
#'
#' @importFrom grDevices dev.cur dev.new dev.list dev.set graphics.off
#'
#' @examples
#' \dontrun{
#' # Open platform-specific graphics device
#' cyto_plot_new()
#' }
#'
#' @author Dillon Hammill, \email{Dillon.Hammill@anu.edu.au}
#'
#' @export
cyto_plot_new <- function(popup,
                          ...) {
  
  # POPUP
  if(missing(popup)) {
    # CALLED WITHIN CYTO_PLOT - USE SAME DEVICE TYPE
    if(!is.null(getOption("cyto_plot_method"))) {
      if(grepl("rstudio", names(dev.cur()), ignore.case = TRUE)) {
        popup <- FALSE
      } else {
        popup <- TRUE
      }
      # CALLED EXTERNALLY
    } else {
      popup <- TRUE
    }
  }
  
  # NULL -> RSTUDIOGD
  if (dev.cur() == 1) {
    dev.new()
  }
  
  # BYPASS ON CYTO_PLOT_SAVE
  if (!getOption("cyto_plot_save")) {
    # NEW DEVICE
    if (popup) {
      dev_new <- "popup"
    } else {
      dev_new <- "rstudio"
    }
    # CURRENT DEVICE
    dev_old <- names(dev.cur())
    if (grepl("rstudio", dev_old, ignore.case = TRUE)) {
      dev_old <- "rstudio"
    } else {
      dev_old <- "popup"
    }
    # CURRENT DEVICE - RSTUDIO
    if (dev_old == "rstudio") {
      # REQUIRE - POPUP
      if (dev_new == "popup") {
        # NEW POPUP DEVICE REQUIRED
        dev_new <- "popup"
        # REQUIRE - RSTUDIO
      } else {
        # PRESET LAYOUT OR EMPTY DEVICE
        if (getOption("cyto_plot_method") == "custom" | dev_empty()) {
          dev_new <- FALSE
          # NEW LAYOUT
        } else {
          dev_new <- "rstudio"
        }
      }
      # CURRENT DEVICE - POPUP
    } else if(dev_old == "popup") {
      # REQUIRE POPUP
      if (dev_new == "popup") {
        # PRESET LAYOUT OR EMPTY DEVICE
        if (getOption("cyto_plot_method") == "custom" | dev_empty()) {
          dev_new <- FALSE
          # NEW LAYOUT
        } else {
          dev_new <- "popup"
        }
        # REQUIRE - RSTUDIO
      } else {
        # NEW RSTUDIO DEVICE REQUIRED
        dev_new <- "rstudio"
      }
    }
    print(dev_new)
    # OPEN NEW GRAPHICS DEVICE
    if (dev_new != FALSE) {
      # POPUP DEVICE
      if (dev_new == "popup") {
        if (interactive() & getOption("CytoExploreR_interactive")) {
          if (.Platform$OS.type == "windows") {
            suppressWarnings(dev.new())
          } else if (.Platform$OS.type == "unix") {
            if (Sys.info()["sysname"] == "Linux") {
              # Cairo needed for semi-transparency
              suppressWarnings(dev.new(type = "cairo"))
            } else if (Sys.info()["sysname"] == "Darwin") {
              suppressWarnings(dev.new())
            }
          }
        }
        # RSTUDIO DEVICE
      } else if (dev_new == "rstudio") {
        dev_ind <- which(grepl("rstudio",
                               names(dev.list()),
                               ignore.case = TRUE
        ))
        if (length(dev_ind) != 0) {
          dev.set(dev.list()[dev_ind])
        } else {
          graphics.off()
          dev.new(noRStudioGD = FALSE)
        }
      }
    }
  }
  
  # SET GRAPHICAL PARAMATERS - INERITS CYTO_PLOT_PAR GLOBAL
  cyto_plot_par(...)
  
}

## DEV_EMPTY -------------------------------------------------------------------

#' Check if graphics device is empty
#' @importFrom graphics par
#' @noRd
dev_empty <- function() {
  # DEVICE EMPTY - NEW CAN ONLY BE CALLED IF PLOT EXISTS
  old_par <- .par("new")
  dev_empty <- tryCatch(
    par(new = TRUE)[["new"]],
    warning = function(w){TRUE},
    finally = function(f){FALSE})
  par(old_par)
  return(dev_empty)
}

## CYTO_PLOT_RESET -------------------------------------------------------------

#' Reset all cyto_plot related settings
#'
#' @author Dillon Hammill (Dillon.Hammill@anu.edu.au)
#'
#' @importFrom grDevices dev.off dev.cur
#' @export
cyto_plot_reset <- function() {
  
  # Create custom theme for cyto_plot
  options("cyto_plot_theme" = NULL)
  
  # Signal cyto_plot_save method has been called
  options("cyto_plot_save" = FALSE)
  
  # Signal which cyto_plot method has been called
  options("cyto_plot_method" = NULL)
  
  # Reset saved parameters
  options("cyto_plot_par" = NULL)
  
  # RESET PARAMETERS
  options("cyto_plot_par_reset" = NULL)
  
  # Reset memory
  .cyto_plot_args_remove()
  
  # Turn off graphics device
  if (dev.cur() != 1) {
    dev.off()
  }
  
  invisible(NULL)
}

## CYTO_PLOT_RECORD ------------------------------------------------------------

#' Record an existing cyto_plot
#'
#' \code{cyto_plot_record} will record an existing plot such that it can be
#' saved to an R object for future reference.
#'
#' @importFrom grDevices recordPlot
#'
#' @author Dillon Hammill (Dillon.Hammill@anu.edu.au)
#'
#' @examples
#' \dontrun{
#'
#' # Load CytoExploreRData to acces data
#' library(CytoExploreRData)
#'
#' # Activation flowSet
#' fs <- Activation
#'
#' # Construct cyto_plot
#' cyto_plot(fs[[1]],
#'   channels = c("FSC-A", "SSC-A")
#' )
#'
#' # Record plot and save to object called p
#' p <- cyto_plot_record()
#'
#' # Calling p will bring back the recorded plot
#' p
#' }
#'
#' @export
cyto_plot_record <- function() {
  recordPlot()
}

## CYTO_PLOT_SAVE --------------------------------------------------------------

#' Save High Resolution cyto_plot Images
#'
#' @param save_as name of the file to which the plot should be saved (including
#'   the file extension). Supported file formats include png, tiff, jpeg, svg
#'   and pdf.
#' @param width numeric indicating the width of exported plot in \code{units},
#'   set to 7 by default for image with width of 7 inches.
#' @param height numeric indicating the height of the exported plot in
#'   \code{units}, set to 7 by default for image with height of 7 inches.
#' @param units units to be used to set plot size, can be either pixels
#'   (\code{px}), inches (\code{inches}), centimetres (\code{cm}) or millimetres
#'   (\code{mm}). Set to \code{"in"} by default. Units cannot be altered for
#'   \code{svg} and \code{pdf} graphics devices.
#' @param res resolution in ppi, set to 300 by default.
#' @param multiple logical indicating whether multiple pages should be saved to
#'   separate numbered files, set to \code{FALSE} by default.
#' @param reset logical indicating whether to reset a previous call to
#'   \code{cyto_plot_save}.
#' @param ... additional arguments for the appropriate \code{png()},
#'   \code{tiff()}, \code{jpeg()}, \code{svg()} or \code{pdf} graphics devices.
#'
#' @importFrom grDevices png tiff jpeg pdf svg
#'
#' @author Dillon Hammill (Dillon.Hammill@anu.edu.au)
#'
#' @examples
#' \dontrun{
#' library(CytoExploreRData)
#'
#' # Load samples into GatingSet
#' fs <- Activation
#' gs <- GatingSet(fs)
#'
#' # Apply compensation
#' gs <- cyto_compensate(gs)
#'
#' # Transform fluorescent channels
#' gs <- cyto_transform(gs)
#'
#' # Apply gatingTemplate
#' cyto_gatingTemplate_apply(gs, Activation_gatingTemplate)
#'
#' # Save png image of gating scheme after plotting
#' cyto_plot_save("Gating-Scheme.png",
#'   width = 20,
#'   height = 16
#' )
#' cyto_plot_gating_scheme(gs[[1]])
#'
#' # Save multiple pages to the same pdf file
#' cyto_plot_save("CD4-T-Cells.pdf",
#'   height = 8,
#'   width = 16,
#'   multiple = TRUE
#' )
#' cyto_plot(gs,
#'   parent = "CD4 T Cells",
#'   alias = "",
#'   channels = c("Alexa Fluor 647-A", "7-AAD-A"),
#'   layout = c(1, 2)
#' )
#' }
#' @seealso \code{\link[grDevices:cairo]{cairo}}
#' @seealso \code{\link[grDevices:png]{png}}
#'
#' @export
cyto_plot_save <- function(save_as,
                           width = 7,
                           height = 7,
                           units = "in",
                           res = 300,
                           multiple = FALSE,
                           reset = FALSE,
                           ...) {
  
  # RESET
  if (reset == TRUE) {
    # CLOSE DEVICE
    dev.off()
    # RESET CYTO_PLOT_SAVE
    options("cyto_plot_save" = FALSE)
    # SET
  } else {
    # APPEND FILE EXTENSION
    save_as <- file_ext_append(save_as, ".png")
    # MULTIPLE FILES
    if (multiple == TRUE & file_ext(save_as) != "pdf") {
      save_as <- paste0(
        file_ext_remove(save_as),
        "_", "%03d", ".",
        file_ext(save_as)
      )
    }
    # PNG DEVICE
    if (file_ext(save_as) == "png") {
      png(
        filename = save_as,
        width = width,
        height = height,
        units = units,
        res = res,
        ...
      )
      # TIFF DEVICE
    } else if (file_ext(save_as) == "tiff") {
      tiff(
        filename = save_as,
        width = width,
        height = height,
        units = units,
        res = res,
        ...
      )
      # JPEG DEVICE
    } else if (file_ext(save_as) == "jpeg") {
      jpeg(
        filename = save_as,
        width = width,
        height = height,
        units = units,
        res = res,
        ...
      )
      # PDF DEVICE
    } else if (file_ext(save_as) == "pdf") {
      pdf(
        file = save_as,
        width = width,
        height = height,
        onefile = multiple,
        ...
      )
      # SVG DEVICE
    } else if (file_ext(save_as) == "svg") {
      svg(
        filename = save_as,
        width = width,
        height = height,
        ...
      )
    } else {
      stop(paste("Can't save file to", file_ext(save_as), "format."))
    }
    # Set global option to notify cyto_plot - dev.off() is required for saving
    options("cyto_plot_save" = TRUE)
  }
}

## CYTO_PLOT_CUSTOM ------------------------------------------------------------

#' Set customised graphical parameters for cyto_plot
#'
#' \code{cyto_plot_custom()} make a call to \code{cyto_plot_par()} to set
#' customised graphical parameters for the current graphics device.
#' \code{cyto_plot_custom()} will then signal to \code{cyto_plot()} to ensure
#' that these set graphical parameters are not overridden and to make sure that
#' the plots are only saved when the user calls \code{cyto_plot_complete()}.
#' \code{cyto_plot_custom()} will also record the current graphical parameters
#' before changing them, so that these can be reset when
#' \code{cyto_plot_complete()} is called.
#'
#' The sequence of calls to save a customised plot are described below:
#' \itemize{\item \code{cyto_plot_save()} - sets a new graphics device of the
#' appropriate type (e.g. \code{png()}) and makes sure that \code{cyto_plot()}
#' does not open other graphics devices \item \code{cyto_plot_custom()} - sets
#' up the current graphics device with customised graphical parameters and
#' indicates to \code{cyto_plot()} that the user will take control over when the
#' plot should be saved. \item \code{cyto_plot()} - the users can then makes
#' calls to any of the \code{cyto_plot()} family of function to construct the
#' plot on the customised graphics device. \item \code{cyto_plot_complete()} -
#' signals that the plot is complete and ready for saving to file. Since
#' \code{cyto_plot_complete()} also resets a lot of graphical parameters it
#' should be called even if a call has not been made to \code{cyto_plot_save()}.
#' }
#'
#' @param ... graphical parameters supplied by name to be passed to
#'   \code{\link{cyto_plot_par}} to customise the current graphics device.
#'
#' @author Dillon Hammill (Dillon.Hammill@anu.edu.au)
#'
#' @examples
#' \dontrun{
#' library(CytoExploreRData)
#'
#' # Activation flowSet
#' fs <- Activation
#'
#' # Save plot
#' cyto_plot_save("Test.png",
#'   height = 7,
#'   width = 14
#' )
#'
#' # Create custom plot - 1D & 2D plot panels
#' cyto_plot_custom(layout = c(1, 2))
#' cyto_plot(fs[[32]],
#'   channels = "FSC-A"
#' )
#' cyto_plot(fs[[32]],
#'   channels = c("FSC-A", "SSC-A")
#' )
#'
#' # Signal plot is complete and save
#' cyto_plot_complete()
#' }
#' @export
cyto_plot_custom <- function(...) {
  
  # SAVE PARS FOR CYTO_PLOT_COMPLETE RESET
  if (getOption("cyto_plot_method") != "custom") {
    options("cyto_plot_par_reset" = .par())
  }
  
  # METHOD
  options("cyto_plot_method" = "custom")
  
  # GRAPHICAL PARAMETERS
  cyto_plot_par(...)
  
  # RESET MEMORY
  if (!getOption("cyto_plot_save")) {
    .cyto_plot_args_remove()
  }
}

## CYTO_PLOT_COMPLETE ----------------------------------------------------------

#' Save custom plot and reset associated settings
#'
#' \code{cyto_plot_custom()} signals that a custom plot is ready for saving with
#' \code{cyto_plot_save()} and also resets any settings that were set by
#' \code{cyto_plot_custom()}. For this reason it is recommended that
#' \code{cyto_plot_complete()} be called after any plotting on a graphics device
#' that has been set up using \code{cyto_plot_custom()}.
#'
#' @param ... graphical parameters supplied by name to be passed to
#'   \code{\link{cyto_plot_par}} to reset the parameters of the current graphics
#'   device.
#'
#' @author Dillon Hammill (Dillon.Hammill@anu.edu.au)
#'
#' @examples
#' library(CytoExploreRData)
#'
#' # Load samples into GatingSet
#' fs <- Activation
#' gs <- GatingSet(fs)
#'
#' # Apply compensation
#' gs <- compensate(gs, fs[[1]]@description$SPILL)
#'
#' # Transform fluorescent channels
#' trans <- estimateLogicle(gs[[4]], cyto_fluor_channels(gs))
#' gs <- transform(gs, trans)
#'
#' # Apply gatingTemplate
#' gt <- Activation_gatingTemplate
#' gt_gating(gt, gs)
#'
#' # Save custom plot
#' cyto_plot_save("Custom.png",
#'   height = 8,
#'   width = 16
#' )
#'
#' # Set out plot layout
#' cyto_plot_layout(c(1, 2))
#'
#' # Add 2D plot
#' cyto_plot(gs[[4]],
#'   parent = "CD4 T Cells",
#'   alias = "",
#'   channels = c("Alexa Fluor 647-A", "7-AAD-A"),
#'   layout = FALSE
#' )
#'
#' # Add 1D plot
#' cyto_plot(gs,
#'   parent = "CD4 T Cells",
#'   alias = "",
#'   channels = "7-AAD-A",
#'   hist_stack = 0.6,
#'   layout = FALSE
#' )
#'
#' # Signal that the plot is complete
#' cyto_plot_complete()
#' @export
cyto_plot_complete <- function(...) {
  
  # CLOSE DEVICE (not RStudioGD/X11/quartz)
  if (getOption("cyto_plot_save")) {
    if (!names(dev.cur()) %in% c(
      "RStudioGD",
      "windows",
      "X11",
      "x11",
      "quartz"
    )) {
      dev.off()
    }
  }
  
  # CUSTOM - USE SAVED RESET PARAMETERS
  if (getOption("cyto_plot_method") == "custom") {
    # RESET PARAMETERS
    old_pars <- getOption("cyto_plot_par_reset")
    pars <- list(...)
    old_pars <- old_pars[!names(old_pars) %in% names(pars)]
    old_pars <- c(old_pars, pars)
    do.call("cyto_plot_par", old_pars)
    # NO SAVED RESET PARAMETERS
  } else {
    cyto_plot_par(...)
  }
  
  # RESET CYTO_PLOT_METHOD
  options("cyto_plot_method" = NULL)
  
  # RESET CYTO_PLOT_SAVE
  options("cyto_plot_save" = FALSE)
  
  # RESET SAVED PARAMETERS
  cyto_plot_par(reset = TRUE)
}

## CYTO_PLOT_THEME -------------------------------------------------------------

#' Create custom themes for cyto_plot
#'
#' \code{cyto_plot_theme} provides an easy way to alter the theme used by
#' \code{cyto_plot}. By calling \code{cyto_plot_theme} prior to plotting,
#' subsequent plots will inherit these arguments so there is no need to supply
#' them manually each time. For a complete list of supported arguments see
#' \code{cyto_plot_theme_args}.
#'
#' @param ... arguments supported by cyto_plot_theme.
#' @param reset logical indicating whether \code{cyto_plot_theme()} settings
#'   should be reset to use default settings, set to FALSE by default.
#'
#' @examples
#' # Make all plots have a black background
#' cyto_plot_theme(border_fill = "black")
#'
#' # Black ground with custom colour scale for points and purple gates
#' cyto_plot_theme(
#'   border_fill = "black",
#'   point_col_scale = c(
#'     "cyan",
#'     "green",
#'     "yellow",
#'     "orange",
#'     "red",
#'     "darkred"
#'   ),
#'   gate_line_col = "magenta"
#' )
#'
#' # Reset to default setting
#' cyto_plot_theme_reset()
#' @author Dillon Hammill (Dillon.Hammill@anu.edu.au)
#'
#' @export
cyto_plot_theme <- function(...,
                            reset = FALSE) {
  
  # RESET
  if (reset) {
    # RESET THEME
    options("cyto_plot_theme" = NULL)
    theme_args <- getOption("cyto_plot_theme")
    # SET
  } else {
    # CURRENT THEME ARGUMENTS
    theme_args <- getOption("cyto_plot_theme")
    # ARGUMENTS
    theme_new_args <- list(...)
    # NEW THEME ARGUMENTS
    if (length(theme_new_args) != 0) {
      # CHECK ARGUMENTS
      if (!all(names(theme_new_args) %in% cyto_plot_theme_args())) {
        lapply(names(theme_new_args), function(x) {
          if (!x %in% cyto_plot_theme_args()) {
            message(
              paste(x, "is not a supported argument for cyto_plot_theme.")
            )
          }
        })
      }
      # SUPPORTED ARGUMENTS ONLY
      theme_new_args <- theme_new_args[names(theme_new_args) %in%
                                         cyto_plot_theme_args()]
    }
    # REMOVE OLD PARAMETERS
    theme_args <- theme_args[!names(theme_args) %in% names(theme_new_args)]
    theme_args <- c(theme_args, theme_new_args)
    options("cyto_plot_theme" = theme_args)
  }
  # RETURN THEME ARUMENTS
  invisible(theme_args)
}

## CYTO_PLOT_PAR ---------------------------------------------------------------

#' Extract a list of graphical parameters set by cyto_plot
#'
#' This function is designed to used within \code{cyto_plot()} to return a list
#' of graphical parameters that have been set by \code{cyto_plot()}. This is not
#' intended to be used by the user, but can be used to check if there are any
#' graphical parameters that have not been properly reset after a call to
#' \code{cyto_plot()}. If required, these graphical parameters can be reset by
#' setting \code{reset = TRUE}.
#'
#' @param ... additional graphical parameters to be set by the current
#'   \code{cyto_plot()} call (e.g. mfrow = c(1,2)).
#' @param reset logical indicating whether these svaed graphical parameters
#'   should be reset, set to FALSE by default.
#'
#' @importFrom graphics par layout
#'
#' @return invisibly return a list of set graphical parameters.
#'
#' @author Dillon Hammill (Dillon.Hammill@anu.edu.au)
#'
#' @export
cyto_plot_par <- function(...,
                          reset = FALSE) {
  
  # RESET
  if (reset) {
    # RESET PARAMETERS
    options("cyto_plot_par" = NULL)
    par_args <- getOption("cyto_plot_par")
    # SET
  } else {
    # CURRENT PARAMETERS
    par_args <- getOption("cyto_plot_par")
    # NEW PARAMETERS
    par_new_args <- list(...)
    # PREPARE PARAMETERS
    par_args <- par_args[!names(par_args) %in% names(par_new_args)]
    par_args <- c(par_args, par_new_args)
    # LAYOUT
    if("layout" %in% names(par_args)) {
      print("YASS")
      layout <- par_args[["layout"]]
      par_args <- par_args[!names(par_args) %in% "layout"]
      if (is.numeric(layout)) {
        if (is.null(dim(layout))) {
          if (length(layout) == 2) {
            par_args <- c(par_args, list("mfrow" = layout))
          } else if (length(layout) == 3) {
            if (layout[3] == 1) {
              par_args <- c(par_args, list("mfrow" = layout[1:2]))
            } else {
              par_args <- c(par_args, list("mfcol" = layout[1:2]))
            }
          }
        } else {
          par_args <- c(par_args, list("layout" = layout))
          layout(layout)
        }
      }
    }
    # SAVE PARAMETERS
    options("cyto_plot_par" = par_args)
    # SET PARAMETERS
    if(length(par_args[!names(par_args) %in% "layout"]) > 0) {
      par(par_args[!names(par_args) %in% "layout"])
    }
  }
  # RETURN SET PARAMETERS
  invisible(par_args)
}

## CYTO_PLOT_THEME_ARGS --------------------------------------------------------

#' Get supported cyto_plot_theme arguments
#'
#' @return vector of argument names supported by cyto_plot_theme.
#'
#' @examples
#' cyto_plot_theme_args()
#' @author Dillon Hammill (Dillon.Hammill@anu.edu.au)
#'
#' @export
cyto_plot_theme_args <- function() {
  c(
    "axes_limits",
    "axes_limits_buffer",
    "margins",
    "popup",
    "hist_stat",
    "hist_bins",
    "hist_smooth",
    "hist_stack",
    "hist_cols",
    "hist_fill_alpha",
    "hist_line_type",
    "hist_line_width",
    "hist_line_col",
    "axes_text",
    "axes_text_font",
    "axes_text_size",
    "axes_text_col",
    "axes_label_text_font",
    "axes_label_text_size",
    "axes_label_text_col",
    "title_text_font",
    "title_text_size",
    "title_text_col",
    "legend",
    "legend_text_font",
    "legend_text_size",
    "legend_text_col",
    "legend_line_col",
    "legend_box_fill",
    "gate_line_type",
    "gate_line_width",
    "gate_line_col",
    "gate_fill",
    "gate_fill_alpha",
    "label",
    "label_position",
    "label_text_font",
    "label_text_size",
    "label_text_col",
    "label_fill",
    "label_fill_alpha",
    "border_fill",
    "border_fill_alpha",
    "border_line_type",
    "border_line_width",
    "border_line_col",
    "point_shape",
    "point_size",
    "point_col_scale",
    "point_cols",
    "point_col_alpha",
    "point_fast",
    "contour_lines",
    "contour_line_type",
    "contour_line_width",
    "contour_line_col",
    "contour_line_alpha",
    "grid",
    "grid_line_type",
    "grid_line_width",
    "grid_line_col",
    "grid_line_alpha"
  )
}
