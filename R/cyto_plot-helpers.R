## CYTO_PLOT_EMPTY -------------------------------------------------------------

#' Create an empty cyto_plot
#'
#' \code{cyto_plot_empty} generates a base for cyto_plot by creating an empty
#' plot with border, axes, axes_text and titles. Data is subsequently added to
#' this base layer with \code{cyto_plot_point} or \code{cyto_plot_hist}.
#'
#' @param x object of class \code{\link[flowWorkspace:cytoset]{cytoset}}.
#' @param channels name of the channel(s) or marker(s) to be used to construct
#'   the plot. The length of channels determines the type of plot to be
#'   constructed, either a 1-D density distribution for a single channel or a
#'   2-D scatterplot with blue-red colour scale for two channels.
#' @param axes_trans object of class
#'   \code{\link[flowCore:transformList-class]{transformList}} or
#'   \code{\link[flowWorkspace]{transformerList}} generated by
#'   \code{\link[flowCore:logicleTransform]{estimateLogicle}} which was used to
#'   transform the fluorescent channels of the supplied flowFrame. This
#'   transformation object will be used internally to ensure that the axes
#'   labels of the plot are appropriately transformed. The transformation object
#'   will NOT be applied to the flowFrame internally and should be applied to
#'   the flowFrame prior to plotting.
#' @param overlay a list of cytosets to overlay onto the plot.
#' @param gate list of gate objects to be plotted, used internally to ensure
#'   gate co-ordinates are taken into account when computing axes limits.
#' @param xlim lower and upper limits of x axis (e.g. c(0,5)).
#' @param ylim lower and upper limits of y axis (e.g. c(0,5)).
#' @param axes_limits options include \code{"auto"}, \code{"data"} or
#'   \code{"machine"} to use optimised, data or machine limits respectively. Set
#'   to \code{"auto"} by default to use optimised axes ranges. Fine control over
#'   axes limits can be obtained by altering the \code{xlim} and \code{ylim}
#'   arguments.
#' @param axes_limits_buffer decimal indicating the percentage of buffering to
#'   add to either end of the axes limits, set to 0.03 by default.
#' @param title title to use for the plot, set to the name of the sample by
#'   default. Title can be removed by setting this argument to \code{NA}.
#' @param xlab x axis label.
#' @param ylab y axis label.
#' @param margins a vector of length 4 to control the margins around the bottom,
#'   left, top and right of the plot, set to c(NA, NA, NA, NA) by default to let
#'   `cyto_plot` compute optimal margins.
#' @param hist_stat can be either \code{"count"}, \code{"percent"} or
#'   \code{"density"} to indicate the statistic to display on histograms, set to
#'   \code{"percent"} by default. The \code{"percent"} option applies modal
#'   normalisation and expresses the result as a percentage.
#' @param hist_smooth smoothing parameter passed to
#'   \code{\link[stats:density]{density}} to adjust the smoothness of the kernel
#'   density for histograms, set to \code{1} by default.
#' @param hist_bins number of bins to use for histograms, set to 256 by default.
#' @param hist_stack numeric [0,1] indicating the degree of stacking for
#'   histograms, set to \code{0} by default.
#' @param hist_layers numeric indicating the number of histograms to stack in
#'   each plot, set to all samples by default. Each plot must contain the same
#'   number of histograms.
#' @param hist_cols vector colours to draw from when selecting histogram fill
#'   colours if none are supplied to \code{hist_fill}.
#' @param hist_fill fill colour(s) for histograms, select from \code{hist_cols}
#'   if not supplied.
#' @param hist_fill_alpha numeric [0,1] used to control histogram fill colour
#'   transparency, set to \code{1} by default for solid colours.
#' @param hist_line_type line type(s) to use for histogram borders, set to 1 by
#'   default to use solid lines. See \code{\link[graphics:par]{lty}} for
#'   alternatives.
#' @param hist_line_width numeric to control line width(s) for histogram borders
#'   lines, set to 1 by default.
#' @param hist_line_col colour(s) for histogram borders, set to \code{"black"}
#'   by default.
#' @param point_shape shape(s) to use for points in 2-D scatterplots, set to
#'   \code{"."} by default to maximise plotting speed.  See
#'   \code{\link[graphics:par]{pch}} for alternatives.
#' @param point_size numeric to control the size of points in 2-D scatter plots
#'   set to 2 by default.
#' @param point_col_scale vector of colours to use for density gradient.
#' @param point_cols vector colours to draw from when selecting colours for
#'   points if none are supplied to point_col.
#' @param point_col colour(s) to use for points in 2-D scatter plots, set to NA
#'   by default to use a blue-red density colour scale.
#' @param point_col_alpha numeric [0,1] to control point colour transparency in
#'   2-D scatter plots, set to 1 by default to use solid colours.
#' @param axes_text logical vector of length 2 indicating whether axis text
#'   should be included for the x and y axes respectively, set to
#'   \code{c(TRUE,TRUE)} by default to display axes text on both axes.
#' @param axes_text_font numeric indicating the font to use for axes, set to 1
#'   for plain font by default. See \code{\link[graphics:par]{?par}} font for
#'   details.
#' @param axes_text_size character expansion for axis text.
#' @param axes_text_col colour of axis text.
#' @param axes_label_text_font numeric indicating the font to use for title, set
#'   to 1 for plain font by default. See \code{\link[graphics:par]{?par}} font
#'   for details.
#' @param axes_label_text_size character expansion for axis labels.
#' @param axes_label_text_col colour of axis labels.
#' @param title_text_font numeric indicating the font to use for title, set to 2
#'   for bold font by default. See \code{\link[graphics:par]{?par}} font for
#'   details.
#' @param title_text_size character expansion for plot title.
#' @param title_text_col colour for plot title.
#' @param border_line_type line type to use for plot border, set to 1 by default
#'   for a sold border.
#' @param border_line_width line width for plot border, set to 1 by default.
#' @param border_line_col line colour for plot border, set to "black" by
#'   default.
#' @param border_fill colour to use for the plot background, set to "white" by
#'   default.
#' @param border_fill_alpha transparency to use for border_fill colour, set to 1
#'   by default to add no transparency.
#' @param legend can be either \code{"line"} or \code{"fill"} to indicate
#'   whether a legend should be constructed based on the density \code{"line"}
#'   or \code{"fill"}, set to FALSE by default to remove the legend.
#' @param legend_text vector of labels to use in the legend.
#' @param legend_text_font numeric to control the font of legend text, set to 1
#'   for plain font by default. See \code{\link[graphics:par]{font}} for
#'   alternatives.
#' @param legend_text_size numeric to control the size of text in the legend,
#'   set to 1 by default.
#' @param legend_text_col colour(s) to use for text in legend, set to
#'   \code{"black"} by default.
#' @param legend_line_type numeric to control the line type for line legends,
#'   set to 1 by default. Refer to \code{lty} in \code{\link[graphics:par]{par}}
#'   for alternatives.
#' @param legend_line_width numeric to control the line width in line legend,
#'   set to 1 by default. Refer to \code{lwd} in \code{\link[graphics:par]{par}}
#'   for alternatives.
#' @param legend_line_col colour(s) to use for the lines in 1-D plot legends
#'   when legend is set to \code{"line"}.
#' @param legend_box_fill fill colour(s) to use for the boxes in 1-D plot
#'   legends when legend is set to \code{"fill"}.
#' @param legend_point_col colour(s) to use for points in 2-D scatter plot
#'   legend.
#' @param key options include \code{"scale"} to display only the colour scale,
#'   \code{"both"} to display the colour scale and text to annotate
#'   \code{counts} or \code{fluorescence units}, or \code{"none"} to remove the
#'   key from the plot(s). Set to \code{"both"} by default to display colour
#'   scale and associated text in the key.
#' @param key_scale inherits scale limits computed within \code{cyto_plot},
#'   should be a vector of the form \code{c(min, max)}, \code{cyto_plot_empty()}
#'   will attempt to compute these limits based on the supplied data if
#'   \code{key_scale} is not supplied. See the \code{key_scale} argument in
#'   \code{\link{cyto_plot}} for details.
#' @param key_text_font font to use for text in the key, set to 1 by default for
#'   plain font.
#' @param key_text_size numeric to control the size of text in the plot key, set
#'   to 1 by default.
#' @param key_text_col colour to use for text in the plot key, set to
#'   \code{"black"} by default.
#' @param key_text_col_alpha numeric [0, 1] to control the transparency of the
#'   text colour in the plot key, set to 1 by default to remove transparency.
#' @param key_title title to place above the key set to \code{"count"} when
#'   \code{point_col = NA} or the name of the channel/marker supplied to
#'   \code{point_col}.
#' @param key_title_text_font font to use for the key title, set to 1 by default
#'   for plain font.
#' @param key_title_text_size numeric to control the size of title text in teh
#'   key, set to 1 by default.
#' @param key_title_text_col colour to use for the key title, set to
#'   \code{"black"} by default.
#' @param key_title_text_col_alpha numeric [0, 1] to control the transparency of
#'   the key title text, set to 1 by default to remove transparency.
#' @param grid logical indicating whether to include grid lines in the plot
#'   background, set to TRUE by default. Alternatively, users can supply a
#'   integer to indicate the number of equally spaced quantiles to used for the
#'   grid lines.
#' @param grid_line_type integer [0,6] to control the line type of grid lines,
#'   set to \code{1} to draw solid lines by default. See
#'   \code{\link[graphics:par]{lty}} for alternatives.
#' @param grid_line_width numeric to control the line width(s) of grid lines,
#'   set to \code{1} by default.
#' @param grid_line_col colour to use for grid lines, set to \code{"grey95"} by
#'   default.
#' @param grid_line_alpha numeric [0,1] to control the transparency of grid
#'   lines, set to 1 by default to remove transparency.
#' @param ... not in use.
#'
#' @importFrom grDevices adjustcolor rgb colorRamp axisTicks
#' @importFrom graphics plot box axis title par rect axTicks abline
#' @importFrom methods formalArgs is
#'
#' @author Dillon Hammill (Dillon.Hammill@anu.edu.au)
#'
#' @examples
#' library(CytoExploreRData)
#'
#' # Construct an empty 2D plot with black background
#' cyto_plot_empty(Activation[[32]],
#'   channels = c("FSC-A", "SSC-A"),
#'   border_fill = "black"
#' )
#'
#' # Construct an empty 1D plot
#' cyto_plot_empty(Activation[[32]],
#'   channels = c("FSC-A"),
#'   overlay = Activation[1:2]
#' )
#' @export
cyto_plot_empty <- function(x,
                            channels,
                            axes_trans = NA,
                            overlay = NA,
                            gate = NA,
                            xlim = c(NA, NA),
                            ylim = c(NA, NA),
                            axes_limits = "auto",
                            axes_limits_buffer = 0.03,
                            title,
                            xlab,
                            ylab,
                            margins = c(NA, NA, NA, NA),
                            hist_stat = "count",
                            hist_smooth = 1,
                            hist_bins = 256,
                            hist_stack = 0.5,
                            hist_layers = 1,
                            hist_cols = NA,
                            hist_fill = NA,
                            hist_fill_alpha = 1,
                            hist_line_type = 1,
                            hist_line_width = 1,
                            hist_line_col = "black",
                            point_shape = ".",
                            point_size = 2,
                            point_col_scale = NA,
                            point_cols = NA,
                            point_col = NA,
                            point_col_alpha = 1,
                            axes_text = c(TRUE, TRUE),
                            axes_text_font = 1,
                            axes_text_size = 1,
                            axes_text_col = "black",
                            axes_label_text_font = 1,
                            axes_label_text_size = 1.1,
                            axes_label_text_col = "black",
                            title_text_font = 2,
                            title_text_size = 1.1,
                            title_text_col = "black",
                            border_line_type = 1,
                            border_line_width = 1,
                            border_line_col = "black",
                            border_fill = "white",
                            border_fill_alpha = 1,
                            legend = FALSE,
                            legend_text,
                            legend_text_font = 1,
                            legend_text_size = 1,
                            legend_text_col = "black",
                            legend_line_type = NA,
                            legend_line_width = NA,
                            legend_line_col = NA,
                            legend_box_fill = NA,
                            legend_point_col = NA,
                            key = "both",
                            key_scale = "fixed",
                            key_text_font = 1,
                            key_text_size = 0.8,
                            key_text_col = "black",
                            key_text_col_alpha = 1,
                            key_title = "",
                            key_title_text_font = 1,
                            key_title_text_size = 0.8,
                            key_title_text_col = "black",
                            key_title_text_col_alpha = 1,
                            grid = TRUE,
                            grid_line_type = 1,
                            grid_line_width = 1,
                            grid_line_col = "grey95",
                            grid_line_alpha = 1,
                            ...) {
  
  # PREPARE X ------------------------------------------------------------------
  
  # X CAN BE EITHER FLOWFRAME/FLOWFRAME LIST/CYTO_PLOT ARGUMENTS
  
  # HISTOGRAMS - CYTO_PLOT ARGUMENTS
  d <- NULL
  
  # CYTOSET
  if (cyto_class(x, "flowSet")) {
    x <- cyto_list(x)
    if(!.all_na(overlay)) {
      overlay <- cyto_list(overlay)
      x <- c(x, overlay)
    }
    # CYTO_PLOT ARGUMENTS
  } else if (class(x) == "cyto_plot") {
    .args_update(x)
  }
  
  # ARGUMENTS ------------------------------------------------------------------
  
  # Pull down arguments to named list
  args <- .args_list()
  
  # Inherit arguments from cyto_plot_theme
  args <- .cyto_plot_theme_inherit(args)
  
  # Update arguments
  .args_update(args)
  
  # CHANNELS -------------------------------------------------------------------
  
  # Check channels
  channels <- cyto_channels_extract(
    x[[1]],
    channels
  )
  
  # AXES LIMITS ----------------------------------------------------------------
  
  # XLIM
  if (any(is.na(xlim))) {
    # XLIM
    xlim[is.na(xlim)] <- .cyto_plot_axes_limits(x,
                                                channels = channels[1],
                                                gate = gate,
                                                axes_limits = axes_limits,
                                                buffer = axes_limits_buffer,
                                                plot = TRUE
    )[, 1][is.na(xlim)]
  }
  
  # YLIM
  if (any(is.na(ylim))) {
    # 1D PLOT
    if (length(channels) == 1) {
      if (is.null(d)) {
        d <- .cyto_plot_hist(x,
                             hist_stat = hist_stat,
                             hist_smooth = hist_smooth,
                             hist_bins = hist_bins,
                             hist_stack = hist_stack,
                             xlim = xlim
        )
      }
      # YLIM
      ymin <- d[[1]]$range[1]
      ymax <- max(
        LAPPLY(d, function(D){
          D$range[2]
        }),
        na.rm = TRUE
      )
      yrng <- c(ymin, ymax)
      ylim[is.na(ylim)] <- yrng[is.na(ylim)]
      # 2D PLOT
    } else if (length(channels) == 2) {
      # YLIM
      ylim[is.na(ylim)] <- .cyto_plot_axes_limits(x,
                                                  channels = channels[2],
                                                  gate = gate,
                                                  axes_limits = axes_limits,
                                                  buffer = axes_limits_buffer,
                                                  plot = TRUE
      )[, 1][is.na(ylim)]
    }
  }
  
  # AXES TEXT ------------------------------------------------------------------
  
  # Convert axes_text to list - allows inheritance from cyto_plot
  if (!cyto_class(axes_text, "list")) {
    axes_text <- list(axes_text[1], axes_text[2])
  }
  
  # X axis breaks and labels -  can be inherited from cyto_plot
  if (!cyto_class(axes_text[[1]], "list")) {
    if (.all_na(axes_text[[1]])) {
      # NA == TRUE returns NA not T/F
    } else if (axes_text[[1]] == TRUE) {
      axes_text[[1]] <- .cyto_plot_axes_text(x,
                                             channels = channels[1],
                                             axes_trans = axes_trans,
                                             axes_range = list(xlim),
                                             axes_limits = axes_limits
      )[[1]]
    }
  }
  
  # Y axis breaks and labels - can be inherited from cyto_plot
  if (!cyto_class(axes_text[[2]], "list")) {
    if (.all_na(axes_text[[2]])) {
      # NA == TRUE returns NA not T/F
    } else if (axes_text[[2]] == TRUE) {
      if (length(channels) == 2) {
        axes_text[[2]] <- .cyto_plot_axes_text(x,
                                               channels = channels[2],
                                               axes_trans = axes_trans,
                                               axes_range = list(ylim),
                                               axes_limits = axes_limits
        )[[1]]
      } else {
        axes_text[[2]] <- NA
      }
    }
  }
  
  # Turn off y axis labels for stacked overlays
  if (length(x) > 1 &
      hist_stack != 0 &
      length(channels) == 1) {
    axes_text <- list(axes_text[[1]], FALSE)
  }

  # AXES LABELS ----------------------------------------------------------------
  
  # AXES LABELS - missing replaced - NA removed
  axes_labels <- .cyto_plot_axes_label(x,
                                       channels = channels,
                                       xlab = xlab,
                                       ylab = ylab,
                                       hist_stat = hist_stat)
  xlab <- axes_labels[[1]]
  ylab <- axes_labels[[2]]
  
  # TITLE ----------------------------------------------------------------------
  
  # TITLE - missing replaced - NA removed
  title <- .cyto_plot_title(x,
                            channels = channels,
                            title = title
  )
  
  # KEY SCALE ------------------------------------------------------------------
  
  # KEY_SCALE REQUIRED FOR MARGINS
  if(length(channels) == 2 &
     (is.na(point_col)[1] |
      any(point_col %in% c(cyto_channels(x), cyto_markers(x)))) &
     key %in% c("scale", "both") &
     !cyto_class(key_scale, "cyto_plot_key")) {
    key_scale <- .cyto_plot_key_scale(
      x,
      channels = channels,
      xlim = xlim,
      ylim = ylim,
      point_col = point_col,
      key_scale = key_scale,
      axes_trans = axes_trans
    )[[1]]
  }
  
  # MARGINS --------------------------------------------------------------------
  
  # PLOT MARGINS - set par("mar")
  .cyto_plot_margins(x,
                     channels = channels,
                     legend = legend,
                     legend_text = legend_text,
                     legend_text_size = legend_text_size,
                     title = title,
                     axes_text = axes_text,
                     margins = margins,
                     point_col = point_col,
                     key = key,
                     key_scale = key_scale
  )
  
  # PLOT CONSTRUCTION ----------------------------------------------------------
  
  # PLOT
  graphics::plot(1,
                 type = "n",
                 axes = FALSE,
                 xlim = xlim,
                 ylim = ylim,
                 xlab = "",
                 ylab = "",
                 bty = "n"
  )
  
  # X AXIS TEXT
  if(.all_na(axes_text[[1]])) {
    axes_text[[1]] <- .cyto_plot_axes_text(
      x,
      channels = channels[1],
      axes_range = list(xlim),
      axes_limits = axes_limits,
      axes_limits_buffer = axes_limits_buffer,
      axes_trans = axes_trans
    )[[1]]
  }
  
  # ADD X AXIS TO PLOT
  if (cyto_class(axes_text[[1]], "list")) {
    # MINOR TICKS
    x_mnr_ind <- which(as.character(axes_text[[1]]$label) == "")
    axis(1,
         at = axes_text[[1]]$at[x_mnr_ind],
         labels = axes_text[[1]]$label[x_mnr_ind],
         tck = -0.015
    )
    
    # MAJOR TICKS
    x_mjr_ind <- which(as.character(axes_text[[1]]$label) != "")
    axis(1,
         at = axes_text[[1]]$at[x_mjr_ind],
         labels = axes_text[[1]]$label[x_mjr_ind],
         font.axis = axes_text_font,
         col.axis = axes_text_col,
         cex.axis = axes_text_size,
         tck = -0.03
    )
  }
  
  # Y AXIS TEXT
  if(.all_na(axes_text[[2]])) {
    axes_text[[2]] <- .cyto_plot_axes_text(
      x,
      channels = channels[2],
      axes_range = list(ylim),
      axes_limits = axes_limits,
      axes_limits_buffer = axes_limits_buffer,
      axes_trans = axes_trans
    )[[1]]
  }
  
  # ADD Y AXIS TO PLOT
  if (cyto_class(axes_text[[2]], "list")) {
    # MINOR TICKS
    y_mnr_ind <- which(as.character(axes_text[[2]]$label) == "")
    axis(2,
         at = axes_text[[2]]$at[y_mnr_ind],
         labels = axes_text[[2]]$label[y_mnr_ind],
         tck = -0.015
    )
    # MAJOR TICKS
    y_mjr_ind <- which(as.character(axes_text[[2]]$label) != "")
    axis(2,
         at = axes_text[[2]]$at[y_mjr_ind],
         labels = axes_text[[2]]$label[y_mjr_ind],
         font.axis = axes_text_font,
         col.axis = axes_text_col,
         cex.axis = axes_text_size,
         tck = -0.03
    )
  }
  
  # BORDER_FILL
  if (border_fill != "white") {
    rect(par("usr")[1], par("usr")[3], par("usr")[2], par("usr")[4],
         col = adjustcolor(border_fill, border_fill_alpha),
         border = NA
    )
  }
  
  # GRID LINES
  if (grid != FALSE) {
    # AXES BREAKS GRID LINES
    if (grid == TRUE) {
      if (length(channels) == 2) {
        axes_grid <- lapply(axes_text, `[[`, "at")
      } else {
        axes_grid <- list(axes_text[[1]]$at)
      }
      # QUANTILE GRID LINES - BASE LAYER ONLY
    } else {
      if (!is.numeric(grid)) {
        grid <- 10
      }
      axes_grid <- lapply(channels, function(z) {
        cyto_apply(x[[1]],
                   "cyto_stat_quantile",
                   channels = z,
                   input = "matrix",
                   copy = FALSE,
                   inverse = FALSE,
                   probs = seq(0, 1, ifelse(grid > 1, 1 / grid, grid))
        )[, 1]
      })
      names(axes_grid) <- channels
    }
    # X AXIS GRID LINES
    lapply(seq_along(axes_grid), function(z) {
      # VERTICAL LINES
      if (z == 1) {
        abline(
          v = axes_grid[[z]],
          lty = grid_line_type,
          lwd = grid_line_width,
          col = adjustcolor(grid_line_col, grid_line_alpha)
        )
        # HORIZONTAL LINES
      } else {
        abline(
          h = axes_grid[[z]],
          lty = grid_line_type,
          lwd = grid_line_width,
          col = adjustcolor(grid_line_col, grid_line_alpha)
        )
      }
    })
  }
  
  # BORDER
  box(
    which = "plot",
    lty = border_line_type,
    lwd = border_line_width,
    col = border_line_col
  )
  
  # TITLE
  if (!.all_na(title)) {
    title(
      main = title,
      cex.main = title_text_size,
      col.main = title_text_col,
      font.main = title_text_font
    )
  }
  
  # XLAB - position labels closer if axes text is missing
  if (!.all_na(xlab)) {
    if (is(axes_text[[1]], "list")) {
      title(
        xlab = xlab,
        font.lab = axes_label_text_font,
        col.lab = axes_label_text_col,
        cex.lab = axes_label_text_size
      )
    } else if (.all_na(axes_text[[1]])) {
      title(
        xlab = xlab,
        font.lab = axes_label_text_font,
        col.lab = axes_label_text_col,
        cex.lab = axes_label_text_size
      )
    } else if (axes_text[[1]] == FALSE) {
      title(
        xlab = xlab,
        font.lab = axes_label_text_font,
        col.lab = axes_label_text_col,
        cex.lab = axes_label_text_size,
        mgp = c(2, 0, 0)
      )
    }
  }
  
  # YLAB - position labels closer if axes text is missing
  if (!.all_na(ylab)) {
    if (is(axes_text[[2]], "list")) {
      title(
        ylab = ylab,
        font.lab = axes_label_text_font,
        col.lab = axes_label_text_col,
        cex.lab = axes_label_text_size
      )
    } else if (.all_na(axes_text[[2]])) {
      title(
        ylab = ylab,
        font.lab = axes_label_text_font,
        col.lab = axes_label_text_col,
        cex.lab = axes_label_text_size
      )
    } else if (axes_text[[2]] == FALSE) {
      title(
        ylab = ylab,
        font.lab = axes_label_text_font,
        col.lab = axes_label_text_col,
        cex.lab = axes_label_text_size,
        mgp = c(2, 0, 0)
      )
    }
  }
  
  # KEY ------------------------------------------------------------------------
  
  # KEY - COUNTS OR MARKER EXPRESSION - BASE LAYER ONLY
  if(length(channels) == 2 &
     (is.na(point_col)[1] |
      any(point_col %in% c(cyto_channels(x), cyto_markers(x)))) &
     !key %in% "none") {
    # ADD KEY TO PLOT
    .cyto_plot_key(
      x,
      channels = channels,
      xlim = xlim,
      ylim = ylim,
      point_col = point_col,
      point_col_scale = point_col_scale,
      point_col_alpha = point_col_alpha,
      key = key,
      key_scale = key_scale,
      key_text_font = key_text_font,
      key_text_size = key_text_size,
      key_text_col = key_text_col,
      key_text_col_alpha = key_text_col_alpha,
      axes_trans = axes_trans,
      key_title = key_title,
      key_title_text_font = key_title_text_font,
      key_title_text_col = key_title_text_col,
      key_title_text_col_alpha = key_title_text_col_alpha
    )
  }
  
  # LEGEND - FALSE/"fill"/"line"
  if (legend != FALSE) {
    .cyto_plot_legend(x,
                      channels = channels,
                      legend = legend,
                      legend_text = legend_text,
                      legend_text_font = legend_text_font,
                      legend_text_size = legend_text_size,
                      legend_text_col = legend_text_col,
                      legend_line_type = legend_line_type,
                      legend_line_width = legend_line_width,
                      legend_line_col = legend_line_col,
                      legend_box_fill = legend_box_fill,
                      legend_point_col = legend_point_col,
                      hist_cols = hist_cols,
                      hist_fill = hist_fill,
                      hist_fill_alpha = hist_fill_alpha,
                      hist_line_type = hist_line_type,
                      hist_line_width = hist_line_width,
                      hist_line_col = hist_line_col,
                      point_shape = point_shape,
                      point_size = point_size,
                      point_col_scale = point_col_scale,
                      point_cols = point_cols,
                      point_col = point_col,
                      point_col_alpha = point_col_alpha
    )
  }
}

## CYTO_PLOT_NEW ---------------------------------------------------------------

#' Open new graphics device for cyto_plot
#'
#' \code{cyto_plot_new} opens a new RStudio or pop-up graphics device and
#' accepts arguments to set the graphical parameters of the new device.
#' \code{cyto_plot_new()} is used internally by cyto_plot to open an OS-specific
#' interactive garphics device to facilitate gate drawing. Mac users will need
#' to install \href{https://www.xquartz.org/}{XQuartz} for this functionality.
#'
#' @param popup logical indicating whether a pop-up graphics device should be
#'   opened, set to TRUE by default if called outside of \code{cyto_plot()}.
#' @param popup_size  a vector of length 2 to control the height and width of
#'   pop-up graphics device in inches, set to \code{c(10,10)} by default. 
#' @param ... additional graphical parameters supplied by name to be passed to
#'   \code{\link{cyto_plot_par}} to customise the new graphics device.
#'
#' @importFrom grDevices dev.cur dev.new dev.list dev.set graphics.off
#' @importFrom graphics par layout
#'
#' @examples
#' \dontrun{
#' # Open platform-specific graphics device
#' cyto_plot_new()
#' }
#'
#' @author Dillon Hammill, \email{Dillon.Hammill@anu.edu.au}
#'
#' @export
cyto_plot_new <- function(popup = NULL,
                          popup_size = NULL,
                          ...) {
  
  # STORED PARAMETERS ----------------------------------------------------------
  
  # STORED GRAPHICAL PARAMETERS
  set_pars <- cyto_option("cyto_plot_par")
  
  # CYTO_PLOT_SAVE - POPUP -> FALSE
  if(cyto_option("cyto_plot_save")) {
    popup <- FALSE
  }
  
  # INHERIT POPUP ARGUMENT
  if(is.null(popup)) {
    # USE STORED SETTING
    if("popup" %in% names(set_pars)) {
      popup <- set_pars$popup
    # USE SAME DEVICE TYPE
    } else {
      if(grepl("rstudio", names(dev.cur()), ignore.case = TRUE)) {
        popup <- FALSE
      } else {
        popup <- TRUE
      }
    }
  }
  
  # INHERIT POPUP_SIZE ARGUMENT
  if(is.null(popup_size)) {
    # CHECK GLOBAL SETTINGS
    if("popup_size" %in% names(set_pars)) {
      popup_size <- set_pars$popup_size
    } else {
      popup_size <- c(10,10)
    }
  }
  
  # STORE POPUP & POPUP_SIZE GLOBALLY
  set_pars$popup <- popup
  set_pars$popup_size <- popup_size
  cyto_option("cyto_plot_par", set_pars)
  set_pars <- set_pars[!names(set_pars) %in% c("popup", "popup_size")]
  
  # OPEN NEW GRAPHICS DEVICE ---------------------------------------------------
  
  # CYTO_PLOT_SAVE
  if(cyto_option("cyto_plot_save")) {
    # DON'T OPEN NEW DEVICE - USE EXISTING DEVICE (PDF MULTIPAGE)
    dev_new <- FALSE
  # NEW GRAPHICS DEVICE REQUIRED?
  } else {
    # NULL -> RSTUDIOGD
    if (dev.cur() == 1) {
      dev.new()
    }
    # NEW DEVICE
    if (popup) {
      dev_new <- "popup"
    } else {
      dev_new <- "rstudio"
    }
    # CURRENT DEVICE
    dev_old <- names(dev.cur())
    if (grepl("rstudio", dev_old, ignore.case = TRUE)) {
      dev_old <- "rstudio"
    } else {
      dev_old <- "popup"
    }
    # CURRENT DEVICE - RSTUDIO
    if (dev_old == "rstudio") {
      # REQUIRE - POPUP
      if (dev_new == "popup") {
        # NEW POPUP DEVICE REQUIRED
        dev_new <- "popup"
        # REQUIRE - RSTUDIO
      } else {
        # EMPTY DEVICE
        if(dev_empty()) {
          dev_new <- FALSE
        # CUSTOM PLOTTING FUNCTION - OPEN NEW DEVICE WHEN FULL
        } else if(cyto_option("cyto_plot_method") != "cytoset") {
          # OPEN NEW DEVICE WHEN FULL
          if(.par("page")[[1]]) {
            dev_new <- "rstudio"
          } else {
            dev_new <- FALSE
          }
          # NEW LAYOUT
        } else {
          dev_new <- "rstudio"
        }
      }
      # CURRENT DEVICE - POPUP
    } else if(dev_old == "popup") {
      # REQUIRE POPUP
      if (dev_new == "popup") {
        # EMPTY DEVICE
        if(dev_empty()){
          dev_new <- FALSE
        # CUSTOM PLOTTING FUNCTION - OPEN NEW DEVICE WHEN FULL
        } else if(cyto_option("cyto_plot_method") != "cytoset") {
          # OPEN NEW GRAPHICS DEVICE WHEN FULL
          if(.par("page")[[1]]) {
            dev_new <- "popup"
          } else {
            dev_new <- FALSE
          }
          # NEW LAYOUT
        } else {
          dev_new <- "popup"
        }
        # REQUIRE - RSTUDIO
      } else {
        # NEW RSTUDIO DEVICE REQUIRED
        dev_new <- "rstudio"
      }
    }
    # OPEN NEW GRAPHICS DEVICE
    if (dev_new != FALSE) {
      # POPUP DEVICE
      if (dev_new == "popup") {
        if (interactive() & cyto_option("CytoExploreR_interactive")) {
          if (.Platform$OS.type == "windows") {
            suppressWarnings(dev.new(height = popup_size[1],
                                     width = popup_size[2],
                                     unit = "in",
                                     noRStudioGD = TRUE))
          } else if (.Platform$OS.type == "unix") {
            if (Sys.info()["sysname"] == "Linux") {
              # Cairo needed for semi-transparency
              suppressWarnings(dev.new(height = popup_size[1],
                                       width = popup_size[2],
                                       unit = "in",
                                       noRStudioGD = TRUE,
                                       type = "cairo"))
            } else if (Sys.info()["sysname"] == "Darwin") {
              suppressWarnings(dev.new(height = popup_size[1],
                                       width = popup_size[2],
                                       unit = "in",
                                       noRStudioGD = TRUE))
            }
          }
        }
        # RSTUDIO DEVICE
      } else if (dev_new == "rstudio") {
        dev_ind <- which(grepl("rstudio",
                               names(dev.list()),
                               ignore.case = TRUE
        ))
        if (length(dev_ind) != 0) {
          dev.set(dev.list()[dev_ind])
        } else {
          graphics.off()
          dev.new(noRStudioGD = FALSE)
        }
      }
    }
  }
  
  # INCOMING PARAMETERS --------------------------------------------------------
  
  # NEW PARAMETERS
  new_pars <- list(...)
  
  # SET PARAMETERS -------------------------------------------------------------
  
  # EMPTY DEVICE - SET ALL PARAMETERS
  if(dev_empty()) {
    # COMBINE SET_PARS & NEW_PARS - REPLACE OLD WITH NEW
    set_pars <- c(
      set_pars[!names(set_pars) %in% names(new_pars)],
      new_pars
    )
  # USED DEVICE - BYPASS LAYOUT/OMA PARAMETERS
  } else {
    # SET NEW PARAMETERS OT PARAMETERS THAT CHANGE & NOT PRIVILEGED
    shared_pars <- names(new_pars)[names(new_pars) %in% names(set_pars)]
    update_pars <- structure(
      lapply(shared_pars, function(z){
        if(!setequal(new_pars[[z]], set_pars[[z]])) {
          return(new_pars[[z]])
        } else {
          return(NULL)
        }
      }),
      names = shared_pars
    )
    update_pars[LAPPLY(update_pars, "is.null")] <- NULL
    set_pars <- c(
      update_pars,
      new_pars[!names(new_pars) %in% names(set_pars)] # NEW
    )
    # EXCLUDE PARAMETERS THAT REQUIRE NEW DEVICE
    set_pars <- set_pars[!names(set_pars) %in% c("layout",
                                                 "mfrow",
                                                 "mfcol",
                                                 "oma",
                                                 "omi",
                                                 "omd")]
  }
  
  # SET GRAPHICAL PARAMETERS
  do.call("cyto_plot_par", set_pars)

}

## DEV_EMPTY -------------------------------------------------------------------

#' Check if graphics device is empty
#' @importFrom graphics par
#' @noRd
dev_empty <- function() {
  # DEVICE EMPTY - NEW CAN ONLY BE CALLED IF PLOT EXISTS
  old_par <- .par("new")
  dev_empty <- tryCatch(
    par(new = TRUE)[["new"]],
    warning = function(w){TRUE},
    finally = function(f){FALSE})
  par(old_par)
  return(dev_empty)
}

## CYTO_PLOT_RESET -------------------------------------------------------------

#' Reset all cyto_plot related settings
#'
#' @author Dillon Hammill (Dillon.Hammill@anu.edu.au)
#'
#' @importFrom grDevices dev.off dev.cur
#' @export
cyto_plot_reset <- function() {
  
  # Create custom theme for cyto_plot
  cyto_option("cyto_plot_theme", NULL)
  
  # Signal cyto_plot_save method has been called
  cyto_option("cyto_plot_save", FALSE)
  
  # Signal which cyto_plot method has been called
  cyto_option("cyto_plot_method", NULL)
  
  # Reset saved parameters
  cyto_plot_par(reset = TRUE)
  
  # Reset memory
  .cyto_plot_args_remove()
  
  # Turn off graphics device
  if (dev.cur() != 1) {
    dev.off()
  }
  
  invisible(NULL)
}

## CYTO_OPTION -----------------------------------------------------------------

#' Retrieve or set a global option for CytoExploreR
#'
#' @param option name of the option to retrieve or set.
#' @param value a value to replace the current option.
#'
#' @return return current value of option if no \code{value} is supplied,
#'   otherwise update the existing value of the option.
#'
#' @author Dillon Hammill (Dillon.Hammill@anu.edu.au)
#'
#' @examples
#' # Extract current theme settings
#' cyto_option("cyto_plot_theme")
#'
#' @export
cyto_option <- function(option, value) {
  # RETRIEVE OPTION
  if(missing(value)) {
    getOption(option)
  # SET OPTION
  } else {
    do.call(
      "options",
      structure(
        list(value),
        names = option
      )
    )
  }
}

## CYTO_PLOT_RECORD ------------------------------------------------------------

#' Record an existing cyto_plot
#'
#' \code{cyto_plot_record} will record an existing plot such that it can be
#' saved to an R object for future reference.
#'
#' @importFrom grDevices recordPlot
#'
#' @author Dillon Hammill (Dillon.Hammill@anu.edu.au)
#'
#' @examples
#' \dontrun{
#'
#' # Load CytoExploreRData to acces data
#' library(CytoExploreRData)
#'
#' # Activation flowSet
#' fs <- Activation
#'
#' # Construct cyto_plot
#' cyto_plot(fs[[1]],
#'   channels = c("FSC-A", "SSC-A")
#' )
#'
#' # Record plot and save to object called p
#' p <- cyto_plot_record()
#'
#' # Calling p will bring back the recorded plot
#' p
#' }
#'
#' @export
cyto_plot_record <- function() {
  recordPlot()
}

## CYTO_PLOT_NEW_PAGE ----------------------------------------------------------

#' Add plots to a new page 
#'
#' \code{cyto_plot_fill()} is a handy function designed to fill incomplete
#' \code{cyto_plot()} layouts so that the next call to \code{cyto_plot()}
#' generates a plot on a new page.
#'
#' @author Dillon Hammill (Dillon.Hammill@anu.edu.au)
#'
#' @importFrom graphics plot.new
#'
#' @examples
#' library(CytoExploreRData)
#' library(flowWorkspace)
#' 
#' cs <- flowSet_to_cytoset(Activation)
#' 
#' # create custom plot layout
#' cyto_plot_custom(layout = c(2,2))
#' 
#' # add some plots - leave some panels empty
#' cyto_plot(
#'   cs[1:3],
#'   channels = c("FSC-A", "SSC-A")
#' )
#' 
#' # signal page is complete - use new page for next plots
#' cyto_plot_new_page()
#' 
#' # add these plots to new page
#' cyto_plot(
#'   cs[4:7],
#'   channels = c("FSC-A", "SSC-A")
#' )
#' 
#' @export
cyto_plot_new_page <- function(){
  while(!.par("page")[[1]]) {
    plot.new()
  }
}

## CYTO_PLOT_SAVE --------------------------------------------------------------

#' Save High Resolution cyto_plot Images
#'
#' @param save_as name of the file to which the plot should be saved (including
#'   the file extension). Supported file formats include png, tiff, jpeg, svg
#'   and pdf.
#' @param width numeric indicating the width of exported plot in \code{units},
#'   set to 7 by default for image with width of 7 inches.
#' @param height numeric indicating the height of the exported plot in
#'   \code{units}, set to 7 by default for image with height of 7 inches.
#' @param units units to be used to set plot size, can be either pixels
#'   (\code{px}), inches (\code{inches}), centimetres (\code{cm}) or millimetres
#'   (\code{mm}). Set to \code{"in"} by default. Units cannot be altered for
#'   \code{svg} and \code{pdf} graphics devices.
#' @param res resolution in ppi, set to 300 by default.
#' @param multiple logical indicating whether multiple pages should be saved to
#'   separate numbered files, set to \code{FALSE} by default.
#' @param reset logical indicating whether to reset a previous call to
#'   \code{cyto_plot_save}.
#' @param ... additional arguments for the appropriate \code{png()},
#'   \code{tiff()}, \code{jpeg()}, \code{svg()} or \code{pdf} graphics devices.
#'
#' @importFrom grDevices png tiff jpeg pdf svg
#'
#' @author Dillon Hammill (Dillon.Hammill@anu.edu.au)
#'
#' @examples
#' \dontrun{
#' library(CytoExploreRData)
#'
#' # Load samples into GatingSet
#' fs <- Activation
#' gs <- GatingSet(fs)
#'
#' # Apply compensation
#' gs <- cyto_compensate(gs)
#'
#' # Transform fluorescent channels
#' gs <- cyto_transform(gs)
#'
#' # Apply gatingTemplate
#' cyto_gatingTemplate_apply(gs, Activation_gatingTemplate)
#'
#' # Save png image of gating scheme after plotting
#' cyto_plot_save("Gating-Scheme.png",
#'   width = 20,
#'   height = 16
#' )
#' cyto_plot_gating_scheme(gs[[1]])
#'
#' # Save multiple pages to the same pdf file
#' cyto_plot_save("CD4-T-Cells.pdf",
#'   height = 8,
#'   width = 16,
#'   multiple = TRUE
#' )
#' cyto_plot(gs,
#'   parent = "CD4 T Cells",
#'   alias = "",
#'   channels = c("Alexa Fluor 647-A", "7-AAD-A"),
#'   layout = c(1, 2)
#' )
#' }
#' @seealso \code{\link[grDevices:cairo]{cairo}}
#' @seealso \code{\link[grDevices:png]{png}}
#'
#' @export
cyto_plot_save <- function(save_as,
                           width = 7,
                           height = 7,
                           units = "in",
                           res = 300,
                           multiple = FALSE,
                           reset = FALSE,
                           ...) {
  
  # RESET
  if (reset == TRUE) {
    # CLOSE DEVICE
    dev.off()
    # RESET CYTO_PLOT_SAVE
    cyto_option("cyto_plot_save", FALSE)
    # SET
  } else {
    # APPEND FILE EXTENSION
    save_as <- file_ext_append(save_as, ".png")
    # MULTIPLE FILES
    if (multiple == TRUE & file_ext(save_as) != "pdf") {
      save_as <- paste0(
        file_ext_remove(save_as),
        "_", "%03d", ".",
        file_ext(save_as)
      )
    }
    # PNG DEVICE
    if (file_ext(save_as) == "png") {
      png(
        filename = save_as,
        width = width,
        height = height,
        units = units,
        res = res,
        ...
      )
      # TIFF DEVICE
    } else if (file_ext(save_as) == "tiff") {
      tiff(
        filename = save_as,
        width = width,
        height = height,
        units = units,
        res = res,
        ...
      )
      # JPEG DEVICE
    } else if (file_ext(save_as) == "jpeg") {
      jpeg(
        filename = save_as,
        width = width,
        height = height,
        units = units,
        res = res,
        ...
      )
      # PDF DEVICE
    } else if (file_ext(save_as) == "pdf") {
      pdf(
        file = save_as,
        width = width,
        height = height,
        onefile = multiple,
        ...
      )
      # SVG DEVICE
    } else if (file_ext(save_as) == "svg") {
      svg(
        filename = save_as,
        width = width,
        height = height,
        ...
      )
    } else {
      stop(paste("Can't save file to", file_ext(save_as), "format."))
    }
    # Set global option to notify cyto_plot - dev.off() is required for saving
    cyto_option("cyto_plot_save", TRUE)
  }
}

## CYTO_PLOT_CUSTOM ------------------------------------------------------------

#' Set customised graphical parameters for cyto_plot
#'
#' \code{cyto_plot_custom()} make a call to \code{cyto_plot_par()} to set
#' customised graphical parameters for the current graphics device.
#' \code{cyto_plot_custom()} will then signal to \code{cyto_plot()} to ensure
#' that these set graphical parameters are not overridden and to make sure that
#' the plots are only saved when the user calls \code{cyto_plot_complete()}.
#' \code{cyto_plot_custom()} will also record the current graphical parameters
#' before changing them, so that these can be reset when
#' \code{cyto_plot_complete()} is called.
#'
#' The sequence of calls to save a customised plot are described below:
#' \itemize{\item \code{cyto_plot_save()} - sets a new graphics device of the
#' appropriate type (e.g. \code{png()}) and makes sure that \code{cyto_plot()}
#' does not open other graphics devices \item \code{cyto_plot_custom()} - sets
#' up the current graphics device with customised graphical parameters and
#' indicates to \code{cyto_plot()} that the user will take control over when the
#' plot should be saved. \item \code{cyto_plot()} - the users can then makes
#' calls to any of the \code{cyto_plot()} family of function to construct the
#' plot on the customised graphics device. \item \code{cyto_plot_complete()} -
#' signals that the plot is complete and ready for saving to file. Since
#' \code{cyto_plot_complete()} also resets a lot of graphical parameters it
#' should be called even if a call has not been made to \code{cyto_plot_save()}.
#' }
#'
#' @param ... graphical parameters supplied by name to be passed to
#'   \code{\link{cyto_plot_par}} to customise the current graphics device.
#'
#' @author Dillon Hammill (Dillon.Hammill@anu.edu.au)
#'
#' @examples
#' \dontrun{
#' library(CytoExploreRData)
#'
#' # Activation flowSet
#' fs <- Activation
#'
#' # Save plot
#' cyto_plot_save("Test.png",
#'   height = 7,
#'   width = 14
#' )
#'
#' # Create custom plot - 1D & 2D plot panels
#' cyto_plot_custom(layout = c(1, 2))
#' cyto_plot(fs[[32]],
#'   channels = "FSC-A"
#' )
#' cyto_plot(fs[[32]],
#'   channels = c("FSC-A", "SSC-A")
#' )
#'
#' # Signal plot is complete and save
#' cyto_plot_complete()
#' }
#' @export
cyto_plot_custom <- function(...) {
  
  # METHOD
  cyto_option("cyto_plot_method", "custom")
  
  # GRAPHICAL PARAMETERS
  cyto_plot_new(...)
  
  # RESET MEMORY
  if (!cyto_option("cyto_plot_save")) {
    .cyto_plot_args_remove()
  }
  
  invisible(NULL)
}

## CYTO_PLOT_COMPLETE ----------------------------------------------------------

#' Save custom plot and reset associated settings
#'
#' \code{cyto_plot_custom()} signals that a custom plot is ready for saving with
#' \code{cyto_plot_save()} and also resets any settings that were set by
#' \code{cyto_plot_custom()}. For this reason it is recommended that
#' \code{cyto_plot_complete()} be called after any plotting on a graphics device
#' that has been set up using \code{cyto_plot_custom()}.
#'
#' @param ... graphical parameters supplied by name to be passed to
#'   \code{\link{cyto_plot_par}} to reset the parameters of the current graphics
#'   device.
#'
#' @author Dillon Hammill (Dillon.Hammill@anu.edu.au)
#'
#' @examples
#' library(CytoExploreRData)
#'
#' # Load samples into GatingSet
#' fs <- Activation
#' gs <- GatingSet(fs)
#'
#' # Apply compensation
#' gs <- compensate(gs, fs[[1]]@description$SPILL)
#'
#' # Transform fluorescent channels
#' trans <- estimateLogicle(gs[[4]], cyto_fluor_channels(gs))
#' gs <- transform(gs, trans)
#'
#' # Apply gatingTemplate
#' gt <- Activation_gatingTemplate
#' gt_gating(gt, gs)
#'
#' # Save custom plot
#' cyto_plot_save("Custom.png",
#'   height = 8,
#'   width = 16
#' )
#'
#' # Set out plot layout
#' cyto_plot_layout(c(1, 2))
#'
#' # Add 2D plot
#' cyto_plot(gs[[4]],
#'   parent = "CD4 T Cells",
#'   alias = "",
#'   channels = c("Alexa Fluor 647-A", "7-AAD-A"),
#'   layout = FALSE
#' )
#'
#' # Add 1D plot
#' cyto_plot(gs,
#'   parent = "CD4 T Cells",
#'   alias = "",
#'   channels = "7-AAD-A",
#'   hist_stack = 0.6,
#'   layout = FALSE
#' )
#'
#' # Signal that the plot is complete
#' cyto_plot_complete()
#' @export
cyto_plot_complete <- function(...) {
  
  # CLOSE DEVICE (not RStudioGD/X11/quartz)
  if (cyto_option("cyto_plot_save")) {
    if (!names(dev.cur()) %in% c(
      "RStudioGD",
      "windows",
      "X11",
      "x11",
      "quartz",
      "cairo",
      "Cairo"
    )) {
      dev.off()
    }
  }
  
  # RESET CYTO_PLOT_METHOD
  cyto_option("cyto_plot_method", NULL)
  
  # RESET CYTO_PLOT_SAVE
  cyto_option("cyto_plot_save", FALSE)
  
  # RESET SAVED PARAMETERS
  cyto_plot_par(..., reset = TRUE)
}

## CYTO_PLOT_THEME -------------------------------------------------------------

#' Create custom themes for cyto_plot
#'
#' \code{cyto_plot_theme} provides an easy way to alter the theme used by
#' \code{cyto_plot}. By calling \code{cyto_plot_theme} prior to plotting,
#' subsequent plots will inherit these arguments so there is no need to supply
#' them manually each time. For a complete list of supported arguments see
#' \code{cyto_plot_theme_args}.
#'
#' @param ... arguments supported by cyto_plot_theme.
#' @param reset logical indicating whether \code{cyto_plot_theme()} settings
#'   should be reset to use default settings, set to FALSE by default.
#'
#' @examples
#' # Make all plots have a black background
#' cyto_plot_theme(border_fill = "black")
#'
#' # Black ground with custom colour scale for points and purple gates
#' cyto_plot_theme(
#'   border_fill = "black",
#'   point_col_scale = c(
#'     "cyan",
#'     "green",
#'     "yellow",
#'     "orange",
#'     "red",
#'     "darkred"
#'   ),
#'   gate_line_col = "magenta"
#' )
#'
#' # Reset to default setting
#' cyto_plot_theme_reset()
#' @author Dillon Hammill (Dillon.Hammill@anu.edu.au)
#'
#' @export
cyto_plot_theme <- function(...,
                            reset = FALSE) {
  
  # RESET
  if (reset) {
    # RESET THEME
    cyto_option("cyto_plot_theme", NULL)
    theme_args <- cyto_option("cyto_plot_theme")
    # SET
  } else {
    # CURRENT THEME ARGUMENTS
    theme_args <- cyto_option("cyto_plot_theme")
    # ARGUMENTS
    theme_new_args <- list(...)
    # NEW THEME ARGUMENTS
    if (length(theme_new_args) != 0) {
      # CHECK ARGUMENTS
      if (!all(names(theme_new_args) %in% cyto_plot_theme_args())) {
        lapply(names(theme_new_args), function(x) {
          if (!x %in% cyto_plot_theme_args()) {
            message(
              paste(x, "is not a supported argument for cyto_plot_theme.")
            )
          }
        })
      }
      # SUPPORTED ARGUMENTS ONLY
      theme_new_args <- theme_new_args[names(theme_new_args) %in%
                                         cyto_plot_theme_args()]
    }
    # REMOVE OLD PARAMETERS
    theme_args <- theme_args[!names(theme_args) %in% names(theme_new_args)]
    theme_args <- c(theme_args, theme_new_args)
    cyto_option("cyto_plot_theme", theme_args)
  }
  # RETURN THEME ARUMENTS
  invisible(theme_args)
}

## CYTO_PLOT_PAR ---------------------------------------------------------------

#' Extract a list of graphical parameters set by cyto_plot
#'
#' This function is designed to used within \code{cyto_plot()} to return a list
#' of graphical parameters that have been set by \code{cyto_plot()}. This is not
#' intended to be used by the user, but can be used to check if there are any
#' graphical parameters that have not been properly reset after a call to
#' \code{cyto_plot()}. If required, these graphical parameters can be reset by
#' setting \code{reset = TRUE}.
#'
#' @param ... additional graphical parameters to be set by the current
#'   \code{cyto_plot()} call (e.g. mfrow = c(1,2)).
#' @param reset logical indicating whether these svaed graphical parameters
#'   should be reset, set to FALSE by default.
#'
#' @importFrom graphics par layout
#'
#' @return invisibly return a list of set graphical parameters.
#'
#' @author Dillon Hammill (Dillon.Hammill@anu.edu.au)
#'
#' @export
cyto_plot_par <- function(...,
                          reset = FALSE) {
  
  # NEW PARAMETERS
  new_pars <- .args_list(...)
  new_pars <- new_pars[!names(new_pars) %in% "reset"]
  
  # EMPTY PARAMETERS
  if(length(new_pars) == 0){
    invisible(NULL)
  }
  
  # RESET PARAMETERS
  if (reset) {
    cyto_option("cyto_plot_par", list())
    reset_pars <- cyto_option("cyto_plot_par_reset")
    reset_pars <- c(reset_pars[!names(reset_pars) %in% names(new_pars)],
                    new_pars)
    # PREPARE LAYOUT ARGUMENT - CYTO_PLOT_COMPLETE
    if("layout" %in% names(reset_pars)) {
      layout <- reset_pars$layout
      reset_pars <- reset_pars[!names(reset_pars) %in% "layout"]
      # BYPASS NON-NUMERIC LAYOUT (FALSE)
      if(is.numeric(layout)) {
        # LAYOUT
        if(!is.null(dim(layout))) {
          layout(layout) # reset to custom layout
        } else {
          # DEFAULT TO MFROW
          if(length(layout) == 2) {
            reset_pars$mfrow <- layout
            # MFROW/MFCOL
          } else if (length(layout) == 3) {
            # MFROW
            if(layout[3] == 1) {
              reset_pars$mfrow <- layout[1:2]
              # MFCOL
            } else {
              reset_pars$mfcol <- layout[1:2]
            }
          }
        }
      }
    }
    par(reset_pars)
    cyto_option("cyto_plot_par_reset", list())
  # SET PARAMETERS
  } else {
    # PREPARE LAYOUT ARGUMENT
    if("layout" %in% names(new_pars)) {
      layout <- new_pars$layout
      new_pars <- new_pars[!names(new_pars) %in% "layout"]
      # BYPASS NON-NUMERIC LAYOUT (FALSE)
      if(is.numeric(layout)) {
        # LAYOUT
        if(!is.null(dim(layout))) {
          new_pars$layout <- layout
        } else {
          # DEFAULT TO MFROW
          if(length(layout) == 2) {
            new_pars$mfrow <- layout
          # MFROW/MFCOL
          } else if (length(layout) == 3) {
            # MFROW
            if(layout[3] == 1) {
              new_pars$mfrow <- layout[1:2]
            # MFCOL
            } else {
              new_pars$mfcol <- layout[1:2]
            }
          }
        }
      }
    }
    # UPDATE GLOABLLY SET PARAMETERS - INCLUDE LAYOUT ARGUMENT
    set_pars <- cyto_option("cyto_plot_par")
    set_pars <- c(set_pars[!names(set_pars) %in% names(new_pars)],
                  new_pars)
    cyto_option("cyto_plot_par", set_pars)
    # GET RESET VALUES FOR NEW PARAMETERS
    reset_pars <- .par(names(new_pars)[!names(new_pars) %in% "layout"])
    # RESET LAYOUT WITH MFROW
    if("layout" %in% names(new_pars)) {
      reset_pars$mfrow <- par("mfrow")
    }
    default_pars <- cyto_option("cyto_plot_par_reset")
    # ONLY ADD IF NOT STORED ALREADY
    default_pars <- c(default_pars,
                      reset_pars[!names(reset_pars) %in% names(default_pars)])
    cyto_option("cyto_plot_par_reset", default_pars)
    # SET LAYOUT PARAMETER
    if("layout" %in% names(new_pars)) {
      layout(new_pars$layout)
      new_pars <- new_pars[!names(new_pars) %in% "layout"]
    }
    # SET REMAINING PARAMETERS
    par(new_pars)
  }

  # NULL RETURN
  invisible(NULL)
}

#' @export
cyto_plot_layout <- function(...){
  .Defunct("cyto_plot_par")
}

## CYTO_PLOT_THEME_ARGS --------------------------------------------------------

#' Get supported cyto_plot_theme arguments
#'
#' @return vector of argument names supported by cyto_plot_theme.
#'
#' @examples
#' cyto_plot_theme_args()
#' @author Dillon Hammill (Dillon.Hammill@anu.edu.au)
#'
#' @export
cyto_plot_theme_args <- function() {
  c(
    "axes_limits",
    "axes_limits_buffer",
    "margins",
    "popup",
    "popup_size",
    "hist_stat",
    "hist_bins",
    "hist_smooth",
    "hist_stack",
    "hist_cols",
    "hist_fill_alpha",
    "hist_line_type",
    "hist_line_width",
    "hist_line_col",
    "axes_text",
    "axes_text_font",
    "axes_text_size",
    "axes_text_col",
    "axes_label_text_font",
    "axes_label_text_size",
    "axes_label_text_col",
    "title_text_font",
    "title_text_size",
    "title_text_col",
    "legend",
    "legend_text_font",
    "legend_text_size",
    "legend_text_col",
    "legend_line_col",
    "legend_box_fill",
    "gate_line_type",
    "gate_line_width",
    "gate_line_col",
    "gate_fill",
    "gate_fill_alpha",
    "label",
    "label_position",
    "label_text_font",
    "label_text_size",
    "label_text_col",
    "label_text_col_alpha",
    "label_fill",
    "label_fill_alpha",
    "border_fill",
    "border_fill_alpha",
    "border_line_type",
    "border_line_width",
    "border_line_col",
    "point_shape",
    "point_size",
    "point_col_scale",
    "point_col_smooth",
    "point_cols",
    "point_col_alpha",
    "point_fast",
    "contour_lines",
    "contour_line_type",
    "contour_line_width",
    "contour_line_col",
    "contour_line_alpha",
    "grid",
    "grid_line_type",
    "grid_line_width",
    "grid_line_col",
    "grid_line_alpha",
    "header_text_font",
    "header_text_size",
    "header_text_col",
    "key",
    "key_scale",
    "key_text_font",
    "key_text_size",
    "key_text_col",
    "key_text_col_alpha",
    "key_title_text_font",
    "key_title_text_size",
    "key_title_text_col",
    "key_title_text_col_alpha"
  )
}
