## CYTO_GATETEMPLATE -----------------------------------------------------------

#' Create a gateTemplate for a GatingHierarchy or GatingSet
#'
#' \code{cyto_gateTemplate()} creates on object of class \code{gateTemplate}
#' containing a template for all the gates applied to the supplied
#' GatingHierarchy or GatingSet. \code{gateTemplate(s)} can then be applied to
#' other GatingHierarchies or GatingSets using \code{cyto_gateTemplate_apply()}.
#' These functions are used internally to transfer gates when we need to create
#' a new GatingHierarchy or GatingSet containing a subset of the original data.
#' Users should not use these functions directly and instead transfer gates
#' using gatingTemplates and \code{cyto_gatingTemplate_apply()}.
#'
#' @param x an object of class
#'   \code{\link[flowWorkspace:GatingHierarchy-class]{GatingHierarchy}} or
#'   \code{\link[flowWorkspace:GatingSet-class]{GatingSet}}.
#'
#' @return a list with class \code{gateTemplate} containing all the gates
#'   applied to the GatingHierarchy or GatingSet.
#'
#' @importFrom openCyto gh_generate_template
#'
#' @author Dillon Hammill, \email{Dillon.Hammill@anu.edu.au}
#'
#' @seealso \code{\link{cyto_gateTemplate_apply}}
#' @seealso \code{\link{cyto_gatingTemplate_apply}}
#'
#' @name cyto_gateTemplate
NULL

#' @noRd
#' @export
cyto_gateTemplate <- function(x) {
  UseMethod("cyto_gateTemplate")
}

#' @rdname cyto_gateTemplate
#' @export
cyto_gateTemplate.GatingHierarchy <- function(x) {
  
  # GENERATE GATINGTEMPLATE
  gt <- gh_generate_template(x)
  
  # TRANSFER GATES
  if(nrow(gt) > 0) {
    # SPLIT GATINGTEMPLATE INTO CHUNKS - PARENT & DIMS
    gt_chunks <- split(
      gt,
      do.call(
        "paste0",
        c(gt[, c("parent", "dims")]) 
      )
    )
    # EXTRACT GATES
    ind <- c()
    gates <- lapply(
      gt_chunks,
      function(z) {
        # EXTRACT GATES - LIST OF GATE OBJECTS
        gate <- cyto_gate_extract(
          x,
          parent = z$parent[1],
          alias = z$alias,
          bool = FALSE # LEAVE BOOLEANFILTERS ALONE
        )[[1]]
        # ORDER
        ind <<- c(
          ind,
          LAPPLY(
            seq_along(
              gate
            ),
            function(v) {
              # MULTIPLE POPULATIONS PER GATE
              a <- strsplit(
                names(gate)[v],
                "\\|"
              )[[1]]
              # MINIMUM ROW INDEX FOR MULTIGATES
              min(
                which(
                  gt$alias %in% a &
                    gt$parent == z$parent[1] &
                    gt$dims == z$dims[1]
                )
              )
            }
          )
        )
        # RETURN GATE OBJECTS
        return(gate)
      }
    )
    # ORDER GATES
    gates <- structure(
      unlist(
        gates,
        recursive = FALSE
      ),
      names = LAPPLY(gates, "names")
    )[order(ind)]
    ind <- ind[order(ind)]
    
    # CREATE GATE TEMPLATE
    gateTemplate <- structure(
      lapply(
        seq_along(gates),
        function(z) {
          list(
            alias = strsplit(
              names(gates)[z],
              "\\|"
            )[[1]],
            parent = gt$parent[ind[z]],
            gate = gates[[z]],
            channels = strsplit(
              gt$dims[ind[z]],
              ","
            )[[1]]
          )
        }
      ),
      names = names(gates)
    )
    class(gateTemplate) <- "gateTemplate"
  # EMPTY GATE TEMPLATE
  } else {
    gateTemplate <- list()
    class(gateTemplate) <- "gateTemplate"
  }
  
  # RETURN UPDATED GATINGHIERARCHY
  return(gateTemplate)

}

#' @rdname cyto_gateTemplate
#' @export
cyto_gateTemplate.GatingSet <- function(x) {
  
  structure(
    lapply(
      seq_along(x),
      function(z) {
        cyto_gateTemplate(x[[z]])
      }
    ),
    names = cyto_names(x)
  )
  
}

## CYTO_GATETEMPLATE_APPLY -----------------------------------------------------

#' Apply a set of gates from another GatingHierarchy or GatingSet
#'
#' \code{cyto_gateTemplate_apply()} is designed to be used internally within
#' CytoExploreR to allow the transfer of gates from one GatingHierarchy or
#' GatingSet to another. \code{gateTemplate} must be generated by calling
#' \code{cyto_gateTemplate()} on the reference GatingHierarchy or GatingSet.
#' Users should instead use gatingTemplates and
#' \code{cyto_gatingTemplate_apply()} transfer gates between GatingHierarchies
#' or GatingSets.
#'
#' @param x an object of class
#'   \code{\link[flowWorkspace:GatingHierarchy-class]{GatingHierarchy}} or
#'   \code{\link[flowWorkspace:GatingSet-class]{GatingSet}} which will inherit
#'   the gates stored in the \code{gateTemplate}.
#' @param gateTemplate object created by calling \code{cyto_gateTemplate()} on
#'   the reference GatingHierarchy or GatingSet. Alternatively, the reference
#'   GatingHierarchy or GatingSet can be supplied and a call will be made to
#'   \code{cyto_gateTemplate()} to create the gateTemplate(s).
#'
#' @return a GatingHierarchy or GatingSet with gates from \code{gateTemplate}
#'   applied.
#'
#' @author Dillon Hammill, \email{Dillon.Hammill@anu.edu.au}
#'
#' @importFrom flowWorkspace gs_pop_add recompute
#'
#' @seealso \code{\link{cyto_gateTemplate}}
#' @seealso \code{\link{cyto_gatingTemplate_apply}}
#'
#' @export
cyto_gateTemplate_apply <- function(x,
                                    gateTemplate = NULL) {
  
  # GATETEMPLATE REQUIRED
  if(is.null(gateTemplate)) {
    stop(
      paste0(
        "Supply a 'gateTemplate` to transfer gates between GatingHierarchies ",
        "or GatingSets."
      )
    )
  }
  
  # PREPARE GATETEMPLATE(S)
  if(cyto_class(gateTemplate, "GatingSet")) {
    gateTemplate <- cyto_gateTemplate(gateTemplate)
  }
  
  # EMPTY GATETEMPLATE
  if(length(gateTemplate) == 0) {
    return(x)
  }
  
  # APPLY GATETEMPLATE - GATINGHIERARCHY
  if(cyto_class(x, "GatingHierarchy")) {
    # CHECK GATETEMPLATE
    if(!cyto_class(gateTemplate, "gateTemplate")) {
      stop(
        "'gateTemplate' must be generated by cyto_gateTemplate()!"
      )
    }
    # APPLY GATETEMPLATE
    lapply(
      gateTemplate,
      function(z) {
        gs_pop_add(
          x,
          gate = z$gate,
          parent = z$parent,
          name = z$alias,
          validityCheck = FALSE
        )
      }
    )
    suppressMessages(
      recompute(x)
    )
  # APPLY GATETEMPLATE - GATINGSET
  } else if(cyto_class(x, "GatingSet")) {
    # SINGLE GATETEMPLATE
    if(cyto_class(gateTemplate, "gateTemplate")) {
      # APPLY GATETEMPLATE
      lapply(
        gateTemplate,
        function(z) {
          gs_pop_add(
            x,
            gate = z$gate,
            parent = z$parent,
            name = z$alias,
            validityCheck = FALSE
          )
        }
      )
      suppressMessages(
        recompute(x)
      )
    # GATETEMPLATE PER GATINGHIERARCHY
    } else {
      # CHECK GATETEMPLATES - SAME SAMPLES REQUIRED
      if(!all(LAPPLY(gateTemplate, "cyto_class", "gateTemplate")) |
         !all(cyto_names(x) %in% names(gateTemplate))) {
        stop(
          paste0(
            "'gateTemplate' must be generated by cyto_gateTemplate() and ",
            "contain gates for every sample in this ", cyto_class(x), "!"
          )
        )
      }
      # RESTRICT GATETEMPLATES
      gateTemplate <- gateTemplate[cyto_names(x)]
      # APPLY GATETEMPLATES
      lapply(
        seq_along(x),
        function(z) {
          lapply(
            gateTemplate[[z]],
            function(w) {
              gs_pop_add(
                x[[z]],
                gate = w$gate,
                parent = w$parent,
                name = w$alias,
                validityCheck = FALSE
              )
            }
          )
        }
      )
      suppressMessages(
        recompute(x)
      )
    }
  # GATINGHIERARCHY/GATINGSET REQUIRED
  } else {
    stop(
      paste0(
        "cyto_gateTemplate_apply() only accepts GatingHierarchy or GatingSet ",
        "objects!"
      )
    )
  }
  
  # RETURN UPDATED GATINGHIERARCHY/GATINGSET
  return(x)
  
}