#' Plot Compensation in All Fluorescent Channels
#'
#' Plot each compensation control in all fluorescent channels to identify any
#' potential compensation issues. The unstained control is overlaid in black as
#' a reference.
#'
#' @param x object of class \code{\link[flowCore:flowFrame-class]{flowFrame}} or
#'   \code{\link[flowCore:flowSet-class]{flowSet}} or
#'   \code{\link[flowWorkspace:GatingSet-class]{GatingSet}} containing gated
#'   compensation controls and an unstained control.
#' @param ... additional method-specific arguments.
#'
#' @author Dillon Hammill (Dillon.Hammill@anu.edu.au)
#'
#' @seealso \code{\link{cyto_plot_compensation,flowFrame-method}}
#' @seealso \code{\link{cyto_plot_compensation,flowSet-method}}
#' @seealso \code{\link{cyto_plot_compensation,GatingSet-method}}
#'
#' @export
cyto_plot_compensation <- function(x, ...) {
  UseMethod("cyto_plot_compensation")
}

#' Plot Compensation in All Fluorescent Channels - flowFrame Method
#'
#' Plot each compensation control in all fluorescent channels to identify any
#' potential compensation issues. The unstained control is overlaid in black as
#' a reference.
#'
#' @param x object of class \code{\link[flowCore:flowFrame-class]{flowFrame}}
#'   containing gated compensation controls and an unstained control.
#' @param channel_match name of the fluorescent channel associated with the
#'   \code{\link[flowCore:flowFrame-class]{flowFrame}}. If not supplied users
#'   will need to select the channel from a dropdown menu.
#' @param compensate logical indicating whether the samples should be
#'   compensated prior to plotting, set to FALSE by default. If no spillover
#'   matrix is supplied to the spillover_file argument the spillover matrix will
#'   extracted from the samples.
#' @param spillover name of spillover matrix csv file including .csv file
#'   extension to apply to sample when \code{compensate} is TRUE. If no
#'   \code{spillover} is supplied the spillover matrix will be extracted
#'   directly from the \code{flowFrame} and applied to the sample when
#'   \code{compensate} is TRUE.
#' @param axes_trans object of class
#'   \code{\link[flowWorkspace]{transformerList}} generated by
#'   \code{cyto_transform} which was used to
#'   transform the fluorescent channels of the supplied flowFrame. This
#'   transform object will be used internally to ensure axes labels of the plot
#'   are appropriately transformed. The transform object will NOT be applied to
#'   the flowFrame internally and should be applied to the flowFrame prior to
#'   plotting.
#' @param layout vector of grid dimensions \code{c(#rows,#columns)} for each
#'   plot.
#' @param popup logical indicating whether plots should be constructed in a
#'   pop-up window.
#' @param title text to include above each plot, set to NA by default to remove
#'   titles.
#' @param header title to use for the plots, set to the name of the sample by
#'   default. Turn off the header by setting this argument to NA.
#' @param header_text_font font to use for header text, set to 2 by default.
#' @param header_text_size text size for header, set to 1 by default.
#' @param header_text_col colour for header text, set to "black" by default.
#' @param ... additional arguments passed to
#'   \code{\link{cyto_plot,flowFrame-method}}.
#'
#' @importFrom grDevices n2mfrow
#' @importFrom graphics par mtext
#'
#' @author Dillon Hammill (Dillon.Hammill@anu.edu.au)
#'
#' @seealso \code{\link{cyto_plot,flowFrame-method}}
#'
#' @examples
#' library(CytoRSuiteData)
#' 
#' # Don't run - bypass directory check for external files
#' options("CytoRSuite_wd_check" = FALSE)
#' 
#' # Load in compensation controls
#' gs <- GatingSet(Compensation)
#' 
#' # Gate single cells using gate_draw
#' gt <- Compensation_gatingTemplate
#' gating(gt, gs)
#' 
#' # Compensation plots
#' cyto_plot_compensation(getData(gs, "Single Cells")[[1]],
#'   channel_match = "7-AAD-A",
#'   overlay = getData(gs, "Single Cells")[[4]]
#' )
#' 
#' # Don't run - return "CytoRSuite_wd_check" to default
#' options("CytoRSuite_wd_check" = TRUE)
#' @export
cyto_plot_compensation.flowFrame <- function(x,
                                             channel_match = NULL,
                                             compensate = FALSE,
                                             spillover = NULL,
                                             axes_trans = NA,
                                             layout,
                                             popup = FALSE,
                                             title = NA,
                                             header,
                                             header_text_font = 2,
                                             header_text_size = 1,
                                             header_text_col = "black", ...) {

  # Compensation controls should be pre-transformed!
  message("cyto_plot_compensation expects a pre-transformed flowFrame.")
  
  # Set plot method
  if (is.null(getOption("CytoRSuite_cyto_plot_method"))) {
    options("CytoRSuite_cyto_plot_method" = "Comp/flowFrame")
  }

  # Graphics parameters
  pars <- par(c("mfrow","oma"))
  on.exit(par(pars))
  
  # Sample names
  nm <- cyto_names(x)

  # Extract channels
  channels <- cyto_fluor_channels(x)

  # Transformations
  if(!.all_na(axes_trans)){
    if(inherits(axes_trans, "transformList")){
      axes_trans <- NA
      message("transformerList is required to transform axes!")
    }
  }else if(.all_na(axes_trans)){
    stop("Data should be transformed and transformations supplied to axes_trans.")
  }  
  
  # Compensation
  if (compensate == TRUE) {
    
    # Data must be inverse transfomed, compensated and re-transformed
    x <- cyto_transform(x, trans = axes_trans, inverse = TRUE)
    x <- cyto_compensate(x, spillover = spillover)
    x <- cyto_transform(x, trans = axes_trans)

  }

  # Select channel associated with flowFrame
  if (is.null(channel_match)) {
    chan <- cyto_channel_select(x)
  } else {
    chan <- channel_match
  }

  # Pop-up
  if (popup == TRUE) {
    cyto_plot_new(popup)
  }

  # layout
  if (missing(layout)) {
    layout <- c(
      n2mfrow(length(channels))[2],
      n2mfrow(length(channels))[1]
    )
    par(mfrow = layout)
  } else if (!missing(layout)) {
    if (layout[1] == FALSE) {

      # Do nothing
    } else {
      par(mfrow = layout)
    }
  }
  
    # Title
  if (missing(header)) {
    header <- cyto_names(x)
  }
  
  # Title space
  if (!.all_na(header)) {
    par(oma = c(0, 0, 3, 0))
  }

  # Plots
  lapply(seq_len(length(channels)), function(y) {
    cyto_plot(x,
      channels = c(chan, channels[y]),
      axes_trans = axes_trans,
      legend = FALSE,
      title = title, ...
    )

    if (channels[y] == channels[length(channels)]) {
      if (!.all_na(header)) {
        mtext(header,
          outer = TRUE,
          cex = header_text_size,
          font = header_text_font,
          col = header_text_col
        )
      }
    }
  })

  # Turn off graphics device for saving
  if (getOption("CytoRSuite_cyto_plot_save")) {
    if (inherits(x, basename(getOption("CytoRSuite_cyto_plot_method")))) {

      # Close graphics device
      dev.off()

      # Reset CytoRSuite_cyto_plot_save
      options("CytoRSuite_cyto_plot_save" = FALSE)

      # Reset CytoRSuite_cyto_plot_method
      options("cytoRSuite_cyto_plot_method" = NULL)
    }
  }
}

#' Plot Compensation in All Fluorescent Channels - flowSet Method
#'
#' Plot each compensation control in all fluorescent channels to identify any
#' potential compensation issues. The unstained control is overlaid in black as
#' a reference.
#'
#' @param x object of class \code{\link[flowCore:flowSet-class]{flowSet}}
#'   containing gated compensation controls and an unstained control.
#' @param channel_match name of a csv file with two columns, the first
#'   called "name" lists the names of each compensation control and the second
#'   "channel" lists the fluorescent channel associated with each of the
#'   compensation controls. Use "Unstained" in the channel column for the
#'   universal unstained control. No need to construct this file manually as
#'   users will be guided through this process if the \code{channel_match}
#'   is missing.
#' @param compensate logical indicating whether the samples should be
#'   compensated prior to plotting, set to FALSE by default. If no spillover
#'   matrix is supplied to the spillover_file argument the spillover matrix will
#'   extracted from the samples.
#' @param spillover name of spillover matrix csv file including .csv file
#'   extension to apply to samples when \code{compensate} is TRUE. If no
#'   \code{spillover} is supplied the spillover matrix will be extracted
#'   directly from the \code{flowSet} and applied to the samples when
#'   \code{compensate} is TRUE.
#' @param axes_trans object of class
#'   \code{\link[flowWorkspace]{transformerList}} generated by
#'   \code{cyto_transform} which was used to
#'   transform the fluorescent channels of the supplied flowFrame. This
#'   transform object will be used internally to ensure axes labels of the plot
#'   are appropriately transformed. The transform object will NOT be applied to
#'   the flowFrame internally and should be applied to the flowFrame prior to
#'   plotting.
#' @param overlay logical indicating whether the unstained control should be
#'   overlaid onto the plot if supplied in the flowSet, set to \code{TRUE} by
#'   default.
#' @param layout vector of grid dimensions \code{c(#rows,#columns)} for each
#'   plot.
#' @param popup logical indicating whether plots should be constructed in a
#'   pop-up window.
#' @param title text to include above each plot, set to NA by default to remove
#'   titles.
#' @param header vector of titles to use for the plots, set to the name of the
#'   sample by default. Turn off the header by setting this argument to NA.
#' @param header_text_font font to use for header text, set to 2 by default.
#' @param header_text_size text size for header, set to 1 by default.
#' @param header_text_col colour for header text, set to "black" by default.
#' @param ... additional arguments passed to
#'   \code{\link{cyto_plot,flowFrame-method}}.
#'
#' @importFrom grDevices n2mfrow
#' @importFrom graphics par mtext
#'
#' @author Dillon Hammill (Dillon.Hammill@anu.edu.au)
#'
#' @examples
#' library(CytoRSuiteData)
#' 
#' # Don't run - bypass directory check for external files
#' options("CytoRSuite_wd_check" = FALSE)
#' 
#' # Load in compensation controls
#' gs <- GatingSet(Compensation)
#' 
#' # Gate single cells using gate_draw
#' gt <- Compensation_gatingTemplate
#' gating(gt, gs)
#' 
#' # Channel match file
#' cmfile <- system.file("extdata",
#'   "Compensation-Channels.csv",
#'   package = "CytoRSuiteData"
#' )
#' 
#' # Compensation plots
#' cyto_plot_compensation(getData(gs, "Single Cells"),
#'   channel_match = cmfile
#' )
#' 
#' # Don't run - return "CytoRSuite_wd_check" to default
#' options("CytoRSuite_wd_check" = TRUE)
#' @seealso \code{\link{cyto_plot,flowFrame-method}}
#'
#' @export
cyto_plot_compensation.flowSet <- function(x,
                                           channel_match = NULL,
                                           compensate = FALSE,
                                           spillover = NULL,
                                           axes_trans = NA,
                                           overlay = TRUE,
                                           layout,
                                           popup = FALSE,
                                           title = NA,
                                           header,
                                           header_text_font = 2,
                                           header_text_size = 1,
                                           header_text_col = "black", ...) {

  # Transformed data only
  message("cyto_plot_compensation expects a pre-transformed flowSet.")
  
  # Set plot method
  if (is.null(getOption("CytoRSuite_cyto_plot_method"))) {
    options("CytoRSuite_cyto_plot_method" = "Comp/flowSet")
  }

  # Graphics parameters
  pars <- par(c("mfrow","oma"))
  on.exit(par(pars))
  
  # Number of samples
  smp <- length(x)

  # Extract channels
  channels <- cyto_fluor_channels(x)

  # Transformations
  if(!.all_na(axes_trans)){
    if(inherits(axes_trans, "transformList")){
      axes_trans <- NA
      message("transformerList is required to transform axes!")
    }
  }else if(.all_na(axes_trans)){
    stop("Data should be transformed and transformations supplied to axes_trans.")
  }  
  
  # Compensation
  if (compensate == TRUE) {
    # Data must be inverse transformed, compensated and re-transformed
    x <- cyto_transform(x, trans = axes_trans, inverse = TRUE)
    x <- cyto_compensate(x, spillover = spillover)
    x <- cyto_transform(x, trans = axes_trans)
  }

  # Extract pData information
  pd <- cyto_details(x)

  # Channel match file
  if (is.null(channel_match)) {

    # No channel_match file supplied
    message("Select a channel for each sample from the dropdown menu.")
    pd$channel <- paste(cyto_channel_select(x))

    # Save new channel_match csv file
    message("Saving channel selections to 'Compensation-Channels.csv'.")
    write.csv(pd, "Compensation-Channels.csv", row.names = FALSE)
  } else if (!is.null(channel_match)) {
    if (getOption("CytoRSuite_wd_check") == TRUE) {
      if (file_wd_check(channel_match) == FALSE) {
        message(paste(channel_match, "is not in this working directory."))
        pd$channel <- paste(cyto_channel_select(x))
      } else {
        cm <- read.csv(channel_match, header = TRUE, row.names = 1)
        chans <- cm$channel[match(cyto_names(x), row.names(cm))]
        pd$channel <- paste(chans)
      }
    } else {
      cm <- read.csv(channel_match, header = TRUE, row.names = 1)
      chans <- cm$channel[match(cyto_names(x), row.names(cm))]
      pd$channel <- paste(chans)
    }
  }

  # Pull out unstained control if supplied
  if ("Unstained" %in% pd$channel) {
    unst <- TRUE
    NIL <- x[[match("Unstained", pd$channel)]]
    x <- x[-match("Unstained", pd$channel)]
    smp <- smp - 1
  } else {
    unst <- FALSE
  }

  # Sample names
  nms <- cyto_names(x)

  # Restrict pd to x
  pd <- pd[!pd$channel == "Unstained", ]

  # Convert x into list of flowFrames
  fs_list <- lapply(seq(1, smp, 1), function(z) x[[z]])

  # Pop-up
  if (popup == TRUE) {
    cyto_plot_new(popup)
  }

  # layout
  if (missing(layout)) {
    layout <- c(
      n2mfrow(length(channels))[2],
      n2mfrow(length(channels))[1]
    )
    par(mfrow = layout)
  } else if (!missing(layout)) {
    if (layout[1] == FALSE) {

      # Do nothing
    } else {
      par(mfrow = layout)
    }
  }

    # Title
  if (missing(header)) {
    header <- pd$name
  }
  
  # Title space
  if (!.all_na(header)) {
    par(oma = c(0, 0, 3, 0))
  }
  
  # Loop through fs_list
  lapply(1:smp, function(z) {
    lapply(seq_len(length(channels)), function(y) {
      if (unst == TRUE & overlay == TRUE) {
        cyto_plot(fs_list[[z]],
          channels = c(pd$channel[z], channels[y]),
          overlay = NIL,
          axes_trans = axes_trans,
          legend = FALSE,
          title = title, ...
        )
      } else {
        cyto_plot(fs_list[[z]],
          channels = c(pd$channel[z], channels[y]),
          axes_trans = axes_trans,
          legend = FALSE,
          title = title, ...
        )
      }

      # Call new plot
      if (z != smp & channels[y] == channels[length(channels)]) {
        if (!.all_na(header)) {
          mtext(header[z],
            outer = TRUE,
            cex = header_text_size,
            font = header_text_font,
            col = header_text_col
          )
        }

        if (popup == TRUE) {
          cyto_plot_new(popup)
          par(mfrow = layout)
          par(oma = c(0, 0, 3, 0))
        } else {
          plot.new()
          par(mfrow = layout)
          par(oma = c(0, 0, 3, 0))
        }
      } else if (z == smp & channels[y] == channels[length(channels)]) {
        if (!.all_na(header)) {
          mtext(header[z],
            outer = TRUE,
            cex = header_text_size,
            font = header_text_font,
            col = header_text_col
          )
        }
      }
    })
  })

  # Turn off graphics device for saving
  if (getOption("CytoRSuite_cyto_plot_save")) {
    if (inherits(x, basename(getOption("CytoRSuite_cyto_plot_method")))) {

      # Close graphics device
      dev.off()

      # Reset CytoRSuite_cyto_plot_save
      options("CytoRSuite_cyto_plot_save" = FALSE)

      # Reset CytoRSuite_cyto_plot_method
      options("cytoRSuite_cyto_plot_method" = NULL)
    }
  }
}

#' Plot Compensation in All Fluorescent Channels - GatingSet Method
#'
#' Plot each compensation control in all fluorescent channels to identify any
#' potential compensation issues. The unstained control is overlaid in black as
#' a reference.
#'
#' @param x object of class
#'   \code{\link[flowWorkspace:GatingSet-class]{GatingSet}} containing gated
#'   compensation controls and an unstained control.
#' @param parent name of the population to plot.
#' @param channel_match name of a csv file with two columns, the first called
#'   "name" lists the names of each compensation control and the second
#'   "channel" lists the fluorescent channel associated with each of the
#'   compensation controls. Use "Unstained" in the channel column for the
#'   universal unstained control. No need to construct this file manually as
#'   users will be guided through this process if the \code{channel_match} is
#'   missing.
#' @param compensate logical indicating whether the samples should be
#'   compensated prior to plotting, set to FALSE by default. If no spillover
#'   matrix is supplied to the spillover_file argument the spillover matrix will
#'   extracted from the samples.
#' @param spillover name of spillover matrix csv file including .csv file
#'   extension to apply to samples when \code{compensate} is TRUE. If no
#'   \code{spillover} is supplied the spillover matrix will be extracted
#'   directly from the \code{GatingSet} and applied to the samples when
#'   \code{compensate} is TRUE.
#' @param axes_trans object of class
#'   \code{\link[flowWorkspace]{transformerList}} generated by
#'   \code{cyto_transform} which was used to
#'   transform the fluorescent channels of the supplied flowFrame. This
#'   transform object will be used internally to ensure axes labels of the plot
#'   are appropriately transformed. The transform object will NOT be applied to
#'   the flowFrame internally and should be applied to the flowFrame prior to
#'   plotting.
#' @param layout vector of grid dimensions \code{c(#rows,#columns)} for each
#'   plot.
#' @param overlay logical indicating whether the unstained control should be
#'   overlaid onto the plot if supplied in the flowSet, set to \code{TRUE} by
#'   default.
#' @param popup logical indicating whether plots should be constructed in a
#'   pop-up window.
#' @param title text to include above each plot, set to NA by default to remove
#'   titles.
#' @param header vector of titles to use for the plots, set to the name of the
#'   sample by default. Turn off the header by setting this argument to NA.
#' @param header_text_font font to use for header text, set to 2 by default.
#' @param header_text_size text size for header, set to 1 by default.
#' @param header_text_col colour for header text, set to "black" by default.
#' @param ... additional arguments passed to
#'   \code{\link{cyto_plot,flowFrame-method}}.
#'
#' @importFrom graphics par
#'
#' @author Dillon Hammill (Dillon.Hammill@anu.edu.au)
#'
#' @examples
#' library(CytoRSuiteData)
#' 
#' # Don't run - bypass directory check for external files
#' options("CytoRSuite_wd_check" = FALSE)
#' 
#' # Load in compensation controls
#' gs <- GatingSet(Compensation)
#' 
#' # Gate single cells using gate_draw
#' gt <- Compensation_gatingTemplate
#' gating(gt, gs)
#' 
#' # Channel match file
#' cmfile <- system.file("extdata",
#'   "Compensation-Channels.csv",
#'   package = "CytoRSuiteData"
#' )
#' 
#' # Compensation plots
#' cyto_plot_compensation(gs,
#'   parent = "Single Cells",
#'   channel_match = cmfile
#' )
#' 
#' # Don't run - return "CytoRSuite_wd_check" to default
#' options("CytoRSuite_wd_check" = TRUE)
#' @seealso \code{\link{cyto_plot,flowFrame-method}}
#'
#' @export
cyto_plot_compensation.GatingSet <- function(x,
                                             parent = NULL,
                                             channel_match = NULL,
                                             compensate = FALSE,
                                             spillover = NULL,
                                             axes_trans = NA,
                                             overlay = TRUE,
                                             layout,
                                             popup = FALSE,
                                             title = NA,
                                             header,
                                             header_text_font = 2,
                                             header_text_size = 1,
                                             header_text_col = "black", ...) {

  # Transformed data only
  message("cyto_plot_compensation expects a pre-transformed GatingSet.")
  
  # Set plot method
  if (is.null(getOption("CytoRSuite_cyto_plot_method"))) {
    options("CytoRSuite_cyto_plot_method" = "Comp/GatingSet")
  }

  # Graphics parameters
  pars <- par(c("mfrow","oma"))
  on.exit(par(pars))
  
  # Parent
  if (is.null(parent)) {
    parent <- cyto_nodes(x, path = "auto")[length(cyto_nodes(x))]
    message(paste(
      "No parent supplied -",
      parent,
      "population will be used for plots."
    ))
  }

  # Extract channels
  channels <- cyto_fluor_channels(x)

  # Extract parent
  fs <- cyto_extract(x, parent)

  # Transformations
  if(!.all_na(axes_trans)){
    if(inherits(axes_trans, "transformList")){
      axes_trans <- NA
      message("transformerList is required to transform axes!")
    }
  }else if(.all_na(axes_trans)){
    axes_trans <- x[[1]]@transformation
    if(is.null(axes_trans)){
      stop("Data should be transformed prior to plotting.")
    }
  } 
  
  # Compensation
  if (compensate == TRUE) {
    # Data must be inverse transformed, compensated and re-transformed
    fs <- cyto_transform(fs, trans = axes_trans, inverse = TRUE)
    fs <- cyto_compensate(fs, spillover = spillover)
    fs <- cyto_transform(fs, trans = axes_trans)
  }
  
  # Make call to cyto_plot_compensation
  cyto_plot_compensation(
    x = fs,
    axes_trans = axes_trans,
    channel_match = channel_match,
    overlay = overlay,
    popup = popup,
    title = title,
    header = header,
    header_text_font = header_text_font,
    header_text_size = header_text_size,
    header_text_col = header_text_col, ...
  )

  # Turn off graphics device for saving
  if (getOption("CytoRSuite_cyto_plot_save")) {
    if (inherits(x, basename(getOption("CytoRSuite_cyto_plot_method")))) {

      # Close graphics device
      dev.off()

      # Reset CytoRSuite_cyto_plot_save
      options("CytoRSuite_cyto_plot_save" = FALSE)

      # Reset CytoRSuite_cyto_plot_method
      options("cytoRSuite_cyto_plot_method" = NULL)
    }
  }
}
