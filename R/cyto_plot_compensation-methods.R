# CYTO_PLOT_COMPENSATION -------------------------------------------------------

#' Visualise Compensation of Fluorescent Spillover in All Fluorescent Channels
#'
#' \code{cyto_plot_compensation} plots each compensation control in all
#' fluorescent channels to make it easy to identify any potential compensation
#' issues. The unstained control is automatically overlaid onto the plot as a
#' refernce if supplied.
#'
#' @param x object of class \code{\link[flowCore:flowFrame-class]{flowFrame}} or
#'   \code{\link[flowCore:flowSet-class]{flowSet}},
#'   \code{\link[flowWorkspace:GatingHierarchy-class]{GatingHierarchy}} or
#'   \code{\link[flowWorkspace:GatingSet-class]{GatingSet}} containing gated
#'   compensation controls and an unstained control.
#' @param parent indicates the name of the population to plot for GatingSet
#'   objects..
#' @param channel_match name of the fluorescent channel associated with the
#'   \code{\link[flowCore:flowFrame-class]{flowFrame}}. A \code{channel_match}
#'   csv file may also be supplied. If not supplied users will need to select
#'   the channel from a dropdown menu.
#' @param compensate logical indicating whether the samples should be
#'   compensated prior to plotting, set to FALSE by default. If no spillover
#'   matrix is supplied to the spillover_file argument the spillover matrix will
#'   extracted from the samples.
#' @param spillover name of spillover matrix csv file including .csv file
#'   extension to apply to sample when \code{compensate} is TRUE. If no
#'   \code{spillover} is supplied the spillover matrix will be extracted
#'   directly from the \code{flowFrame} and applied to the sample when
#'   \code{compensate} is TRUE.
#' @param axes_trans object of class
#'   \code{\link[flowWorkspace:transformerList-class]{transformerList}}
#'   generated by a \code{cyto_transformer} which contains the transformer
#'   definitions to be used internally to transform the fluorescent channels of
#'   the samples.
#' @param overlay logical indicating whether the unstained control should be
#'   overlaid onto the plot if supplied in the flowSet or GatingSet, set to
#'   \code{TRUE} by default.
#' @param layout vector of grid dimensions \code{c(#rows,#columns)} for each
#'   plot.
#' @param popup logical indicating whether plots should be constructed in a
#'   pop-up window.
#' @param title text to include above each plot, set to NA by default to remove
#'   titles.
#' @param header title to use for the plots, set to the name of the sample by
#'   default. Turn off the header by setting this argument to NA.
#' @param header_text_font font to use for header text, set to 2 by default.
#' @param header_text_size text size for header, set to 1 by default.
#' @param header_text_col colour for header text, set to "black" by default.
#' @param ... additional arguments passed to \code{\link{cyto_plot}}.
#'
#' @importFrom grDevices n2mfrow
#' @importFrom graphics par mtext
#' @importFrom tools file_ext
#'
#' @author Dillon Hammill (Dillon.Hammill@anu.edu.au)
#'
#' @examples
#' library(CytoRSuiteData)
#'
#' # Don't run - bypass directory check for external files
#' options("CytoRSuite_wd_check" = FALSE)
#'
#' # Load in compensation controls
#' gs <- GatingSet(Compensation)
#'
#' # Gate single cells using cyto_gate_draw
#' gt <- Compensation_gatingTemplate
#' gating(gt, gs)
#'
#' # Extract flowSet for plotting
#' fs <- cyto_extract(gs, "Single Cells")
#'
#' # Channel match file
#' cmfile <- system.file("extdata",
#'   "Compensation-Channels.csv",
#'   package = "CytoRSuiteData"
#' )
#'
#' # Compensation plots - flowFrame
#' cyto_plot_compensation(fs[[1]],
#'   channel_match = cmfile,
#'   overlay = fs[[7]]
#' )
#'
#' # Compensation plots - flowSet
#' cyto_plot_compensation(fs,
#'   channel_match = "7-AAD-A",
#'   overlay = fs[[7]]
#' )
#'
#' # Compensation plots - GatingHierarchy
#' cyto_plot_compensation(gs[[1]],
#'   parent = "Single Cells",
#'   channel_match = "7-AAD-A",
#'   overlay = fs[[7]]
#' )
#'
#' # Compensation plots - GatingSet
#' cyto_plot_compensation(gs,
#'   parent = "Single Cells",
#'   channel_match = cmfile
#' )
#'
#' # Don't run - return "CytoRSuite_wd_check" to default
#' options("CytoRSuite_wd_check" = TRUE)
#'
#' @seealso \code{\link{cyto_spillover_compute}}
#' @seealso \code{\link{cyto_spillover_edit}}
#' @seealso \code{\link{cyto_spillover_spread}}
#' @seealso \code{\link{cyto_plot}}
#'
#' @name cyto_plot_compensation
NULL

#' @noRd
#' @export
cyto_plot_compensation <- function(x, ...) {
  UseMethod("cyto_plot_compensation")
}

#' @rdname cyto_plot_compensation
#' @export
cyto_plot_compensation.GatingSet <- function(x,
                                             parent = NULL,
                                             channel_match = NULL,
                                             compensate = FALSE,
                                             spillover = NULL,
                                             axes_trans = NA,
                                             overlay = TRUE,
                                             layout,
                                             popup = FALSE,
                                             title = NA,
                                             header,
                                             header_text_font = 2,
                                             header_text_size = 1,
                                             header_text_col = "black", ...) {

  # Set plot method
  if (is.null(getOption("CytoRSuite_cyto_plot_method"))) {
    options("CytoRSuite_cyto_plot_method" = "Comp/GatingSet")
  }

  # Graphics parameters
  pars <- par(c("mfrow","oma"))
  on.exit(par(pars))
  
  # Parent
  if (is.null(parent)) {
    parent <- cyto_nodes(x, path = "auto")[length(cyto_nodes(x))]
    message(paste(
      "No parent supplied -",
      parent,
      "population will be used for plots."
    ))
  }

  # Extract channels
  channels <- cyto_fluor_channels(x)

  # Extract parent
  fs <- cyto_extract(x, parent)

  # Get complete transformerList
  axes_trans <- .cyto_transformer_complete(x, axes_trans)
  
  # Reverse any transformations in fluorescent channels
  if(any(channels %in% names(x[[1]]@transformation))){
    fs <- cyto_transform(fs,
                         axes_trans[names(axes_trans) %in% channels],
                         inverse = TRUE,
                         plot = FALSE)
  }

  # Compensation
  if (compensate == TRUE) {
    # Data must be LINEAR, compensated and re-transformed
    fs <- cyto_compensate(fs, 
                          spillover = spillover)
    # Apply transformations
    fs <- cyto_transform(fs, 
                         axes_trans, 
                         plot = FALSE)
  }else{
    # Apply transformations
    fs <- cyto_transform(fs,
                         axes_trans,
                         plot = FALSE)
  }
  
  # Make call to cyto_plot_compensation
  cyto_plot_compensation(
    x = fs,
    axes_trans = axes_trans,
    channel_match = channel_match,
    overlay = overlay,
    popup = popup,
    title = title,
    header = header,
    header_text_font = header_text_font,
    header_text_size = header_text_size,
    header_text_col = header_text_col, ...
  )

  # Turn off graphics device for saving
  if (getOption("CytoRSuite_cyto_plot_save")) {
    if (inherits(x, basename(getOption("CytoRSuite_cyto_plot_method")))) {

      # Close graphics device
      dev.off()

      # Reset CytoRSuite_cyto_plot_save
      options("CytoRSuite_cyto_plot_save" = FALSE)

      # Reset CytoRSuite_cyto_plot_method
      options("cytoRSuite_cyto_plot_method" = NULL)
    }
  }
}


#' @rdname cyto_plot_compensation
#' @export
cyto_plot_compensation.GatingHierarchy <- function(x,
                                                   parent = NULL,
                                                   channel_match = NULL,
                                                   compensate = FALSE,
                                                   spillover = NULL,
                                                   axes_trans = NA,
                                                   overlay = TRUE,
                                                   layout,
                                                   popup = FALSE,
                                                   title = NA,
                                                   header,
                                                   header_text_font = 2,
                                                   header_text_size = 1,
                                                   header_text_col = "black", ...) {
  
  # Set plot method
  if (is.null(getOption("CytoRSuite_cyto_plot_method"))) {
    options("CytoRSuite_cyto_plot_method" = "Comp/GatingHierarchy")
  }
  
  # Graphics parameters
  pars <- par(c("mfrow","oma"))
  on.exit(par(pars))
  
  # Parent
  if (is.null(parent)) {
    parent <- cyto_nodes(x, path = "auto")[length(cyto_nodes(x))]
    message(paste(
      "No parent supplied -",
      parent,
      "population will be used for plots."
    ))
  }
  
  # Extract channels
  channels <- cyto_fluor_channels(x)
  
  # Extract parent
  fr <- cyto_extract(x, parent)
  
  # Get complete transformerList
  axes_trans <- .cyto_transformer_complete(x, axes_trans)
  
  # Reverse any transformations in fluorescent channels
  if(any(channels %in% names(x@transformation))){
    fr <- cyto_transform(fr,
                         axes_trans[names(axes_trans) %in% channels],
                         inverse = TRUE,
                         plot = FALSE)
  }
  
  # Compensation
  if (compensate == TRUE) {
    # Data must be LINEAR, compensated and re-transformed
    fr <- cyto_compensate(fr, 
                          spillover = spillover)
    # Apply transformations
    fr <- cyto_transform(fr, 
                         axes_trans, 
                         plot = FALSE)
  }else{
    # Apply transformations
    fr <- cyto_transform(fr,
                         axes_trans,
                         plot = FALSE)
  }
  
  # Make call to cyto_plot_compensation
  cyto_plot_compensation(
    x = fr,
    axes_trans = axes_trans,
    channel_match = channel_match,
    overlay = overlay,
    popup = popup,
    title = title,
    header = header,
    header_text_font = header_text_font,
    header_text_size = header_text_size,
    header_text_col = header_text_col, ...
  )
  
  # Turn off graphics device for saving
  if (getOption("CytoRSuite_cyto_plot_save")) {
    if (inherits(x, basename(getOption("CytoRSuite_cyto_plot_method")))) {
      
      # Close graphics device
      dev.off()
      
      # Reset CytoRSuite_cyto_plot_save
      options("CytoRSuite_cyto_plot_save" = FALSE)
      
      # Reset CytoRSuite_cyto_plot_method
      options("cytoRSuite_cyto_plot_method" = NULL)
    }
  }
}

#' @rdname cyto_plot_compensation
#' @export
cyto_plot_compensation.flowSet <- function(x,
                                           channel_match = NULL,
                                           compensate = FALSE,
                                           spillover = NULL,
                                           axes_trans = NA,
                                           overlay = TRUE,
                                           layout,
                                           popup = FALSE,
                                           title = NA,
                                           header,
                                           header_text_font = 2,
                                           header_text_size = 1,
                                           header_text_col = "black", ...) {

  # Set plot method
  if (is.null(getOption("CytoRSuite_cyto_plot_method"))) {
    options("CytoRSuite_cyto_plot_method" = "Comp/flowSet")
  }

  # Graphics parameters
  pars <- par(c("mfrow","oma"))
  on.exit(par(pars))
  
  # Number of samples
  smp <- length(x)

  # Extract channels
  channels <- cyto_fluor_channels(x)

  # Get complete transformerList
  axes_trans <- .cyto_transformer_complete(x, axes_trans)
  
  # Compensation
  if (compensate == TRUE) {
    # Data must be LINEAR, compensated and re-transformed
    x <- cyto_compensate(x,
                         spillover = spillover)
    # Apply transformations
    x <- cyto_transform(x, 
                        trans = axes_trans,
                        plot = FALSE)
  }else{
    # Apply transformations - data msut be LINEAR
    fs <- cyto_transform(fs,
                         axes_trans,
                         plot = FALSE)
  }

  # Extract pData information
  pd <- cyto_details(x)

  # Channel match file
  if (is.null(channel_match)) {

    # No channel_match file supplied
    message("Select a channel for each sample from the dropdown menu.")
    pd$channel <- paste(cyto_channel_select(x))

    # Save new channel_match csv file
    message("Saving channel selections to 'Compensation-Channels.csv'.")
    write.csv(pd, "Compensation-Channels.csv", row.names = FALSE)
  } else if (!is.null(channel_match)) {
    if (getOption("CytoRSuite_wd_check") == TRUE) {
      if (file_wd_check(channel_match) == FALSE) {
        message(paste(channel_match, "is not in this working directory."))
        pd$channel <- paste(cyto_channel_select(x))
      } else {
        cm <- read.csv(channel_match, header = TRUE, row.names = 1)
        chans <- cm$channel[match(cyto_names(x), row.names(cm))]
        pd$channel <- paste(chans)
      }
    } else {
      cm <- read.csv(channel_match, header = TRUE, row.names = 1)
      chans <- cm$channel[match(cyto_names(x), row.names(cm))]
      pd$channel <- paste(chans)
    }
  }

  # Pull out unstained control if supplied
  if ("Unstained" %in% pd$channel) {
    unst <- TRUE
    NIL <- x[[match("Unstained", pd$channel)]]
    x <- x[-match("Unstained", pd$channel)]
    smp <- smp - 1
  } else {
    unst <- FALSE
  }

  # Sample names
  nms <- cyto_names(x)

  # Restrict pd to x
  pd <- pd[!pd$channel == "Unstained", ]

  # Convert x into list of flowFrames
  fs_list <- lapply(seq(1, smp, 1), function(z) x[[z]])

  # Pop-up
  if (popup == TRUE) {
    cyto_plot_new(popup)
  }

  # layout
  if (missing(layout)) {
    layout <- c(
      n2mfrow(length(channels))[2],
      n2mfrow(length(channels))[1]
    )
    par(mfrow = layout)
  } else if (!missing(layout)) {
    if (layout[1] == FALSE) {

      # Do nothing
    } else {
      par(mfrow = layout)
    }
  }

    # Title
  if (missing(header)) {
    header <- pd$name
  }
  
  # Title space
  if (!.all_na(header)) {
    par(oma = c(0, 0, 3, 0))
  }
  
  # Loop through fs_list
  lapply(1:smp, function(z) {
    lapply(seq_len(length(channels)), function(y) {
      if (unst == TRUE & overlay == TRUE) {
        cyto_plot(fs_list[[z]],
          channels = c(pd$channel[z], channels[y]),
          overlay = NIL,
          axes_trans = axes_trans,
          legend = FALSE,
          title = title, ...
        )
      } else {
        cyto_plot(fs_list[[z]],
          channels = c(pd$channel[z], channels[y]),
          axes_trans = axes_trans,
          legend = FALSE,
          title = title, ...
        )
      }

      # Call new plot
      if (z != smp & channels[y] == channels[length(channels)]) {
        if (!.all_na(header)) {
          mtext(header[z],
            outer = TRUE,
            cex = header_text_size,
            font = header_text_font,
            col = header_text_col
          )
        }

        if (popup == TRUE) {
          cyto_plot_new(popup)
          par(mfrow = layout)
          par(oma = c(0, 0, 3, 0))
        } else {
          plot.new()
          par(mfrow = layout)
          par(oma = c(0, 0, 3, 0))
        }
      } else if (z == smp & channels[y] == channels[length(channels)]) {
        if (!.all_na(header)) {
          mtext(header[z],
            outer = TRUE,
            cex = header_text_size,
            font = header_text_font,
            col = header_text_col
          )
        }
      }
    })
  })

  # Turn off graphics device for saving
  if (getOption("CytoRSuite_cyto_plot_save")) {
    if (inherits(x, basename(getOption("CytoRSuite_cyto_plot_method")))) {

      # Close graphics device
      dev.off()

      # Reset CytoRSuite_cyto_plot_save
      options("CytoRSuite_cyto_plot_save" = FALSE)

      # Reset CytoRSuite_cyto_plot_method
      options("cytoRSuite_cyto_plot_method" = NULL)
    }
  }
}

#' @rdname cyto_plot_compensation
#' @export
cyto_plot_compensation.flowFrame <- function(x,
                                             channel_match = NULL,
                                             compensate = FALSE,
                                             spillover = NULL,
                                             axes_trans = NA,
                                             layout,
                                             popup = FALSE,
                                             title = NA,
                                             header,
                                             header_text_font = 2,
                                             header_text_size = 1,
                                             header_text_col = "black", ...) {
  
  # Set plot method
  if (is.null(getOption("CytoRSuite_cyto_plot_method"))) {
    options("CytoRSuite_cyto_plot_method" = "Comp/flowFrame")
  }

  # Graphics parameters
  pars <- par(c("mfrow","oma"))
  on.exit(par(pars))
  
  # Sample names
  nm <- cyto_names(x)

  # Extract channels
  channels <- cyto_fluor_channels(x)

  # Get complete transformerList
  axes_trans <- .cyto_transformer_complete(x, axes_trans)
  
  # Compensation
  if (compensate == TRUE) {
    
    # Data must be LINEAR, compensated and re-transformed
    x <- cyto_compensate(x, 
                         spillover = spillover)
    # Apply transformations
    x <- cyto_transform(x, 
                        axes_trans, 
                        plot = FALSE)

  }else{
    # Apply transformations
    x <- cyto_transform(x,
                        axes_trans,
                        plot = FALSE)
  }

  # Select channel associated with flowFrame
  if(is.null(channel_match)){
    chan <- cyto_channel_select(x)
  # channel_match is the name of the channel
  }else if(grepl(channel_match, channels)){
    chan <- channel_match
  # channel_match is the name of a csv file
  }else{
    # File extension missing
    if(file_ext(channel_match) != "csv"){
      channel_match <- paste0(channel_match,".csv")
    }
    # Working directory checks
    if(getOption("CytoRSuite_wd_check") == TRUE){
      # File not in working directory
      if (file_wd_check(channel_match) == FALSE) {
        message(paste(channel_match, "is not in this working directory."))
        chan <- cyto_channel_select(x)
      } else {
        cm <- read.csv(channel_match, header = TRUE, row.names = 1)
        chan <- cm$channel[match(cyto_names(x), row.names(cm))]
      }
    # Bypass working directory checks  
    }else if(getOption("CytoRSuite_wd_check") == FALSE){
      # Read in file
      cm <- read.csv(channel_match, header = TRUE, row.names = 1)
      chan <- cm$channel[match(cyto_names(x), row.names(cm))]
    }
  }

  # Pop-up
  if (popup == TRUE) {
    cyto_plot_new(popup)
  }

  # layout
  if (missing(layout)) {
    layout <- c(
      n2mfrow(length(channels))[2],
      n2mfrow(length(channels))[1]
    )
    par(mfrow = layout)
  } else if (!missing(layout)) {
    if (layout[1] == FALSE) {

      # Do nothing
    } else {
      par(mfrow = layout)
    }
  }
  
    # Title
  if (missing(header)) {
    header <- cyto_names(x)
  }
  
  # Title space
  if (!.all_na(header)) {
    par(oma = c(0, 0, 3, 0))
  }

  # Plots
  lapply(seq_len(length(channels)), function(y) {
    cyto_plot(x,
      channels = c(chan, channels[y]),
      axes_trans = axes_trans,
      legend = FALSE,
      title = title, ...
    )

    if (channels[y] == channels[length(channels)]) {
      if (!.all_na(header)) {
        mtext(header,
          outer = TRUE,
          cex = header_text_size,
          font = header_text_font,
          col = header_text_col
        )
      }
    }
  })

  # Turn off graphics device for saving
  if (getOption("CytoRSuite_cyto_plot_save")) {
    if (inherits(x, basename(getOption("CytoRSuite_cyto_plot_method")))) {

      # Close graphics device
      dev.off()

      # Reset CytoRSuite_cyto_plot_save
      options("CytoRSuite_cyto_plot_save" = FALSE)

      # Reset CytoRSuite_cyto_plot_method
      options("cytoRSuite_cyto_plot_method" = NULL)
    }
  }
}
