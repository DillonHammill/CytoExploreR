# AXES TEXT --------------------------------------------------------------------

#' Get Appropriate Axes Labels for Transformed Channels - flowWorkspace
#'
#' @param x object of class \code{flowFrame} or \code{GatingHierarchy}.
#' @param ... additional arguments.
#'
#' @return list containing axis labels and breaks.
#'
#' @noRd
.cyto_plot_axes_text <- function(x, ...) {
  UseMethod(".cyto_plot_axes_text")
}

#' Get Appropriate Axes Labels for Transformed Channels - flowFrame Method
#'
#' @param x an object of class \code{flowFrame}.
#' @param channels name(s) of the channel(s) used to construct the plot.
#' @param axes_trans object of class \code{"transformerList"} generated by
#'   \code{cyto_transform_} containing the transformations applied to the
#'   flowFrame.
#' @param axes_range named list of axes limits for each each axis (i.e.
#'   list(xlim,ylim)).
#'
#' @return list containing axis labels and breaks.
#'
#' @noRd
.cyto_plot_axes_text.flowFrame <- function(x,
                                           channels,
                                           axes_trans = NA,
                                           axes_range = list(NA,NA)) {

  # Return NA if axes_trans is missing
  if (.all_na(axes_trans)) {
    return(NA)
  } else {
    # axes_trans of incorrect class
    if (!inherits(axes_trans, "transformerList")) {
      stop("Supply a valid transformerList object to 'axes_trans'.")
    }
  }

  # Assign x to fr
  fr <- x

  # TICKS - 10^-5 -> 10^5
  tcks <- c(-seq(200000, 100000, -100000),
            -seq(90000, 10000, -10000),
            -seq(9000, 1000, -1000),
            -seq(900, 100, -100),
            -seq(90, 10, -10),
            seq(0, 90, 10),
            seq(100, 900, 100),
            seq(1000, 9000, 1000),
            seq(10000, 90000, 10000),
            seq(100000, 200000, 100000))
  
  # LABELS - 10^-5 -> 10^5
  lbls <- .cyto_plot_axes_labels(tcks)
  
  # PER CHANNEL
  axs <- lapply(channels, function(chan){
    # LINEAR CHANNEL - NA
    if(!chan %in% names(axes_trans)){
      return(NA)
    }
    # TRANSFORMED CHANNEL - TRANSFORMATIONS
    trans_func <- axes_trans[[chan]]$transform
    inv_func <- axes_trans[[chan]]$inverse
    # AXIS RANGE - LINEAR SCALE
    if(!.all_na(axes_range[[chan]])){
      rng <- inv_func(axes_range[[chan]])
    }else{
      rng <- inv_func(as.vector(range(fr)[,chan]))
    }
    # RESTRICT tcks & lbls by rng
    tks <- tcks[tcks > rng[1] & tcks < rng[2]]
    lbs <- lbls[tcks %in% tks]
    # BREAKS - TRANSFORMED SCALE
    brks <- signif(trans_func(tks))
    # BREAKS & LABELS
    return(list("label" = lbs, "at" = brks))
  })
  names(axs) <- channels

  return(axs)
}

#' Convert Ticks to Labels - Expressions
#'@noRd
.cyto_plot_axes_labels <- function(x){
  res <- lapply(x, function(z){
    if(z != 0){
      pwr <- log10(abs(z))
      if(z < 0){
        pwr <- -pwr
      }
    }
    if(z == 0){
      quote(0)
    }else if(abs(pwr)%%1 == 0){
      substitute(10^pwr)
    }else{
      quote("")
    }
  })
  do.call("expression", res)
}

# GATES ------------------------------------------------------------------------

#' Get number of gates supplied to cyto_plot
#' @param x gate object, filters object or list object.
#' @return number of gate objects in x.
#' @noRd
.cyto_plot_gate_count <- function(x) {

  # Supported gate objects
  typs <- c("rectangleGate",
            "polygonGate", 
            "ellipsoidGate", 
            "quadGate",
            "filters")

  # No gates
  if (is.null(x)) {
    gate_count <- 0
  } else if (class(x) %in% c("rectangleGate",
                             "polygonGate",
                             "ellipsoidGate")) {
    gate_count <- length(x)
  } else if(class(x) %in% "filters"){
    x <- unlist(x)
    gate_count <- 0
    lapply(x, function(z){
      if(class(z) %in% c("rectangleGate",
                         "polygonGate",
                         "ellipsoidGate")){
        gate_count <<- gate_count + 1
      }else if(class(z) == "quadGate"){
        gate_count <<- gate_count + 4
      }
    })
  }else if(class(x) == "quadGate"){
    gate_count <- 4
  } else if (class(x) == "list") {
    # LIST OF GATE OBJECTS
    if(all(LAPPLY(x, "class") %in% c("rectangleGate",
                                     "polygonGate",
                                     "ellipsoidGate",
                                     "filters"))){
      gate_count <- 0
      lapply(x, function(z){
        if(class(z) %in% c("rectangleGate",
                           "polygonGate",
                           "ellipsoidGate")){
          gate_count <<- gate_count + length(z)
        }else if(class(z) == "quadGate"){
          gate_count <<- gate_count + 4
        }else if(class(z) == "filters"){
          z <- unlist(z)
          gate_count_list <- 0
          lapply(z, function(y){
            if(class(y) %in% c("rectangleGate",
                               "polygonGate",
                               "ellipsoidGate")){
              gate_count_list <<- gate_count_list + 1
            }else if(class(y) == "quadGate"){
              gate_count_list<<- gate_count_list + 4
            }
          })
          gate_count <<- gate_count + gate_count_list
        }
      })
    # LIST OF GATE OBJECT LISTS - NECESSARY?
    }else if(all(LAPPLY(x, "class") == "list")){
      gate_count <- 0
      lapply(x, function(Z){
        gate_count_list <- 0
        lapply(z, function(y){
          if(class(y) %in% c("rectangleGate",
                             "polygonGate",
                             "ellipsoidGate",
                             "filters")){
            gate_count_list <<- gate_count_list + length(y)
          }else if(class(y) == "quadGate"){
            gate_count_list <<- gate_count_list + 4
          }
        })
        gate_count <<- gate_count + gate_count_list
      })
    }
  } else {
    gate_count <- 0
  }
  # RETURN GATE COUNT
  return(gate_count)
}

# ARGUMENT HANDLERS ------------------------------------------------------------

#' Repeat and split arguments for use in cyto_plot
#'
#' Use with cyto_plot only!
#'
#' @param x named list of arguments
#'
#' @author Dillon Hammill (Dillon.Hammill@anu.edu.au)
#'
#' @noRd
.cyto_plot_args_split <- function(x) {

  # NUMBER OF PLOTS - N --------------------------------------------------------
  if(all(LAPPLY(x[["fr_list"]], "class") == "flowFrame")){
    N <- 1
  }else if(all(LAPPLY(x[["fr_list"]], function(z){class(z)}) == "flowFrame")){
    N <- length(x[["fr_list"]])
  }
  
  # LAYERS PER PLOT - L --------------------------------------------------------
  if(N == 1){
    L <- length(x[["fr_list"]])
  }else{
    L <- LAPPLY(x[["fr_list"]], "length")
  }
  
  # TOTAL LAYERS - TL ----------------------------------------------------------
  TL <- N * sum(L)
  
  # GATES PER PLOT - G ---------------------------------------------------------
  if(N == 1){
    if(all(LAPPLY(x[["gate"]], function(z){.all_na(z)}))){
      G <- 0
    }else{
      G <- length(x[["gate"]])
    }
  }else{
    if(all(LAPPLY(x[["gate"]][[1]], function(z){.all_na(z)}))){
      G <- 0
    }else{
      G <- length(x[["gate"]][[1]])
    }
  }
  
  # POPULATIONS PER GATE -------------------------------------------------------
  P <- c()
  if(N == 1){
    if(G != 0) {
      lappy(x[["gate"]], function(z){
        if(class(z) == "quadGate"){
          P <<- c(P, 4)
        }else{
          P <<- c(P, 1)
        }
      })
    }
  }else if(N > 1){
    if(G != 0){
      lappy(x[["gate"]][[1]], function(z){
        if(class(z) == "quadGate"){
          P <<- c(P, 4)
        }else{
          P <<- c(P, 1)
        }
      })
    }
  }
  
  # POPULATIONS PER PLOT -------------------------------------------------------
  
  TP <- sum(P)
  
  # ARGUMENTS NOT REPEATED -----------------------------------------------------
  
  # The following arguments are not repeated: 
  # - arguments used to prepare the data - x, overlay, display, density_modal,
  #   density_stack, density_smooth
  # - arguments that MUST be the same in each plot - channels, limits, popup,
  #   xlim, ylim, negate, density_cols, point_col_scale, point_cols, legend
  # - arguemnts already prepared - gate

  # CYTO_PLOT ARGUMENTS --------------------------------------------------------
  
  # AVAILABLE ARGUMENTS
  ARGS <- formalArgs(cyto_plot4.flowSet)
  
  # REMOVE ARGUMENTS (SAME PER PLOT)
  ARGS <- ARGS[-match(c("x",
                        "overlay",
                        "display",
                        "channels",
                        "gate",
                        "limits",
                        "popup",
                        "xlim",
                        "ylim",
                        "negate",
                        "density_modal",
                        "density_stack",
                        "density_smooth",
                        "density_cols",
                        "point_cols",
                        "point_col_scale"), ARGS)]
  
  # ARGUMENTS PER PLOT ---------------------------------------------------------
  
  # SINGLE LENGTH ARGUMENTS
  args <- c("xlab",
            "ylab",
            ARGS[grepl("title", ARGS)],
            ARGS[grepl("axes_text_", ARGS)],
            ARGS[grepl("axes_label_", ARGS)],
            "label",
            "legend",
            ARGS[grepl("border_", ARGS)])
  
  # UPDATE AVAILABLE ARGUMENTS
  ARGS <- ARGS[-match(args, ARGS)]

  lapply(args, function(arg) {
    if (arg %in% names(x)) {
      res <- rep_len(x[[arg]], N)

      if (N == 1) {
        res <- list(res)
      } else {
        res <- split(res, rep_len(seq_len(N), N))
      }

      x[[arg]] <<- res
    }
  })

  # MULTIPLE LENGTH ARGUMENTS
  args <- c("axes_text")

  # UPDATE AVAILABLE ARGUMENTS
  ARGS <- ARGS[-match(args, ARGS)]
  
  lapply(args, function(arg) {
    if (arg %in% names(x)) {
      res <- rep_len(x[[arg]], N * 2)

      if (N == 1) {
        res <- list(res)
      } else {
        res <- split(res, rep(seq_len(N), length.out = N * 2, each = 2))
      }

      x[[arg]] <<- res
    }
  })

  # ARGUMENTS PER LAYER --------------------------------------------------------
  
  # CONTOUR_LINES (ADD ZEROS)
  args <- c("contour_lines")

  # UPDATE AVAILABLE ARGUMENTS
  ARGS <- ARGS[-match(args, ARGS)]
  
  lapply(args, function(arg) {
    if (arg %in% names(x)) {
      if (length(x[[arg]]) < L) {
        res <- rep(c(x[[arg]], rep(0, L)), length.out = L)
        res <- rep(res, N)
      }else{
        res <- x[[arg]]
      }

      if (N == 1) {
        res <- list(res)
      } else {
        res <- split(res, rep(seq_len(N), length.out = TL, each = L))
      }

      x[[arg]] <<- res
    }
  })  
  
  # ARGUMENTS/LAYER
  args <- c(ARGS[grepl("density_fill", ARGS)],
            ARGS[grepl("density_line", ARGS)],
            ARGS[grepl("legend_", ARGS)],
            ARGS[grepl("point_", ARGS)],
            ARGS[grepl("contour_", ARGS)])

  # UPDATE AVAILABLE ARGUMENTS
  ARGS <- ARGS[-match(args, ARGS)]
  
  lapply(args, function(arg) {
    if (arg %in% names(x)) {
      res <- rep(x[[arg]], length.out = TL)

      if (N == 1) {
        res <- list(res)
      } else {
        res <- split(res, rep(seq_len(N), length.out = TL, each = L))
      }

      x[[arg]] <<- res
    }
  })

  # ARGUMENTS PER GATE ---------------------------------------------------------
  
  # ARGUMENTS
  args <- ARGS[grepl("gate_line", ARGS)]
  
  # UPDATE AVAILABLE ARGUMENTS
  ARGS <- ARGS[-match(args, ARGS)]
  
  if (G != 0) {
    lapply(args, function(arg) {
      if (arg %in% names(x)) {
        res <- rep(x[[arg]], length.out = G * N)
        
        if (N == 1) {
          res <- list(res)
        } else {
          res <- split(res, rep(seq_len(N),
                                length.out = G * N,
                                each = G
          ))
        }
        
        x[[arg]] <<- res
      }
    })
  }
  
  # ARGUMENTS PER POPULATION ---------------------------------------------------
  
  # GATE_FILL ARGUMENTS
  args <- c(ARGS[grepl("gate_fill", ARGS)])
  
  # UPDATE AVAILABLE ARGUMENTS
  ARGS <- ARGS[-match(args, ARGS)]

  if (G != 0) {
    lapply(args, function(arg) {
      if (arg %in% names(x)) {
        res <- rep(x[[arg]], length.out = TP * N)

        if (N == 1) {
          res <- list(res)
        } else {
          res <- split(res, rep(seq_len(N),
                                length.out = TP * N,
                                each = TP))
        }

        x[[arg]] <<- res
      }
    })
  }

  # LABEL ARGUMENTS - NEGATE
  args <- ARGS[grepl("label_", ARGS)]
  
  # UPDATE AVAILABLE ARGUMENTS
  ARGS <- ARGS[-match(args, ARGS)]
  
  # NEGATED POPULATION
  if("negate" %in% names(x)){
    if(x[["negate"]]){
      # WATCH OUT - QUADGATES
      if(N == 1){
        if(!"quadGate" %in% LAPPLY(x[["gate"]], "class")){
          TP <- TP + 1
        }
      }else if(N == 2){
        if(!"quadGate" %in% LAPPLY(x[["gate"]][[1]], "class")){
          TP <- TP + 1
        }
      }
    }
  }

  # 1D PLOT
  if (length(channels) == 1) {

    lapply(args, function(arg) {
      if (arg %in% names(x)) {
        if (G != 0) {
          if (arg %in% c(
            "label_text",
            "label_text_x",
            "label_text_y"
          )) {
            if (length(x[[arg]]) < TP) {
              x[[arg]] <- c(x[[arg]], rep(NA, TP - length(x[[arg]])))
            }
          }

          res <- rep(x[[arg]], length.out = TP * N * L)

          if (N == 1) {
            res <- list(res)
          } else {
            res <- split(res, rep(seq_len(N),
              length_out = TP * N * L,
              each = TP * L
            ))
          }

          x[[arg]] <<- res

          # labels without gates
        } else {
          if (arg %in% c(
            "label_text",
            "label_text_x",
            "label_text_y"
          )) {
            if (length(x[[arg]]) < L) {
              x[[arg]] <- c(x[[arg]], rep(NA, L - length(x[[arg]])))
            }
          }
          res <- rep(x[[arg]], length.out = TL)

          if (N == 1) {
            res <- list(res)
          } else {
            res <- split(res, rep(seq_len(N),
              length_out = TL,
              each = L
            ))
          }

          x[[arg]] <<- res
        }
      }
    })

  # 2D PLOT
  } else if (length(channels) == 2) {

    if (G != 0) {
      lapply(args, function(arg) {
        if (arg %in% names(x)) {
          if (arg %in% c(
            "label_text",
            "label_text_x",
            "label_text_y"
          )) {
            if (length(x[[arg]]) < TP) {
              x[[arg]] <- c(x[[arg]], rep(NA, TP - length(x[[arg]])))
            }
          }

          res <- rep(x[[arg]], length.out = TP * N)

          if (N == 1) {
            res <- list(res)
          } else {
            res <- split(res, rep(seq_len(N),
              length.out = TP * N,
              each = TP
            ))
          }

          x[[arg]] <<- res
        }
      })

      # No gates expect 1 label per layer
    } else if (G == 0) {
      lapply(args, function(arg) {
        if (arg %in% names(x)) {
          if (arg %in% c(
            "label_text",
            "label_text_x",
            "label_text_y"
          )) {
            if (length(x[[arg]]) < L) {
              x[[arg]] <- c(x[[arg]], rep(NA, L - length(x[[arg]])))
            }
          }

          res <- rep(x[[arg]], length.out = TL)

          if (N == 1) {
            res <- list(res)
          } else {
            res <- split(res, rep(seq_len(N),
              length_out = TL,
              each = L
            ))
          }

          x[[arg]] <<- res
        }
      })
    }
  }

  return(x)
}

# POINT DENSITY COLOURS --------------------------------------------------------

#' Get density gradient colours for cyto_plot_2d
#'
#' @param point_cols vector of ordered colours to use for point density colour
#'   scale.
#'
#' @return a list of colorRampPalette functions to be used in densCols.
#'
#' @author Dillon Hammill (Dillon.Hammill@anu.edu.au)
#'
#' @importFrom grDevices colorRampPalette
#'
#' @noRd
.cyto_plot_point_cols <- function(point_cols = NA) {

  # Pull down arguments to named list
  args <- .args_list()

  # Inherit arguments from cyto_plot_theme
  args <- .cyto_plot_theme_inherit(args)

  # Use default colour scale
  if (.all_na(args[["point_cols"]])) {
    args[["point_cols"]] <- c(
      "blue",
      "turquoise",
      "green",
      "yellow",
      "orange",
      "red",
      "darkred"
    )
  }

  return(args[["point_cols"]])
}

# GATES ------------------------------------------------------------------------

#' Check gate object supplied to cyto_plot
#'
#' @param gate gate object(s) to add to plot.
#' @param smp number of samples
#'
#' @author Dillon Hammill, \email{Dillon.Hammill@anu.edu.au}
#'
#' @noRd
.cyto_gate_check <- function(gate, smp) {

  # A single gate supplied
  if (inherits(gate, "rectangleGate") |
    inherits(gate, "polygonGate") |
    inherits(gate, "ellipsoidGate")) {
    gate <- rep(list(list(gate)), smp)

    # A filters object supplied
  } else if (inherits(gate, "filters")) {
    gate <- rep(list(filters), smp)

    # A list of gate objects
  } else if (inherits(gate, "list")) {

    # List of individual gates
    if (all(LAPPLY(gate, class) %in%
      c("rectangleGate", "polygonGate", "ellipsoidGate"))) {

      # Assume 1 gate per sample
      if (length(gate) == smp) {
        gate <- lapply(gate, "list")

        # Assume list contains gates for each sample
      } else {
        gate <- rep(list(gate), smp)
      }

      # List of filters objects
    } else if (all(LAPPLY(gate, class) == "filters")) {

      # Assume 1 filters object per sample
      gate <- rep(gate, length.out = smp)
    }

    # filtersList
  } else if (inherits(gate, "filtersList")) {
    gate <- gate
  }

  return(gate)
}

# LAYOUT -----------------------------------------------------------------------

#' Set plot layout
#'
#' @param x list of flowFrame lists to be plotted.
#' @param layout grid dimensions c(nr, nc), NA or FALSE.
#' @param density_stack degree of offset.
#' @param denisity_layers number of layers per plot.
#'
#' @importFrom grDevices n2mfrow
#'
#' @noRd
.cyto_plot_layout <- function(x,
                              layout = NA,
                              density_stack = 0,
                              density_layers = NA) {

  # Number of samples
  smp <- length(x)

  # Plot layout
  if (.empty(layout)) {
    if (smp > 1) {
      mfrw <- c(grDevices::n2mfrow(smp)[2], grDevices::n2mfrow(smp)[1])
    } else {
      mfrw <- c(1, 1)
    }
  } else if (!.empty(layout)) {
    if (layout[1] %in% c(FALSE, NA)) {

      # Do nothing
    } else {
      mfrw <- layout
    }
  }

  return(mfrw)
}

# MARGINS ----------------------------------------------------------------------

#' Set plot margins
#'
#' @param x list of flowFrames or density objects to plot.
#' @param legend logical indicating whether a legend should be included in the
#'   plot.
#' @param title if NULL remove excess space above plot.
#' @param axes_text vector of logicals indicating whether the x and y axes
#'   should be included on the plot.
#'
#' @noRd
.cyto_plot_margins <- function(x,
                               legend = FALSE,
                               legend_text = NA,
                               legend_text_size = 1,
                               title,
                               axes_text = list(TRUE, TRUE)) {

  # Bypass setting margins on cyto_plot_grid
  if (!getOption("CytoRSuite_cyto_plot_grid")) {

    # Pull down arguments to named lis
    args <- .args_list()

    # Default margins
    mar <- c(5.1, 5.1, 4.1, 2.1)

    # Make space for legend text on right
    if (length(x) > 1 &
      legend != FALSE &
      !.all_na(legend_text)) {
      mar[4] <- 7 + max(nchar(legend_text)) * 0.32 * legend_text_size
    }

    # Remove space above plot if no title
    if (.all_na(title)) {
      mar[3] <- 2.1
    }

    # Remove space below plot if x axis is missing
    if (!all(inherits(axes_text[[1]], "list"))) {
      if (.all_na(axes_text[[1]])) {
        # NA == FALSE returns NA not T/F
      } else if (all(axes_text[[1]] == FALSE)) {
        mar[1] <- 4.1
      }
    }

    # Remove space below plot if y axis is missing
    if (!all(inherits(axes_text[[2]], "list"))) {
      if (.all_na(axes_text[[2]])) {
        # NA == FALSE return NA not T/F
      } else if (all(axes_text[[2]] == FALSE)) {
        mar[2] <- 4.1
      }
    }

    # Set update graphics parameter
    par("mar" = mar)
  }
}

# LEGEND -----------------------------------------------------------------------

#' Create a legend for cyto_plot
#'
#' \code{.cyto_plot_margins} will handle setting the plot margins to make space
#' for the legend.
#'
#' @param x list of flowFrame objects to include in the plot.
#' @param channels name of the channels or markers to be used to construct the
#'   plot.
#' @param legend logical indicating whether a legend should be included for
#'   plots including overlays, set to FALSE by default.
#' @param legend_text vector of labels to use for the legend.
#' @param legend_text_font numeric indicating the font to use for legend text,
#'   set to 2 for bold font by default. See \code{\link[graphics:par]{?par}}
#'   font for details.
#' @param legend_text_size character expansion for legend text, set to 1 by
#'   default.
#' @param legend_text_col colour to use for legend text, set to "black by
#'   default.
#' @param legend_line_col vector of line colours to use for legend.
#' @param legend_box_fill vector of fill colours to use for legend.
#' @param legend_point_col vector of colours to use for points in legend.
#' @param density_fill colour(s) used to fill polygons.
#' @param density_fill_alpha numeric [0,1] used to control fill transparency,
#'   set to 1 by default to remove transparency.
#' @param density_line_type line type(s) to use for border(s), set to solid
#'   lines by default.
#' @param density_line_width line width for border.
#' @param density_line_col colour(s) for border line, set to "black" by default.
#' @param point_shape point character to use for points, set to "." by default
#'   to maximise plotting speed.
#' @param point_size numeric specifying the degree of character expansion for
#'   points, set to 2 by default.
#' @param point_col colours to use for points, set to NA by default to blue-red
#'   density colour scale.
#' @param point_alpha numeric [0,1] used to control colour transparency, set to
#'   1 by default to remove transparency.
#'
#' @author Dillon Hammill, \email{Dillon.Hammill@anu.edu.au}
#'
#' @importFrom graphics legend strheight
#' @importFrom grDevices adjustcolor
#'
#' @noRd
.cyto_plot_legend <- function(x,
                              channels,
                              legend = "fill",
                              legend_text = NA,
                              legend_text_font = 1,
                              legend_text_size = 1,
                              legend_text_col = "black",
                              legend_line_type = NA,
                              legend_line_width = NA,
                              legend_line_col = NA,
                              legend_box_fill = NA,
                              legend_point_col = NA,
                              density_cols = NA,
                              density_fill = NA,
                              density_fill_alpha = 1,
                              density_line_type = 1,
                              density_line_width = 1,
                              density_line_col = "black",
                              point_shape = ".",
                              point_size = 2,
                              point_cols = NA,
                              point_col = NA,
                              point_col_alpha = 1) {

  # ARGUMENTS ------------------------------------------------------------------

  # ARGUMENTS
  args <- .args_list()

  # CYTO_PLOT_THEME
  args <- .cyto_plot_theme_inherit(args)

  # UPDATE ARGUMENTS
  .args_update(args)

  # LEGEND_TEXT ----------------------------------------------------------------
  if (legend != FALSE) {
    if (.all_na(legend_text)) {
      legend_text <- cyto_names(x)
    }
  }

  # Estimate legend height using strheight
  lgnd <- paste(legend_text, collapse = " \n ")
  lgnd_height <- strheight(lgnd,
    cex = legend_text_size,
    font = legend_text_font
  )

  # LEGEND POSITION ------------------------------------------------------------

  # Calculate y center of plot
  cnt <- par("usr")[3] + (par("usr")[4] - par("usr")[3]) / 2

  # Legend for 1D density distributions
  if (length(channels) == 1) {

    # Set default legend type to fill
    if (legend == TRUE) {
      legend <- "fill"
    }

    # Reverse legend text order for legend
    legend_text <- rev(legend_text)

    # Line legend
    if (legend == "line") {

      # Revert to density_line_col if no colours supplied
      if (.all_na(legend_line_col)) {
        legend_line_col <- density_line_col
      }

      # Revert to density_line_type if not specified
      if (.all_na(legend_line_type)) {
        legend_line_type <- density_line_type
      }

      # Revert to density_line_width if not specified
      if (.all_na(legend_line_width)) {
        legend_line_width <- density_line_width
      }

      # Construct legend
      legend(
        x = 1.07 * par("usr")[2],
        y = cnt + 0.52 * lgnd_height,
        legend = legend_text,
        text.font = rev(legend_text_font),
        cex = legend_text_size,
        text.col = rev(legend_text_col),
        col = rev(legend_line_col),
        lty = rev(legend_line_type),
        lwd = rev(legend_line_width),
        xpd = TRUE,
        bty = "n",
        x.intersp = 0.5
      )
    } else if (legend == "fill") {

      # COLOURS
      density_fill <- .cyto_plot_density_fill(x,
        density_fill = density_fill,
        density_cols = density_cols,
        density_fill_alpha = 1
      )

      # Revert to density_fill if no legend fill colours supplied
      if (.all_na(legend_box_fill)) {
        legend_box_fill <- density_fill
      }
      # Alpha adjust colours if suppplied directly to legend_box_fill
      if (!.all_na(legend_box_fill) &
        !all(density_fill_alpha == 1)) {
        legend_box_fill <- mapply(
          function(legend_box_fill,
                             density_fill_alpha) {
            adjustcolor(legend_box_fill, density_fill_alpha)
          }, legend_box_fill, density_fill_alpha
        )
      }

      # Construct legend
      legend(
        x = 1.07 * par("usr")[2],
        y = cnt + 0.52 * lgnd_height,
        legend = legend_text,
        fill = rev(legend_box_fill),
        xpd = TRUE,
        bty = "n",
        x.intersp = 0.5,
        cex = legend_text_size,
        text.col = rev(legend_text_col),
        text.font = rev(legend_text_font)
      )
    }

    # Legend for 2D scatter plot
  } else if (length(channels) == 2) {

    # Prepare point_cols
    point_cols <- .cyto_plot_point_cols(point_cols)

    # Prepare point_col - alpha adjust later
    point_col <- .cyto_plot_point_col(x,
      channels = channels,
      point_col_scale = point_col_scale,
      point_cols = point_cols,
      point_col = point_col,
      point_col_alpha = 1
    )

    # Prepare point col - use first density colour
    point_col <- LAPPLY(point_col, function(z) {
      if (length(z) > 1) {
        return(point_cols[1])
      } else {
        return(z)
      }
    })

    # Revert to point_col if no legend point cols supplied
    if (.all_na(legend_point_col)) {
      legend_point_col <- point_col
    }

    # Alpha adjust colours supplied directly to legend_point_col
    if (!.all_na(legend_point_col) &
      !all(point_col_alpha == 1)) {
      legend_point_col <- mapply(function(col, alpha) {
        adjustcolor(col, alpha)
      }, legend_point_col, point_col_alpha)
    }

    legend(
      x = 1.08 * par("usr")[2],
      y = cnt + 0.6 * lgnd_height,
      legend = rev(legend_text),
      col = rev(legend_point_col),
      pch = rev(point_shape),
      pt.cex = rev(2 * point_size),
      xpd = TRUE,
      bty = "n",
      x.intersp = 0.7,
      cex = legend_text_size,
      text.col = rev(legend_text_col),
      text.font = rev(legend_text_font)
    )
  }
}

# THEME INHERIT ----------------------------------------------------------------

#' Inherit cyto_plot_theme arguments
#'
#' @param x list of named cyto_plot arguments.
#'
#' @return updated list of named arguments if cyto_plot_theme has been set.
#'
#' @author Dillon Hammill, \email{Dillon.Hammill@anu.edu.au}
#'
#' @noRd
.cyto_plot_theme_inherit <- function(x) {

  # extract cyto_plot_theme arguments
  args <- getOption("CytoRSuite_cyto_plot_theme")

  if (!is.null(args)) {
    lapply(names(args), function(y) {
      x[[y]] <<- args[[y]]
    })
  }

  return(x)
}

# TITLE ------------------------------------------------------------------------

#' Title for cyto_plot
#'
#' @param x flowFrame object.
#'
#' @author Dillon Hammill, \email{Dillon.Hammill@anu.edu.au}
#'
#' @noRd
.cyto_plot_title <- function(x,
                             channels,
                             overlay = NA,
                             title = "") {

  # x can be a list
  if (class(x) == "list") {
    if (length(x) > 1) {
      overlay <- x[2:length(x)]
      x <- x[[1]]
    }
  }

  # Pull down arguments to named list
  args <- .args_list()

  # Update arguments
  .args_update(args)

  # 1D density distributions
  if (length(channels) == 1) {

    # missing/empty replace with valid title
    if (.empty(title)) {

      # stacked/overlays lack a title
      if (.all_na(overlay)) {
        title <- identifier(x)
        if (title == "anonymous") {
          title <- "Combined Events"
        }
      } else {
        title <- NA
      }

      # NA will remove title in cyto_plot_empty
    } else if (.all_na(title)) {
      title <- NA
    }

    # 2D scatterplots
  } else if (length(channels) == 2) {

    # missing title replaced with sample name
    if (.empty(title)) {
      title <- identifier(x)
      if (title == "anonymous") {
        title <- "Combined Events"
      }

      # NA will remove title in cyto_plot_empty
    } else if (.all_na(title)) {
      title <- NA
    }
  }

  return(title)
}

# AXES LABELS ------------------------------------------------------------------

#' Get axes titles for cyto_plot
#'
#' @param x flowFrame object.
#'
#' @author Dillon Hammill, \email{Dillon.Hammill@anu.edu.au}
#'
#' @noRd
.cyto_plot_axes_label <- function(x,
                                  channels,
                                  xlab,
                                  ylab,
                                  density_modal = TRUE) {

  # Extract information about channels
  fr_data <- pData(parameters(x))
  fr_channels <- BiocGenerics::colnames(x)

  # 1D density distributions
  if (length(channels) == 1) {

    # x axis label
    if (missing(xlab) | .empty(xlab)) {
      # Marker assigned to channel
      if (!is.na(fr_data$desc[which(fr_channels == channels)])) {
        # Channel only if marker is identical
        if(fr_data$desc[which(fr_channels == channels)] == channels){
          xlab <- paste(channels)
        }else{
          xlab <- paste(fr_data$desc[which(fr_channels == channels)],
            channels,
            sep = " "
          )
        }
        # No assigned marker to channel
      } else if (is.na(fr_data$desc[which(fr_channels == channels)])) {
        xlab <- paste(channels)
      }
    } else if (.all_na(xlab)) {
      xlab <- NA
    }

    # y axis label
    if (missing(ylab) | .empty(ylab)) {
      if (density_modal) {
        ylab <- "% of Mode"
      } else {
        ylab <- "Density"
      }
    } else if (.all_na(ylab)) {
      ylab <- NA
    }

    # 2D scatterplots
  } else if (length(channels) == 2) {

    # x axis label
    if (missing(xlab) | .empty(xlab)) {
      # Marker assigned to channel
      if (!is.na(fr_data$desc[which(fr_channels == channels[1])])) {
        # Channel only if marker is identical
        if(fr_data$desc[which(fr_channels == channels[1])] == channels[1]){
          xlab <- paste(channels[1])
        }else{
          xlab <- paste(fr_data$desc[which(fr_channels == channels[1])],
            channels[1],
            sep = " "
          )
        }
        # No assigned marker to channel
      } else if (is.na(fr_data$desc[which(fr_channels == channels[1])])) {
        xlab <- paste(channels[1])
      }
    } else if (.all_na(xlab)) {
      xlab <- NA
    }

    # y axis label
    if (missing(ylab) | .empty(ylab)) {
      # Marker assigned to channel
      if (!is.na(fr_data$desc[which(fr_channels == channels[2])])) {
        # Channel only if marker matches
        if(fr_data$desc[which(fr_channels == channels[2])] == channels[2]){
          ylab <- paste(channels[2])
        }else{
          ylab <- paste(fr_data$desc[which(fr_channels == channels[2])],
            channels[2],
            sep = " "
          )
        }

        # No assigned marker to channel
      } else if (is.na(fr_data$desc[which(fr_channels == channels[2])])) {
        ylab <- paste(channels[2])
      }
    } else if (.all_na(ylab)) {
      ylab <- NA
    }
  }

  return(list(xlab, ylab))
}

# DENSITY FILL -----------------------------------------------------------------

#' Get density fill colours for cyto_plot
#'
#' @param x list of flowFrame or density objects.
#' @param density_fill vector of colours to use for each layer.
#' @param density_cols vector of colls to use to select density_fill colours.
#'
#' @importFrom grDevices adjustcolor colorRampPalette
#'
#' @author Dillon Hammill, \email{Dillon.Hammill@anu.edu.au}
#'
#' @noRd
.cyto_plot_density_fill <- function(x,
                                    density_fill = NA,
                                    density_cols = NA,
                                    density_fill_alpha = 1) {

  # Expected number of colours
  n <- length(x)

  # Pull down arguments to named list
  args <- as.list(environment())

  # Inherit arguments from cyto_plot_theme
  args <- .cyto_plot_theme_inherit(args)

  # No density_cols supplied
  if (.all_na(args[["density_cols"]])) {
    args[["density_cols"]] <- c(
      "grey",
      "bisque4",
      "brown1",
      "red",
      "darkred",
      "chocolate",
      "orange",
      "yellow",
      "yellowgreen",
      "green",
      "aquamarine",
      "cyan",
      "cornflowerblue",
      "blue",
      "blueviolet",
      "purple",
      "magenta",
      "deeppink"
    )
  }


  # Make colorRampPalette
  if (class(args[["density_cols"]]) != "function") {
    cols <- colorRampPalette(args[["density_cols"]])
  } else {
    cols <- args[["density_cols"]]
  }

  # No colours supplied to density_fill either
  if (.all_na(args[["density_fill"]]) | .empty(args[["density_fill"]])) {

    # Pull out a single colour per layer
    args[["density_fill"]] <- cols(n)

    # Colours supplied manually to density_fill
  } else {

    # Too few colours supplied - pull others from cols
    if (length(args[["density_fill"]]) < n) {
      args[["density_fill"]] <- c(
        args[["density_fill"]],
        cols(n - length(args[["density_fill"]]))
      )

      # Too many colours supplied
    } else if (length(args[["density_fill"]]) > n) {
      args[["density_fill"]] <- args[["density_fill"]][seq(1, n)]
    }
  }

  # Adjust colors by density_fill_alpha
  if (any(args[["density_fill_alpha"]] != 1)) {
    args[["density_fill"]] <- mapply(function(density_fill, density_fill_alpha) {
      if (density_fill_alpha != 1) {
        adjustcolor(density_fill, density_fill_alpha)
      } else {
        density_fill
      }
    }, args[["density_fill"]], args[["density_fill_alpha"]], USE.NAMES = FALSE)
  }

  return(args[["density_fill"]])
}

# POINT COLOUR -----------------------------------------------------------------

#' Get point colours for cyto_plot
#'
#' @param x list of flowFrames.
#' @param channels used to construct the plot.
#' @param point_col_scale vector of colours to use for density gradient.
#' @param point_cols vector colours to select from when choosing a colour for
#'   each layer in x.
#' @param point_col vector of length x indicating colours to use for each layer.
#'   If NA set to default density gradient.
#' @param point_col_alpha transparency to use for point colours.
#'
#' @importFrom grDevices densCols colorRampPalette adjustcolor
#' @importFrom flowCore exprs
#'
#'
#' @author Dillon Hammill, \email{Dillon.Hammill@anu.edu.au}
#'
#' @noRd
.cyto_plot_point_col <- function(x,
                                 channels,
                                 point_col_scale,
                                 point_cols,
                                 point_col,
                                 point_col_alpha = 1) {

  # Expected number of colours
  n <- length(x)

  # Pull down arguments to named list
  args <- .args_list()

  # Inherit arguments from cyto_plot_theme - possibly remove?
  args <- .cyto_plot_theme_inherit(args)

  # Update arguments
  .args_update(args)

  # No colours supplied for density gradient
  if (.all_na(point_col_scale)) {
    point_col_scale <- c(
      "blue",
      "turquoise",
      "green",
      "yellow",
      "orange",
      "red",
      "darkred"
    )
  }

  # Make colorRampPalette
  if (class(point_col_scale) != "function") {
    col_scale <- colorRampPalette(point_col_scale)
  } else {
    col_scale <- point_col_scale
  }

  # No colours supplied for selection
  if (.all_na(point_cols)) {
    point_cols <- c(
      "black",
      "darkorchid",
      "blueviolet",
      "magenta",
      "deeppink",
      "red4",
      "orange",
      "springgreen4"
    )
  }

  # Make colorRampPalette
  if (class(point_cols) != "function") {
    cols <- colorRampPalette(point_cols)
  } else {
    cols <- point_cols
  }

  # Repeat point_col n times
  point_col <- rep(point_col,
    length.out = n
  )

  # Convert point_col to list
  if (!inherits(point_col, "list")) {
    point_col <- lapply(seq(1, n), function(z) {
      point_col[z]
    })
  }

  # First layer contains density gradient in no other colour is designated
  if (.all_na(point_col)) {

    # Extract data
    fr_exprs <- exprs(x[[1]])[, channels]

    # Too few events for density computation
    if (!is.null(nrow(fr_exprs))) {
      if (nrow(fr_exprs) >= 2) {
        # Get density colour for each point
        point_col[[1]] <- densCols(fr_exprs,
          colramp = col_scale
        )
      }
    } else {
      point_col[[1]] <- point_col_scale[1]
    }
  } else if (any(is.na(point_col))) {

    # Get position of NAs in point_col - replace with density scale
    ind <- which(is.na(point_col))

    # Run through each ind and get density gradient colours
    lapply(ind, function(z) {

      # Extract data
      fr_exprs <- exprs(x[[z]])[, channels]

      # Too few events for density computation
      if (!is.null(nrow(fr_exprs))) {
        if (nrow(fr_exprs) >= 2) {
          # Get density colour for each point
          point_col[[z]] <<- densCols(fr_exprs,
            colramp = col_scale
          )
        }
      } else {
        point_col[[z]] <- point_col_scale[1]
      }
    })
  }

  # Remaining colours are selected one per layer from point_cols
  if (any(is.na(point_col))) {

    # Number of layers missing colours
    n <- length(point_col[is.na(point_col)])

    # Pull colours out of point_cols
    clrs <- cols(n)

    # Replace NA values in point_col with selected colours
    point_col[is.na(point_col)] <- clrs
  }

  # Adjust colors by point_fill_alpha
  point_col <- mapply(function(point_col,
                                 point_col_alpha) {
    adjustcolor(point_col, point_col_alpha)
  },
  point_col,
  point_col_alpha,
  USE.NAMES = FALSE,
  SIMPLIFY = FALSE
  )

  return(point_col)
}

# LABEL CENTERS -----------------------------------------------------------

#' Get gate centers to use to position labels
#'
#' @param x gate object.
#' @param channels channels used to construct the plot.
#' @param text_x x co-ordinate for label.
#' @param text_y y co-ordinate for label.
#'
#' @importFrom graphics par
#' @importFrom flowCore rectangleGate
#'
#' @noRd
.cyto_plot_label_center <- function(x, ...) {
  UseMethod(".cyto_plot_label_center")
}

#' @noRd
.cyto_plot_label_center.rectangleGate <- function(x,
                                                  channels,
                                                  text_x = NA,
                                                  text_y = NA) {

  # GRAPHICAL PARAMETERS -------------------------------------------------------
  
  # PLOT LIMITS
  lims <- par("usr")
  
  # X LIMITS
  xmin <- lims[1]
  xmax <- lims[2]
  xpad <- ((xmax - xmin) - (xmax - xmin)/1.04)/2 # 2% BUFFER EITHER SIDE
  xmin <- xmin + 0.5 * xpad # 1% BUFFER
  xmax <- xmax - 0.5 * xpad # 1% BUFFER
  
  # Y LIMITS
  ymin <- lims[3]
  ymax <- lims[4]
  ypad <- ((ymax - ymin) - (ymax - ymin)/1.04)/2 # 2% BUFFER EITHER SIDE
  ymin <- ymin + 0.5 * ypad # 1% BUFFER
  ymax <- ymax - 0.5 * ypad # 1% BUFFER
  
  # PREPARE GATE ---------------------------------------------------------------
  
  # CORRECT DIMENSIONS
  x <- cyto_gate_convert(x, channels = channels)
  
  # GATE CENTER ----------------------------------------------------------------

  # 1D GATE - 1D PLOT
  if(length(channels) == 1){
    # X COORD
    if(.all_na(text_x)){
      gate_xmin <- x@min
      gate_xmax <- x@max
      # REPLACE INFINITE COORDS
      if(is.infinite(gate_xmin)){
        gate_xmin <- xmin
      }
      if(is.infinite(gate_xmax)){
        gate_xmax <- xmax
      }
    }
    # Y COORD
    if(.all_na(text_y)){
      gate_ymin <- ymin
      gate_ymax <- ymax
    }
    
  # 2D GATE - 2D PLOT
  }else if(length(channels) == 2){
    # X COORD
    if(.all_na(text_x)){
      gate_xmin <- x@min[channels[1]]
      gate_xmax <- x@max[channels[1]]
      # REPLACE INFINITE COORDS
      if(is.infinite(gate_xmin)){
        gate_xmin <- xmin
      }
      if(is.infinite(gate_xmax)){
        gate_xmax <- xmax
      }
    }
    # Y COORD
    if(.all_na(text_y)){
      gate_xmin <- x@min[channels[2]]
      gate_xmax <- x@max[channels[2]]
      # REPLACE INFINITE COORDS
      if(is.infinite(gate_ymin)){
        gate_ymin <- ymin
      }
      if(is.infinite(gate_ymax)){
        gate_ymax <- ymax
      }
    }
  }
  
  # GATE CENTER ----------------------------------------------------------------
  
  # GATE CENTER -  X COORD
  if(.all_na(text_x)){
    text_x <- (gate_xmin + gate_xmax) / 2
  }
  
  # GATE CENTER - Y COORD
  if(.all_na(text_y)){
    text_y <- (gate_ymin + gate_ymax) / 2
  }

  # RETURN GATE CENTER ---------------------------------------------------------
  
  # GATE CENTER MATRIX
  text_xy <- matrix(c(text_x, text_y),
                    ncol = 2,
                    byrow = FALSE)
  colnames(text_xy) <- c("x", "y")

  # RETURN GATE CENTER MATRIX
  return(text_xy)
}

#' @noRd
.cyto_plot_label_center.polygonGate <- function(x,
                                                channels,
                                                text_x = NA,
                                                text_y = NA) {

  # GRAPHICAL PARAMETERS -------------------------------------------------------
  
  # PLOT LIMITS
  lims <- par("usr")
  
  # X LIMITS
  xmin <- lims[1]
  xmax <- lims[2]
  xpad <- ((xmax - xmin) - (xmax - xmin)/1.04)/2 # 2% BUFFER EITHER SIDE
  xmin <- xmin + 0.5 * xpad # 1% BUFFER
  xmax <- xmax - 0.5 * xpad # 1% BUFFER
  
  # Y LIMITS
  ymin <- lims[3]
  ymax <- lims[4]
  ypad <- ((ymax - ymin) - (ymax - ymin)/1.04)/2 # 2% BUFFER EITHER SIDE
  ymin <- ymin + 0.5 * ypad # 1% BUFFER
  ymax <- ymax - 0.5 * ypad # 1% BUFFER
  
  # PREPARE GATE ---------------------------------------------------------------
  
  # CORRECT DIMENSIONS
  x <- cyto_gate_convert(x, channels = channels)

  # GATE CENTER ----------------------------------------------------------------
  
  # GATE CENTER X COORD
  if (.all_na(text_x)) {
    # 2D RECTANGLEGATE
    if(is(x, "rectangleGate")){
      gate_xmin <- x@min[channels[1]]
      gate_xmax <- x@max[channels[1]]
      # REPLACE INFINITE COORDS
      if(is.infinte(gate_xmin)){
        gate_xmin <- xmin
      }
      if(is.infinite(gate_xmax)){
        gate_xmax <- xmax
      }
      text_x <- (gate_xmin + gate_xmax)/2
    # 2D POLYGONGATE  
    }else{
      # COORDS
      coords <- x@boundaries[, channels[1]]
      # REPLACE INFINITE COORDS
      if(any(is.infinite(coords))){
        # -Inf
        if(coords[is.infinite(coords)] < 0){
          coords[is.infinite(coords)] <- xmin
        }
        # Inf
        if(coords[is.infinite(coords)] > 0){
          coords[is.inifinte(coords)] <- xmax
        }
      }
      text_x <- sum(coords) / length(coords)
    }
  }

  # GATE CENTER Y COORD
  if (.all_na(text_y)) {
    # 2D RECTANGLEGATE
    if(is(x, "rectangleGate")){
      gate_ymin <- x@min[channels[2]]
      gate_ymax <- x@max[channels[2]]
      # REPLACE INFINITE COORDS
      if(is.infinte(gate_ymin)){
        gate_ymin <- ymin
      }
      if(is.infinite(gate_ymax)){
        gate_ymax <- ymax
      }
      text_y <- (gate_ymin + gate_ymax)/2
      # 2D POLYGONGATE  
    }else{
      # COORDS
      coords <- x@boundaries[, channels[2]]
      # REPLACE INFINITE COORDS
      if(any(is.infinite(coords))){
        # -Inf
        if(coords[is.infinite(coords)] < 0){
          coords[is.infinite(coords)] <- ymin
        }
        # Inf
        if(coords[is.infinite(coords)] > 0){
          coords[is.inifinte(coords)] <- ymax
        }
      }
      text_y <- sum(coords) / length(coords)
    }
  }

  # RETURN GATE CENTER ---------------------------------------------------------

  # GATE CENTER MATRIX
  text_xy <- matrix(c(text_x, text_y),
    ncol = 2,
    byrow = FALSE
  )
  colnames(text_xy) <- c("x", "y")
  
  # RETUEN GATE CENTER MATRIX
  return(text_xy)
}

#' @noRd
.cyto_plot_label_center.ellipsoidGate <- function(x,
                                                  channels,
                                                  text_x = NA,
                                                  text_y = NA) {

  # GRAPHICAL PARAMETERS -------------------------------------------------------
  
  # PLOT LIMITS
  lims <- par("usr")
  
  # X LIMITS
  xmin <- lims[1]
  xmax <- lims[2]
  xpad <- ((xmax - xmin) - (xmax - xmin)/1.04)/2 # 2% BUFFER EITHER SIDE
  xmin <- xmin + 0.5 * xpad # 1% BUFFER
  xmax <- xmax - 0.5 * xpad # 1% BUFFER
  
  # Y LIMITS
  ymin <- lims[3]
  ymax <- lims[4]
  ypad <- ((ymax - ymin) - (ymax - ymin)/1.04)/2 # 2% BUFFER EITHER SIDE
  ymin <- ymin + 0.5 * ypad # 1% BUFFER
  ymax <- ymax - 0.5 * ypad # 1% BUFFER
  
  # PREPARE GATE ---------------------------------------------------------------
  
  # CORRECT DIMENSIONS
  x <- cyto_gate_convert(x, channels = channels)
  
  # GATE CENTER ----------------------------------------------------------------
  
  # GATE CENTER X COORD
  if(.all_na(text_x)){
    # 2D RECTANGLEGATE
    if(is(x, "rectangleGate")){
      gate_xmin <- x@min[channels[1]]
      gate_xmax <- x@max[channels[1]]
      # REPLACE INFINITE COORDS
      if(is.infinte(gate_xmin)){
        gate_xmin <- xmin
      }
      if(is.infinite(gate_xmax)){
        gate_xmax <- xmax
      }
      text_x <- (gate_xmin + gate_xmax)/2
    # ELLIPSOIDGATE
    }else{
      text_x <- x@mean[channels[1]]
    }
  }
  
  # GATE CENTER Y COORD
  if(.all_na(text_y)){
    # 2D RECTANGLEGATE
    if(is(x, "rectangleGate")){
      gate_ymin <- x@min[channels[2]]
      gate_ymax <- x@max[channels[2]]
      # REPLACE INFINITE COORDS
      if(is.infinte(gate_ymin)){
        gate_ymin <- ymin
      }
      if(is.infinite(gate_ymax)){
        gate_ymax <- ymax
      }
      text_y <- (gate_ymin + gate_ymax)/2
      # ELLIPSOIDGATE
    }else{
      text_y <- x@mean[channels[2]]
    }
  }

  # RETURN GATE CENTER ---------------------------------------------------------
  
  # GATE CENTER MATRIX
  text_xy <- matrix(c(text_x, text_y),
    ncol = 2,
    byrow = FALSE,
  )
  colnames(text_xy) <- c("x", "y")

  # RETURN GATE CENTER MATRIX
  return(text_xy)
}

#' @noRd
.cyto_plot_label_center.quadGate <- function(x,
                                             channels,
                                             text_x = NA,
                                             text_y = NA){
  
  # GRAPHICAL PARAMETERS -------------------------------------------------------
  
  # PLOT LIMITS
  lims <- par("usr")
  
  # X LIMITS
  xmin <- lims[1]
  xmax <- lims[2]
  xpad <- ((xmax - xmin) - (xmax - xmin)/1.04)/2 # 2% BUFFER EITHER SIDE
  xmin <- xmin + 0.5 * xpad # 1% BUFFER
  xmax <- xmax - 0.5 * xpad # 1% BUFFER
  
  # Y LIMITS
  ymin <- lims[3]
  ymax <- lims[4]
  ypad <- ((ymax - ymin) - (ymax - ymin)/1.04)/2 # 2% BUFFER EITHER SIDE
  ymin <- ymin + 0.5 * ypad # 1% BUFFER
  ymax <- ymax - 0.5 * ypad # 1% BUFFER
  
  # PREPARE GATE ---------------------------------------------------------------
  
  # CORRECT DIMENSIONS
  x <- cyto_gate_convert(x, channels = channels)
  
  # REPEAT ARGUMENTS -----------------------------------------------------------
  
  # QUADGATE - 4 CENTERS
  text_x <- rep(text_x, length.out = 4)
  text_y <- rep(text_y, length.out = 4)
  
  # QUADGATE CO-ORDINATES ------------------------------------------------------
  
  x_coord <- x@boundary[channels[1]]
  y_coord <- x@boundary[channels[2]]
  
  # LABEL CENTERS --------------------------------------------------------------
  
  # UPDATE MISSING LABEL CO-ORDINATES
  lapply(seq_len(4), function(z){
    # QUADRANT 1 - TOP RIGHT
    if(z == 1){
      # X COORD 
      if(.all_na(text_x[z])){
        text_x[z] <<- mean(c(x_coord, xmax))
      }
      # Y COORD
      if(.all_na(text_y[z])){
        text_y[z] <<- mean(c(y_coord, ymax))
      }
    # QUADRANT 2 - TOP LEFT
    }else if(z == 2){
      # X COORD 
      if(.all_na(text_x[z])){
        text_x[z] <<- mean(c(x_coord, xmin))
      }
      # Y COORD
      if(.all_na(text_y[z])){
        text_y[z] <<- mean(c(y_coord, ymax))
      }
    # QUADRANT 3 - BOTTOM RIGHT
    }else if(z == 3){
      # X COORD 
      if(.all_na(text_x[z])){
        text_x[z] <<- mean(c(x_coord, xmax))
      }
      # Y COORD
      if(.all_na(text_y[z])){
        text_y[z] <<- mean(c(y_coord, ymin))
      }
    # QUADRANT 4 - BOTTOM LEFT
    }else if(z == 4){
      # X COORD 
      if(.all_na(text_x[z])){
        text_x[z] <<- mean(c(x_coord, xmin))
      }
      # Y COORD
      if(.all_na(text_y[z])){
        text_y[z] <<- mean(c(y_coord, ymin))
      }
    }
  })
  
  # RETURN GATE CENTERS --------------------------------------------------------
  
  # GATE CENTERS MATRIX
  text_xy <- as.matrix(cbind(text_x, text_y))
  colnames(text_xy) <- c("x","y")
  
  # RETURN GATES CENTERS MATRIX
  return(text_xy)
  
}

#' @noRd
.cyto_plot_label_center.filters <- function(x,
                                            channels,
                                            text_x = NA,
                                            text_y = NA) {

  # LIST GATE OBJECTS ----------------------------------------------------------
  x <- unlist(x)

  # CALL LIST METHOD -----------------------------------------------------------
  text_xy <- .cyto_plot_label_center(x,
    channels = channels,
    text_x = text_x,
    text_y = text_y
  )

  # RETURN GATE CENTER MATRIX --------------------------------------------------
  return(text_xy)
}

#' @noRd
.cyto_plot_label_center.list <- function(x,
                                         channels,
                                         text_x = NA,
                                         text_y = NA) {

  # LIST GATE OBJECTS ----------------------------------------------------------
  
  x <- unlist(gate)
  
  # REPEAT ARGUMENTS -----------------------------------------------------------
  
  # GATE COUNT
  cnt <- c()
  lapply(gate_count, function(z){
    if(is(z, "quadGate")){
      cnt <- c(cnt, 4)
    }else{
      cnt <- c(cnt, 1)
    }
  })
  
  # REPEAT ARGUMENTS
  text_x <- rep_len(text_x, sum(cnt))
  text_y <- rep_len(text_y, sum(cnt))
  
  # SPLIT ARGUMENTS
  text_x <- split(text_x, rep(seq_len(length(x)), times = cnt))
  text_y <- split(text_y, rep(seq_len(length(x)), times = cnt))
  
  # GATE CENTERS ---------------------------------------------------------------
  
  # LIST GATE CENTER MATRICES
  text_xy <- mapply(function(x,
                             text_x,
                             text_y) {
    .cyto_plot_label_center(x,
      channels = channels,
      text_x = text_x,
      text_y = text_y
    )
  }, x,
  text_x,
  text_y,
  SIMPLIFY = FALSE
  )

  # GATE CENTER MATRIX
  text_xy <- do.call("rbind", text_xy)

  # RETURN GATE CENTER MATRIX
  return(text_xy)
}

# LABEL DIMENSIONS -------------------------------------------------------------

#' Get dimensions of labels for cyto_plot_label
#'
#' Labels should already contain statistic as well. Co-ordiante for each label
#' must already be computed.
#'
#' @importFrom graphics strwidth strheight
#'
#' @return upper left and bottom right x and y co-ordinates of labels
#'
#' @author Dillon Hammill (Dillon.Hammill@anu.edu.au)
#'
#' @noRd
.cyto_plot_label_dims <- function(text,
                                  text_x,
                                  text_y = NA,
                                  text_size = 1,
                                  xpad = 1.2,
                                  ypad = 1.2,
                                  adj = 0.5, ...) {

  # GRAPHICAL PARAMETERS -------------------------------------------------------
  
  # RESET CEX & XPD
  old_pars <- par(c("cex","xpd"))
  on.exit(par(old_pars))

  # SET CEX & XPD
  par(cex = text_size)
  par(xpd = TRUE)

  # LABEL DIMENSIONS -----------------------------------------------------------

  # BOX ADJUSTMENT
  box_adj <- adj + (xpad - 1) * text_size * (0.5 - adj)

  # BOX DIMENSIONS
  lwidths <- strwidth(text)
  rwidths <- lwidths * (1 - box_adj)
  lwidths <- lwidths * box_adj
  bheights <- theights <- strheight(text) * 0.5

  # BOX X COORDS
  xr <- text_x - lwidths * xpad
  xl <- text_x + lwidths * xpad

  # BOX Y COORDS
  yb <- text_y - bheights * ypad
  yt <- text_y + theights * ypad

  # LABEL DIMENSIONS MATRIX ----------------------------------------------------
  
  # MATRIX - TOP LEFT THEN BOTTOM RIGHT
  coords <- matrix(c(
    min(c(xl, xr)),
    max(c(yb, yt)),
    max(c(xl, xr)),
    min(c(yb, yt))
  ),
  ncol = 2,
  byrow = TRUE
  )
  colnames(coords) <- c("x", "y")

  # RETURN LABEL DIMENSIONS ----------------------------------------------------
  return(coords)
  
}

# LABEL OVERLAP ----------------------------------------------------------------

#' Check if any cyto_plot labels overlap
#'
#' @param x list of label dimensions.
#'
#' @return list of length x. Each element compares the label to all others and
#' returns TRUE if any overlap is detected. NA is returned when comparing the
#' same label co-ordinates.
#'
#' @author Dillon Hammill (Dillon.Hammill@anu.edu.au)
#'
#' @noRd
.cyto_plot_label_overlap <- function(x) {

  # For each rectangle in x
  overlaps <- lapply(seq_len(length(x)), function(y) {

    # Check if other rectangles overlap
    LAPPLY(seq_len(length(x)), function(z) {

      # Co-ordinates of reference label
      x1 <- x[[y]][, "x"]
      y1 <- x[[y]][, "y"]

      # Co-ordinates of comparison label
      x2 <- x[[z]][, "x"]
      y2 <- x[[z]][, "y"]

      # Return NA for same label
      if (z == y) {
        return(NA)
      }

      # X co-ordinates are overlapping
      if (min(x2) >= min(x1) & min(x2) <= max(x1) |
        max(x2) >= min(x1) & max(x2) <= max(x1)) {

        # Y co-ordinates are also overlapping
        if (min(y2) >= min(y1) & min(y2) <= max(y1) |
          max(y2) >= min(y1) & max(y2) <= max(y1)) {
          return(TRUE)
        } else {
          return(FALSE)
        }
      }

      # Non-overlapping x and y co-ordinates
      return(FALSE)
    })
  })

  return(overlaps)
}

# LABEL OFFSET --------------------------------------------------------------

#' Offset overlapping labels
#'
#' Label co-ordinates must be pre-calculated. This function checks for
#' overlapping labels given co-ordinates and offsets these co-ordinates
#' accordingly.
#'
#' @param text text to be included in the labels, must contain statistic if
#'   desired.
#' @param text_x vector of x co-ordinates for labels.
#' @param text_y vector of y co-ordinates for labels.
#' @param text_size vector of numerics to control the size of the text in each
#'   label. \code{text_size} is required to compute the dimensions of each of
#'   the labels.
#'
#' @author Dillon Hammill (Dillon.Hammill@anu.edu.au)
#'
#' @noRd
.cyto_plot_label_offset <- function(text,
                                    text_x,
                                    text_y,
                                    text_size){
  
  # GRAPHICAL PARAMETERS -------------------------------------------------------
  
  # PLOT LIMITS
  lims <- par("usr")
  ymin <- lims[3]
  ymax <- lims[4]
  yrng <- ymax - ymin
  ypad <- (yrng - yrng / 1.04) / 2
  ymin <- ymin + ypad
  ymax <- ymax - ypad
  yrng <- ymax - ymin
  
  # LABEL CO-ORDINATE MATRIX ---------------------------------------------------
  
  # MATRIX
  text_xy <- matrix(c(text_x, text_y),
                    ncol = 2,
                    byrow = FALSE)
  colnames(text_xy) <- c("x", "y")
  
  # LABEL DIMENSIONS -----------------------------------------------------------
  
  # COMPUTE LABEL DIMENSIONS
  label_dims <- mapply(function(text,
                                text_x,
                                text_y,
                                text_size){
    
    .cyto_plot_label_dims(text = text,
                          text_x = text_x,
                          text_y = text_y,
                          text_size = text_size)
    
  },
  text,
  text_x,
  text_y,
  text_size,
  SIMPLIFY = FALSE)
  
  # LABEL OVERLAP --------------------------------------------------------------
  
  # OVERLAPPING LABELS PRESENT?
  label_overlap <- any(na.omit(unlist(.cyto_plot_label_overlap(label_dims))))
  
  # LABEL OFFSET ---------------------------------------------------------------
  
  # COMPUTE OFFSET LABEL Y CO-ORDINATES
  if(label_overlap){
    # LABEL HEIGHT
    label_height <- LAPPLY(label_dims, function(z){
      max(z[, "y"]) - min(z[, "y"])
    })
    # USE MAX LABEL HEIGHT
    label_height <- max(label_height)
    # EXTRA BUFFERING
    label_height <- 1.18 * label_height
    # OFFSET Y COORDS
    text_xy[, "y"] <- .spread.labels(text_xy[, "y"],
                                     mindiff = label_height,
                                     min = ymin,
                                     max = ymax)
  }

  # RETURN OFFSET LABEL CO-ORDINATES -------------------------------------------
  
  # RETURN LABEL CO-ORDINATE MATRIX
  return(text_xy)
  
}
