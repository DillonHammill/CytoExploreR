# CYTO_SPILLOVER_COMPUTE -------------------------------------------------------

#' Compute Spillover Matrix
#'
#' \code{cyto_spillover_compute} uses the method described by Bagwell & Adams
#' 1993 to automatically calculate the fluorescent spillover matrix using single
#' stain compensation controls.
#'
#' \code{cyto_spillover_compute} supports spillover matrix calculation for both
#' internal or universal unstained reference populations based on channel
#' selection. The fluorescent channels of the compensation controls MUST be
#' appropriately transformed prior to using \code{cyto_spillover_compute} using
#' \code{cyto_transform}.
#'
#' \code{cyto_spillover_compute} begins by the user selecting which fluorescent
#' channel is associated with each compensation control from a dropdown menu.
#' The results of these selections are saved to a csv file called
#' "Compensation-Channels.csv" which can be passed to the \code{channel_match}
#' argument on subsequent runs to bypass the channel selection process.
#'
#' Following channel selection, \code{cyto_spillover_compute} runs through each
#' compensation control and plots the density distribution in the associated
#' channel. If an universal "Unstained" compensation control is supplied, the
#' unstained compensation control will be overlaid onto the plot as a reference
#' for gating. Users can then gate the positive signal for spillover calculation
#' using an interval gate. If no universal unstained compensation control is
#' supplied, users are expected to gate the negative and then the positive
#' signal for each compensation control.
#'
#' The percentage spillover is calculated based on the median fluorescent
#' intensities (MedFI) of the positive populations relative to that of the
#' reference negative population(s). The calculated spillover matrix is returned
#' and written to a named csv file for future use.
#'
#' @param x object of class \code{flowSet} or \code{GatingSet} containing
#'   pre-gated compensation controls with all fluorescent channels appropriately
#'   transformed using \code{cyto_transform}.
#' @param parent name of the population to use for the spillover calculation
#'   when a GatingSet object is supplied, set to the last node of the GatingSet
#'   by default (e.g. "Single Cells").
#' @param axes_trans object of class
#'   \code{\link[flowWorkspace:transformerList-class]{transformerList}}
#'   generated by a \code{cyto_transformer} which contains the transformer
#'   definitions used to transform the fluorescent channels of the compensation
#'   controls.
#' @param channel_match name of csv file to associate a fluorescent channel with
#'   each of the compensation controls. The \code{channel_match} file should
#'   contain a "name" column with the names of the compensation controls and a
#'   "channel" column to associate a fluorescent channel with each compensation
#'   control. Users need not generate this file by hand as it will be created
#'   following the channel selection process.
#' @param spillover name of the output spillover csv file, set to
#'   \code{"Spillover-Matrix.csv"} by default.
#' @param ... additional arguments passed to \code{\link{cyto_plot}}.
#'
#' @return spillover matrix and write spillover matrix to csv file named in
#'   accordance with \code{spillover}.
#'
#' @examples
#' library(CytoRSuiteData)
#'
#' # Bypass directory check for external files
#' options("CytoRSuite_wd_check" = FALSE)
#'
#' # Load in compensation controls
#' fs <- Compensation
#' gs <- GatingSet(Compensation)
#'
#' # Gate using cyto_gate_draw
#' gt <- Compensation_gatingTemplate
#' gating(gt, gs)
#'
#' # Channel match fille
#' cmfile <- system.file("extdata",
#'   "Compensation-Channels.csv",
#'   package = "CytoRSuiteData"
#' )
#'
#' # Compute fluorescent spillover matrix
#' spill <- spillover_compute(getData(gs, "Single Cells"),
#'   channel_match = cmfile,
#'   spillover = "Example-spillover.csv"
#' )
#'
#' # Compensate samples
#' gs <- compensate(gs, spill)
#'
#' # Return CytoRSuite_wd_check to default
#' options("CytoRSuite_wd_check" = TRUE)
#' @importFrom flowCore each_col fsApply sampleNames flowSet Subset
#' @importFrom flowWorkspace pData GatingSet
#' @importFrom methods as
#' @importFrom utils read.csv write.csv
#' @importFrom stats median
#' @importFrom tools file_ext
#'
#' @seealso \code{\link{cyto_spillover_edit}}
#'
#' @author Dillon Hammill, \email{Dillon.Hammill@anu.edu.au}
#'
#' @references C. B. Bagwell \& E. G. Adams (1993). Fluorescence spectral
#'   overlap compensation for any number of flow cytometry parameters. in:
#'   Annals of the New York Academy of Sciences, 677:167-184.
#'
#' @name cyto_spillover_compute
NULL

#' @noRd
#' @export
cyto_spillover_compute <- function(x, ...) {
  UseMethod("cyto_spillover_compute")
}

#' @rdname cyto_spillover_compute
#' @export
cyto_spillover_compute.flowSet <- function(x,
                                           axes_trans = NULL,
                                           channel_match = NULL,
                                           spillover = "Spillover-Matrix.csv",
                                           ...) {

  # Compensation controls MUST be pre-transformed
  if (is.null(axes_trans)) {
    stop(
      paste(
        "Fluorescent channels MUST be transformed. Supply the",
        "transformerList to 'axes_trans'."
      )
    )
  }

  # Extract pData information
  pd <- cyto_details(x)

  # Extract fluorescent channels
  channels <- cyto_fluor_channels(x)

  # Select a fluorescent channel for each compensation control
  if (is.null(channel_match)) {
    pd$channel <- paste(cyto_channel_select(x))
    write.csv(pd, "Compensation-Channels.csv", row.names = FALSE)
  } else {
    if (inherits(channel_match, "data.frame") |
      inherits(channel_match, "matrix") |
      inherits(channel_match, "tibble")) {
      if (!all(c("name", "channel") %in% colnames(channel_match))) {
        stop("channel_match should contains columns 'name' and 'channel'.")
      }
      cm <- channel_match
      chans <- cm$channel[match(cyto_names(x), rownames(cm))]
      pd$channel <- paste(chans)
    } else {
      if (getOption("CytoRSuite_wd_check") == TRUE) {
        if (file_wd_check(channel_match)) {
          cm <- read.csv(channel_match, header = TRUE, row.names = 1)
          chans <- cm$channel[match(cyto_names(x), row.names(cm))]
          pd$channel <- paste(chans)
        } else {
          stop(paste(channel_match, "is not in this working directory."))
        }
      } else {
        cm <- read.csv(channel_match, header = TRUE, row.names = 1)
        chans <- cm$channel[match(cyto_names(x), row.names(cm))]
        pd$channel <- paste(chans)
      }
    }
  }

  # Universal reference population
  if ("Unstained" %in% pd$channel) {

    # Extract unstained control based on selected channels in pData(x)
    NIL <- x[[match("Unstained", pd$channel)]]
    x <- x[-match("Unstained", pd$channel)]

    # Names
    nms <- cyto_names(x)

    # Samples
    smp <- length(x)

    # Remove NIL from pd
    pd <- pd[!pd$channel == "Unstained", ]

    # Gate positive populations
    pops <- lapply(seq(1, smp, 1), function(z) {

      # Extract flowFrame
      fr <- x[[z]]

      # Channel
      chan <- pd$channel[z]

      # Plot
      cyto_plot(NIL,
        channels = chan,
        overlay = fr,
        density_stack = 0,
        axes_trans = axes_trans,
        popup = TRUE,
        density_fill = c("red", "dodgerblue"),
        legend = FALSE,
        density_fill_alpha = 0.6,
        title = nms[z], ...
      )

      # Call cyto_gate_draw on each flowFrame using interval gate on selected channel
      gt <- cyto_gate_draw(
        x = fr,
        alias = paste(chan, "+"),
        channels = chan,
        type = "interval",
        plot = FALSE
      )
      fr <- Subset(fr, gt[[1]])

      return(fr)
    })
    names(pops) <- nms
    pops <- flowSet(pops)

    # Calculate medFI for all channels unstained control
    neg <- cyto_stats_compute(NIL,
                              trans = axes_trans,
                              stat = "median",
                              channels = channels,
                              format = "wide")
    colnames(neg) <- channels
    neg <- neg[, channels]
    
    # Calculate medFI for all channels in all stained controls
    pos <- cyto_stats_compute(pops,
                              trans = axes_trans,
                              stat = "median",
                              channels = channels,
                              format = "wide")
    colnames(pos) <- channels
    pos <- pos[, channels]
    pos <- data.matrix(pos)
    rownames(pos) <- nms

    # Subtract background fluorescence
    signal <- sweep(pos, 2, neg)

    # Internal reference population
  } else if (!"Unstained" %in% pd$channel) {

    # Each control has its own positive and negative population
    
    # Names
    nms <- cyto_names(x)
    
    # Samples
    smp <- length(x)
    
    # List of negative populations
    neg_pops <- list()
    
    # List of positive populations
    pos_pops <- list()
    
    # Gate positive and negative populations for each control
    lapply(seq(1, smp, 1), function(z) {
      
      # Extract flowFrame
      fr <- x[[z]]
      
      # Channel
      chan <- pd$channel[z]
      
      # Plot
      cyto_plot(fr,
                channels = chan,
                density_stack = 0,
                axes_trans = axes_trans,
                popup = TRUE,
                density_fill = "dodgerblue",
                legend = FALSE,
                density_fill_alpha = 0.6,
                title = nms[z], ...
      )
      
      # Gate negative population
      gt <- cyto_gate_draw(
        x = fr,
        alias = paste(chan, "-"),
        channels = chan,
        type = "interval",
        plot = FALSE
      )
      neg_pops[[z]] <<- Subset(fr, gt[[1]])
      
      # Gate positive population
      gt <- cyto_gate_draw(
        x = fr,
        alias = paste(chan, "+"),
        channels = chan,
        type = "interval",
        plot = FALSE
      )
      pos_pops[[z]] <<- Subset(fr, gt[[1]])
      
    })
    
    # Add names to pops lists
    names(neg_pops) <- nms
    names(pos_pops) <- nms
    
    # Convert neg_pops and pos_pops to flowSets
    neg_pops <- flowSet(pos_pops)
    pos_pops <- flowSet(pos_pops)
    
    # Calculate medFI for negative populations
    neg <- cyto_stats_compute(neg_pops,
                              trans = axes_trans,
                              stat = "median",
                              channels = channels,
                              format = "wide")
    colnames(neg) <- channels
    neg <- neg[, channels]
    neg <- data.matrix(neg)
    rownames(neg) <- nms
    
    # Calculate medFI for all channels in all stained controls
    pos <- cyto_stats_compute(pos_pops,
                              trans = axes_trans,
                              stat = "median",
                              channels = channels,
                              format = "wide")
    colnames(pos) <- channels
    pos <- pos[, channels]
    pos <- data.matrix(pos)
    rownames(pos) <- nms
    
    # Subtract background fluorescence
    signal <- pos - neg
  
  }
  
  # Construct spillover matrix - include values for which there is a control
  spill <- diag(x = 1, nrow = length(channels), ncol = length(channels))
  colnames(spill) <- channels
  rownames(spill) <- channels
    
  # Normalise each row to stained channel
  lapply(seq(1, nrow(signal), 1), function(y) {
    signal[y, ] <<- signal[y, ] /
      signal[y, match(pd$channel[y], colnames(spill))]
  })
    
  # Insert values into appropriate rows
  rws <- match(pd$channel, rownames(spill))
  spill[rws, ] <- signal
    
  # write spillover matrix to csv file
  if (!inherits(spillover, "character")) {
    stop("'spillover' should be the name of a csv file.")
  } else {
    if (!file_ext(spillover) == "csv") {
      paste0(spillover, ".csv")
    }
    write.csv(spill, spillover)
  }

  return(spill)
}

#' @rdname cyto_spillover_compute
#' @export
cyto_spillover_compute.GatingSet <- function(x,
                                             parent = NULL,
                                             axes_trans = NULL,
                                             channel_match = NULL,
                                             spillover = "Spillover-Matrix.csv",
                                             ...) {

  # No parent supplied - use last node
  if (is.null(parent)) {
    parent <- cyto_nodes(x)[length(cyto_nodes(x))]
  }

  # Extract Population for Downstream Analyses
  fs <- cyto_extract(x, parent)

  # Transformations are always extracted from GatingSet - ignore axes_trans
  transformer_list <- x@transformation[[1]]
    
  # Compensation controls MUST be transformed for gating
  if (length(transformer_list) == 0) {
    stop("Transform ALL fluorescent channels using cyto_transform().")
  }

  # Make call to flowSet method
  spill <- cyto_spillover_compute(
    x = fs,
    axes_trans = transformer_list,
    channel_match = channel_match,
    spillover = spillover, ...
  )

  # Return spillover matrix
  return(spill)
}
