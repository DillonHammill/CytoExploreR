## CYTO_SPILLOVER_COMPUTE ------------------------------------------------------

#' Compute Spillover Matrix
#'
#' \code{cyto_spillover_compute} automatically computes the fluorescent
#' spillover matrix for a set of single colour compensation controls using
#' either the method proposed by Bagwell et al. (1993) or the more recent method
#' proposed by Roca et al. (2021).
#'
#' The method proposed by Roca et al. (2021) is now the default method, and has
#' been implemented in \code{cyto_spillover_compute} as a fully automated
#' algorithm to compute the spillover matrix. Users simply need to ensure that
#' the channel associated with each control is annotated in the
#' \code{cyto_details()} of the supplied data.
#'
#' The method proposed by Bagwell et al. (1993) is also supported but is
#' implemented as a semi-automated approach as it requires gating of the
#' positive and negative signal within each single colour control to accurately
#' compute the spillover coefficients. Gating is performed on a per channel
#' basis with the user manually drawing interval gates around the positive and
#' negative signal for each control. If a universal unstained control is
#' supplied, users are only asked to gate the positive signal for each control
#' and the unstained control will be used as the reference for the negative
#' signal in each channel.
#'
#' The computed spillover is returned as a matrix and exported as a csv file
#' specified by the \code{save_as} argument. To assess the quality of the
#' compensation, refer to \code{\link{cyto_spillover_edit}} and
#' \code{\link{cyto_plot_compensation}}. Users can apply their computed
#' spillover matrices to their samples using \code{\link{cyto_compensate}}.
#'
#' @param x object of class \code{\link[flowCore:flowSet-class]{flowSet}} or
#'   \code{\link[flowWorkspace:GatingSet-class]{GatingSet}} containing
#'   transformed and gated compensation controls.
#' @param parent name of the population to use for the spillover calculation
#'   when a GatingSet object is supplied, set to the last node of the GatingSet
#'   by default (e.g. "Single Cells"). For greater flexibility, users can
#'   specify a parent population for each control, which will be extracted for
#'   the spillover calculation (e.g. Lymphocytes for CD4 APC or Myeloid Cells
#'   for CD11b FITC). The parent populations for each control can also be
#'   specified in a \code{parent} column in the channel match CSV file or in
#'   \code{cyto_details}.
#' @param select passed to \code{\link{cyto_select}} to select the samples
#'   required to compute the spillover matrix.
#' @param channels names of the channels or markers for which spillover
#'   coefficients should be computed, set to all area fluorescent channels by
#'   default.
#' @param type options include \code{"Bagwell"}, \code{"Roca"} or
#'   \code{"hybrid"} to indicate which method to use when computing the
#'   spillover matrix, set to \code{"Roca"} by default. The \code{"hybrid"}
#'   method computes the spillover coefficients using the \code{Bagwell}
#'   approach (no RLM) and refines the coefficients using the \code{Autospill}
#'   approach. Refer to \code{references} section for more details about each
#'   method.
#' @param save_as name of a csv file to which the computed spillover matrix
#'   should be written, set to \code{Spillover-Matrix.csv} prefixed with the
#'   date by default.
#' @param gatingTemplate name of \code{gatingTemplate} csv file to which the
#'   \code{gatingTemplate} entries for the \code{GatingSet} method should be
#'   saved, set to \code{cyto_gatingTemplate_active()} by default.
#' @param axes_trans object of class
#'   \code{\link[flowWorkspace:transformerList]{transformerList}} generated by a
#'   \code{cyto_transformer} which contains the transformer definitions used to
#'   transform the data. Transformer definitions are only required when a
#'   flowSet object is supplied.
#' @param axes_limits options include \code{"auto"}, \code{"data"} or
#'   \code{"machine"} to use optimised, data or machine limits respectively. Set
#'   to \code{"machine"} by default to use entire axes ranges. Fine control over
#'   axes limits can be obtained by altering the \code{xlim} and \code{ylim}
#'   arguments.
#' @param spillover superseded by the \code{save_as} argument above, only
#'   included for backwards compatibility with older versions of CytoExploreR.
#' @param heatmap logical indicating whether the computed spillover matrix
#'   should be displayed in a heatmap, set to TRUE by default.
#' @param events number of events to extract from each control prior to fitting
#'   RLM models, set to 500 events by default.
#' @param iter indicates the maximum number of allowable iterations for refining
#'   the spillover coefficients, set to 100 by default.
#' @param trim proportion of events to exclude from the top and bottom of each
#'   scale when fitting RLM models in autospill method, set to 0.001 by default.
#' @param ... additional arguments passed to \code{\link{cyto_plot}}.
#'
#' @return spillover matrix and write spillover matrix to csv file named in
#'   accordance with \code{spillover}.
#'
#' @importFrom flowWorkspace cytoset
#' @importFrom openCyto mindensity gs_add_gating_method
#' @importFrom flowWorkspace gs_pop_remove
#' @importFrom HeatmapR heat_map
#'
#' @examples
#' \dontrun{
#' library(CytoExploreRData)
#'
#' # Bypass directory check for external files
#' options("CytoExploreR_wd_check" = FALSE)
#'
#' # Load in compensation controls
#' fs <- Compensation
#' gs <- GatingSet(Compensation)
#'
#' # Gate using cyto_gate_draw
#' gt <- Compensation_gatingTemplate
#' cyto_gatingTemplate_apply(gs, gt)
#'
#' # Channel match fille
#' cmfile <- system.file("extdata",
#'   "Compensation-Channels.csv",
#'   package = "CytoExploreRData"
#' )
#'
#' # Compute fluorescent spillover matrix
#' spill <- cyto_spillover_compute(cyto_extract(gs, "Single Cells"),
#'   channel_match = cmfile,
#'   spillover = "Example-spillover.csv"
#' )
#'
#' # Compensate samples
#' gs <- cyto_compensate(gs, spill)
#'
#' # Return CytoExploreR_wd_check to default
#' options("CytoExploreR_wd_check" = TRUE)
#' }
#'
#' @seealso \code{\link{cyto_channel_match}}
#' @seealso \code{\link{cyto_spillover_edit}}
#' @seealso \code{\link{cyto_plot_compensation}}
#' @seealso \code{\link{cyto_compensate}}
#'
#' @author Dillon Hammill, \email{Dillon.Hammill@anu.edu.au}
#'
#' @references C. B. Bagwell & E. G. Adams (1993). Fluorescence spectral overlap
#'   compensation for any number of flow cytometry parameters. in: Annals of the
#'   New York Academy of Sciences, 677:167-184.
#'
#' @references Roca et al. (2021). AutoSpill is a principled framework that
#'   simplifies the analysis of multichromatic flow cytometry data. Nature
#'   Communications 12(2890).
#'
#' @export
cyto_spillover_compute <- function(x,
                                   parent = "root",
                                   select = NULL,
                                   channels = NULL,
                                   type = "roca",
                                   save_as = NULL,
                                   gatingTemplate = NULL,
                                   axes_trans = NA,
                                   axes_limits = "machine",
                                   spillover = NULL,
                                   heatmap = TRUE,
                                   events = 500,
                                   iter = 100,
                                   trim = 0.001,
                                   ...) {

  # TODO: SAMPLE CHECKS PERFORMED PRIOR TO GROUPING
  # FITC ON BEADS AND CELLS - BOTH KEPT 
  
  # TODO: SELECT ARGUMENT AND GATE STORAGE ISSUES - XSUB?
  
  # SPILLOVER ------------------------------------------------------------------
  
  # BACKWARDS COMPATIBILITY
  if(!is.null(spillover)) {
    warning(
      paste0(
        "'spillover' is now deprecated in favour of 'save_as' - ",
        "please use that argument instead."
      )
    )
    save_as <- spillover
  }
  
  # CHANNEL_MATCH DEPRECIATED
  if("channel_match" %in% names(list(...))) {
    stop(
      paste0(
        "'channel_match' is no longer supported. CytoExploreR will ",
        "automatically create and search for a file called ",
        "'Compensation-Details.csv'."
      )
    )
  }
  
  # PREPARE DATA ---------------------------------------------------------------
  
  # SELECT CONTROLS
  x <- cyto_select(
    x,
    select
  )
  
  # CHANNELS
  if(is.null(channels)) {
    channels <- cyto_fluor_channels(x)
    # DEFAULT - ALL AREA PARAMETERS
    channels <- channels[
      grepl(
        "\\-A$",
        channels,
        ignore.case = TRUE
      )
    ]
  } else {
    channels <- unique(cyto_channels_extract(x, channels))
  }
  
  # MATCH CHANNELS
  pd <- cyto_channel_match(
    x,
    channels = channels
  )
  pd <- pd[match(rownames(cyto_details(x)), rownames(pd)), , drop = FALSE]
  
  # CHECK COMPENSATION DETAILS
  lapply(
    seq_len(nrow(pd)),
    function(z) {
      # CHANNEL
      if(!pd$channel[z] %in% c("Unstained",
                               "unstained",
                               cyto_channels(x))) {
        stop(
          paste0(
            pd$channel[z], 
            " is not a valid channel for this ", 
            cyto_class(x), 
            "!"
          )
        )
      }
      # PARENT
      if(cyto_class(x, "GatingSet")) {
        cyto_nodes_convert(x, pd$parent[z]) # ERRORS IF MISSING
      }
    }
  )
  
  # MISSING VARIABLES
  vars <- c("name", "group", "parent", "channel")
  if(!all(vars %in% colnames(pd))) {
    stop(
      paste0(
        "cyto_details(x) is missing required variables: ",
        paste0(
          vars[!vars %in% colnames(pd)],
          collapse = " & "
        )
      )
    )
  }
  
  # TRANSFORMATIONS
  if(.all_na(axes_trans)) {
    axes_trans <- cyto_transformers_extract(x)
  }
  
  # DECOMPENSATE
  if(cyto_class(x, "GatingSet")) {
    if(!is.null(cyto_spillover_extract(x))) {
      x <- cyto_compensate(
        x,
        remove = TRUE,
        quiet = TRUE
      )
    }
  }
  
  # BAGWELL METHOD REQUIRES TRANSFORMED DATA
  if(grepl("^b|^h", type, ignore.case = TRUE)) {
    if(any(!channels %in% names(axes_trans))) {
      # DEFINE NEW TRANSFORMERS
      trans_new <- cyto_transformers_define(
        x, 
        channels = channels[!channels %in% names(axes_trans)],
        type = "biex",
        plot = FALSE,
        progress = FALSE
      )
      # APPLY NEW TRANSFORMERS
      x <- suppressWarnings(
        cyto_transform(
          x,
          trans = trans_new,
          copy = TRUE,
          plot = FALSE,
          quiet = TRUE
        )
      )
      # COMBINE TRANSFROMERS
      if(.all_na(axes_trans)) {
        axes_trans <- trans_new
      } else {
        axes_trans <- cyto_transformers_combine(axes_trans, trans_new)
      }
    }
  }
  
  # RESTRICT TRANSFORMERS TO CHANNELS
  if(!.all_na(axes_trans)) {
    if(any(channels %in% names(axes_trans))) {
      axes_trans <- cyto_transformers_combine(
        axes_trans[names(axes_trans) %in% channels]
      )
    } else {
      axes_trans <- NA
    }
  }
  
  # SPILLOVER TEMPLATE
  spill_mat <- matrix(
    0,
    ncol = length(channels),
    nrow = length(channels),
    dimnames = list(unname(channels), unname(channels))
  )
  diag(spill_mat) <- 1
  
  # PREPARE GATINGTEMPLATE -----------------------------------------------------
  
  # STORE GATES FOR BAGWELL & HYBRID METHODS
  if(cyto_class(x, "GatingSet") & grepl("^(b|h)", type, ignore.case = TRUE)) {
    # ACTIVE GATINGTEMPLATE
    if(is.null(gatingTemplate)) {
      gatingTemplate <- cyto_gatingTemplate_active(
        ask = TRUE
      )
    }
    # CREATE GATINGTEMPLATE
    if(!file_exists(gatingTemplate)) {
      cyto_gatingTemplate_create(
        gatingTemplate,
        active = TRUE
      )
    }
    # READ GATINGTEMPLATE
    gt <- cyto_gatingTemplate_read(
      gatingTemplate,
      data.table = TRUE
    )
  }
  
  # GATED POPULATIONS ----------------------------------------------------------
  
  # EXTRACT NODES FROM GATINGSET
  if(cyto_class(x, "GatingSet")) {
    nodes <- cyto_nodes(
      x,
      path = "auto"
    )
  } else {
    nodes <- NULL
  }
  
  # SPILLOVER COMPUTATION ------------------------------------------------------
  
  # BAGWELL METHOD
  if(grepl("^b|^h", type, ignore.case = TRUE)) {
    
    # NOTE: CS - LIST PER CONTROL WITH NEGATIVE & POSITIVE EVENTS
    
    # MESSAGE
    message(
      "Computing spillover matrix using the Bagwell et al. (1993) method... \n"
    )
    # REFERENCE
    message(
      paste0(
        "C. B. Bagwell & E. G. Adams (1993). Fluorescence spectral ",
        "overlap compensation for any number of flow cytometry parameters. in:",
        " Annals of the New York Academy of Sciences, 677:167-184.", "\n"
      )
    )
    
    # SPLIT SAMPLES INTO GROUPS
    cs_list <- cyto_group_by(
      x,
      group_by = "group"
    )
    
    # PREPARE EACH GROUP
    pd_list <- list()
    cs_list <- structure(
      lapply(
        seq_along(cs_list),
        function(w) {
          # CYTOSET
          cs <- cs_list[[w]]
          # GROUP DETAILS
          pd <- cyto_details(cs)
          # UNSTAINED INDEX
          unst_ind <- c()
          # SINGLE COLOUR INDEX
          comp_ind <- c()
          # GET INDEX OF CONTROLS AND UNSTAINED FOR GROUP
          lapply(
            unique(pd$channel),
            function(z) {
              # FIND BEST CONTROL PER CHANNEL
              ind <- which(pd$channel == z)
              # UNSTAINED CONTROL
              if(grepl("unstained", z, ignore.case = TRUE)) {
                # MULTIPLE UNSTAINED CONTROLS - CV
                if(length(ind) > 1) {
                  # CHANNELS TO COMPUTE CV
                  chans <- pd$channel[
                    !grepl(
                      "Unstained",
                      pd$channel,
                      ignore.case = TRUE
                    )
                  ]
                  # COMPUTE CV IN CHANNELS - PARENT
                  cv <- lapply(
                    ind, 
                    function(i) {
                      cyto_apply(
                        cs[i],
                        parent = pd$parent[i],
                        FUN = "cyto_stat_cv",
                        channels = channels,
                        input = "matrix",
                        trans = axes_trans,
                        inverse = TRUE,
                        copy = TRUE, 
                        simplify = FALSE
                      )
                    }
                  )
                  unst_ind <<- ind[
                    which.min(
                      LAPPLY(cv, "mean")
                    )
                  ]
                } else {
                  unst_ind <<- ind
                }
              # SINGLE COLOUR CONTROL
              } else {
                # MULTIPLE SINGLE COLOUR CONTROLS - MEDFI
                if(length(ind) > 1) {
                  # COMPUTE MEDFI IN CHANNEL - PARENT
                  medFI <- LAPPLY(
                    ind,
                    function(i) {
                      cyto_apply(
                        cs[i],
                        parent = pd$parent[i],
                        FUN = "cyto_stat_median",
                        channels = z,
                        input = "matrix",
                        trans = axes_trans,
                        inverse = TRUE,
                        copy = TRUE, 
                        simplify = TRUE
                      )
                    }
                  )
                  comp_ind <<- c(comp_ind, ind[
                    which.max(medFI)
                  ])
                } else {
                  comp_ind <<- c(comp_ind, ind)
                }
              }
            }
          )
          # STORE EXPERIMENT DETAILS PER GROUP
          pd_list[[names(cs_list)[w]]] <<- pd[comp_ind, ,drop = FALSE]
          # NOTE: IF UNSTAINED MISSING IN GROUP USER MUST GATE + AND - SIGNAL
          # IN EACH CONTROL
          # LIST OF POSITIVE & NEGATIVE CYTOFRAMES PER CHANNEL
          structure(
            lapply(
              comp_ind,
              function(v) {
                structure(
                  list(
                    "-" = if(length(unst_ind) == 0) {
                      NULL
                    } else {
                      cyto_data_extract(
                        cs,
                        select = unst_ind,
                        parent = pd$parent[v], # USE UNSTAINED POP HERE?
                        format = "cytoset",
                        inverse = FALSE,
                        copy = FALSE,
                        events = events
                      )[[1]]
                    },
                    "+" = cyto_data_extract(
                      cs,
                      select = v,
                      parent = pd$parent[v],
                      format = "cytoset",
                      inverse = FALSE,
                      copy = FALSE,
                      events = events
                    )[[1]]
                  )
                )
              }
            ),
            names = pd$channel[comp_ind]
          )
        }
      ),
      names = names(cs_list)
    )
    
    # GATE POPULATIONS & COMPUTE SPILLOVER COEFFICIENTS
    spill <- structure(
      lapply(
        seq_along(cs_list),
        function(q) {
          # EXPERIMENT DETAILS
          pd <- pd_list[[q]]
          # GATE POPULATIONS PER CHANNEL
          pops <- structure(
            lapply(
              names(cs_list[[q]]),
              function(y) {
                # PARENT
                parent <- pd[pd$channel %in% y, "parent"]
                # ESCAPED CHANNEL NAME - GATINGSET STORAGE
                chan <- gsub(
                  "[\\|\\&|\\:|\\,|\\/]",
                  "",
                  y
                )
                # POPULATION NAMES
                pops <- c(
                  paste0(chan, "-"),
                  paste0(chan, "+")
                )
                # REFERENCE CYTOSETS
                neg_events <- cs_list[[q]][[y]][["-"]]
                pos_events <- cs_list[[q]][[y]][["+"]]
                # EXTRACT GATES FROM GATINGSET
                if(cyto_class(x, "GatingSet")) {
                  # LOCATE NEGATIVE GATE
                  neg_ind <- grep(pops[1], nodes)
                  # NO NEGTAIVE GATE LOCATED
                  if(length(neg_ind) == 0) {
                    neg_gt <- NULL
                  # NEGATIVE GATE LOCATED
                  } else {
                    neg_gt <- cyto_gate_extract(
                      x,
                      select = cyto_names(
                        cs_list[[q]][[y]][["+"]]
                      ),
                      parent = parent,
                      alias = nodes[
                        grep(paste0(chan, "\\-"), nodes)
                      ]
                    )[[1]][[1]]
                  }
                  # LOCATE POSITIVE GATE
                  pos_ind <- grep(pops[2], nodes)
                  # NO POSITIVE GATE LOCATED
                  if(length(pos_ind) == 0) {
                    pos_gt <- NULL
                  # POSITIVE GATE LOCATED
                  } else {
                    # EXTRACT POSITIVE GATE
                    pos_gt <- cyto_gate_extract(
                      x,
                      select = cyto_names(
                        cs_list[[q]][[y]][["+"]]
                      ),
                      alias = nodes[
                        grep(paste0(chan, "\\+"), nodes)
                      ]
                    )[[1]][[1]]
                  }
                }
                # COMBINE GATES FOR PLOTTING
                gts <- structure(
                  list(
                    neg_gt,
                    pos_gt
                  ),
                  names = pops
                )
                # REMOVE MISSING GATES
                gts[LAPPLY(gts, "is.null")] <- NULL
                # CYTO_PLOT
                cyto_plot(
                  if(is.null(neg_events)){
                    pos_events
                  } else {
                    neg_events
                  },
                  channels = y,
                  overlay = if(!is.null(neg_events)){
                    pos_events
                  } else {
                    NA
                  },
                  gate = if(!is.null(gts)) {
                    gts
                  } else {
                    NA
                  },
                  hist_stack = 0,
                  hist_fill = if(is.null(neg_events)){
                    "dodgerblue"
                  } else {
                    c("red", "dodgerblue")
                  },
                  hist_fill_alpha = 0.6,
                  title = cyto_names(pos_events),
                  axes_limits = axes_limits, 
                  axes_trans = axes_trans,
                  legend = FALSE,
                  ...
                )
                # INTERACTIVE - USE CYTO_GATE_DRAW()
                if(interactive() & cyto_option("CytoExploreR_interactive")) {
                  # GATE NEGATIVE POPULATION
                  if(is.null(neg_events) & is.null(neg_gt)) {
                    neg_gt <- cyto_gate_draw(
                      x = pos_events,
                      alias = paste0(y, "-"),
                      channels = y,
                      type = "interval",
                      plot = FALSE
                    )[[1]][[1]]
                    neg_gt@filterId <- pops[1]
                  } else {
                    neg_gt <- NULL
                  }
                  # GATE POSITIVE POPULATION
                  if(is.null(pos_gt)) {
                    pos_gt <- cyto_gate_draw(
                      x = pos_events,
                      alias = paste0(y, "+"),
                      channels = y,
                      type = "interval",
                      plot = FALSE
                    )[[1]][[1]]
                    pos_gt@filterId <- pops[2]
                  }
                # NON-INTERACTIVE - USE MINDENSITY()
                } else {
                  # COMPUTE RANGE TO ELIMINATE OUTLIERS
                  rng <- cyto_apply(
                    pos_events,
                    FUN = "cyto_stat_quantile",
                    probs = c(0.025, 0.975),
                    input = "matrix",
                    channels = y,
                    copy = FALSE,
                    inverse = FALSE
                  )
                  # GATE NEGATIVE POPULATION
                  if(is.null(neg_events) & is.null(neg_gt)) {
                    # MINDENSITY - GATE NEGATIVE EVENTS
                    neg_gt <- mindensity(
                      pos_events[[1]], # CYTOFRAME REQUIRED
                      channel = y,
                      filterId = pops[1],
                      positive = FALSE,
                      min = min(rng),
                      max = max(rng)
                    )
                    # PLOT GATE
                    cyto_plot_gate(
                      neg_gt
                    )
                  } else {
                    neg_gt <- NULL
                  }
                  # MINDENSITY - GATE POSITIVE EVENTS
                  if(is.null(pos_gt)) {
                    pos_gt <- mindensity(
                      pos_events[[1]], # CYTOFRAME REQUIRED
                      channel = y,
                      filterId =pops[2],
                      positive = TRUE,
                      min = min(rng),
                      max = max(rng)
                    )
                    # PLOT GATE
                    cyto_plot_gate(
                      pos_gt
                    )
                  }
                }
                # APPLY GATES TO GATINGSET & STORE IN GATINGTEMPLATE
                if(cyto_class(x, "GatingSet")) {
                  # ADD NEW GATES TO GATINGSET & GATINGTEMPLATE
                  lapply(
                    pops[!pops %in% names(gts)],
                    function(r) {
                      # NEGATIVE GATE OPTIONAL
                      pop_gt <- if(grepl("\\-$", r)) {
                        neg_gt
                      } else {
                        pos_gt
                      }
                      # ADD NEW GATES - BYPASS NULL NEGATIVE GATE
                      if(!is.null(pop_gt)) {
                        # GATINGTEMPLATE
                        gt <<- rbind(
                          gt,
                          .suppress_all_messages(
                            gs_add_gating_method(
                              gs = x,
                              alias = r,
                              parent = parent,
                              pop = "+",
                              dims = y,
                              gating_method = "cyto_gate_draw",
                              gating_args = list(
                                gate = list(
                                  "Combined Events" = filters(
                                    if(grepl("\\-$", r)) {
                                      list(
                                        neg_gt
                                      )
                                    } else {
                                      list(
                                        pos_gt
                                      )
                                    }
                                  )
                                  
                                ),
                                openCyto.minEvents = -1
                              ),
                              groupBy = NA,
                              collapseDataForGating = TRUE,
                              preprocessing_method = "pp_cyto_gate_draw"
                            )
                          )
                        )
                      }
                    }
                  )
                  # WRITE UPDATED GATINGTEMPLATE - WRITING ERROR - SYNC GS
                  tryCatch(
                    cyto_gatingTemplate_write(
                      gt,
                      gatingTemplate
                    ),
                    error = function(e) {
                      
                      gs_pop_remove(
                        x,
                        r
                      )
                    }
                  )
                }
                # RETURN GATED POSITIVE/NEGATIVE POPULATIONS
                return(
                  list(
                    "-" = if(!is.null(neg_gt)) {
                      cyto_gate_apply(
                        pos_events,
                        neg_gt
                      )[[1]][[1]] # LIST OF POPULATIONS PER GATE
                    } else {
                      neg_events
                    },
                    "+" = cyto_gate_apply(
                      pos_events,
                      pos_gt
                    )[[1]][[1]] # LIST OF POPULATIONS PER GATE
                  )
                )
              }
            ),
            names = names(cs_list[[q]])
          )
          # STORE GATED POPULATIONS IN CS_LIST
          cs_list[[q]] <<- pops
          # COMPUTE SPILLOVER COEFFICIENTS PER CHANNEL
          sp <- do.call(
            "rbind",
            lapply(
              names(pops), 
              function(w){
                # TODO: QUANTILE RESTRICTION?
                # COMPUTE NEGATIVE STATS
                neg_stats <- cyto_apply(
                  pops[[w]][["-"]],
                  channels = channels,
                  FUN = "cyto_stat_median",
                  input = "matrix",
                  trans = axes_trans,
                  inverse = TRUE,
                  copy = TRUE,
                  simplify = FALSE
                )[[1]]
                # COMPUTE POSITIVE STATS
                pos_stats <- cyto_apply(
                  pops[[w]][["+"]],
                  channels = channels,
                  FUN = "cyto_stat_median",
                  input = "matrix",
                  trans = axes_trans,
                  inverse = TRUE,
                  copy = TRUE,
                  simplify = FALSE
                )[[1]]
                # SUBTRACT BACKGROUND
                coef <- pos_stats - neg_stats
                # NORMALISE
                return(as.numeric(coef/coef[w]))
              }
            )
          )
          rownames(sp) <- names(pops)
          colnames(sp) <- channels
          return(sp)
        }
      ),
      names = names(cs_list)
    )
    
    # SPILLOVER MATRIX - SINGLE GROUP
    if(length(spill) == 1) {
      spill <- spill[[1]]
    # SPILLOVER MATRIX - MULTIPLE GROUPS - DUPLICATE CHANNELS?
    } else {
      spill <- do.call(
        "rbind",
        lapply(
          pd$channel[!grepl("Unstained", pd$channel, ignore.case = TRUE)],
          function(z) {
            # SPILLOVER COEFICIENTS FOR CHANNEL
            sp <- list()
            lapply(
              spill,
              function(q) {
                if(z %in% rownames(q)) {
                  sp <<- c(
                    sp, 
                    list(q[match_ind(z, rownames(q)), , drop = FALSE])
                  )
                }
              }
            )
            # DUPLICATE COEFFICIENTS FOR CHANNEL
            if(length(sp) > 1) {
              sp <- sp[[
                which.max(
                  LAPPLY(sp, "rowSums")
                )
              ]]
            } else {
              sp <- sp[[1]]
            }
            return(sp)
          }
        )
      )
    }
    
    # HYBRID METHOD - SPILLOVER REFINEMENT
    if(.grepl("^h", type, ignore.case = TRUE)) {
      message(
        "Iteratively refining spillover coefficients..."
      )
      spill <- .cyto_asp_spill_refine(
        cs_list,
        spill = list(coef = spill),
        trans = axes_trans,
        channels = channels,
        iter = iter,
        trim = 0 # USE MEDIANS OF NEGATIVE & POSITIVE POPULATIONS
      )
    }
    
  # AUTOSPILL - ROCA METHOD  
  } else {
    # MESSAGE
    message(
      "Computing spillover matrix using the Roca et al. (2021) method... \n"
    )
    # REFERENCE
    message(
      paste0(
        "Roca et al. (2021). AutoSpill is a principled framework that ",
        "simplifies the analysis of multichromatic flow cytometry data. Nature",
        " Communications 12(2890)."
      )
    )
    # DROP UNSTAINED CONTROLS
    if(any(.grepl("Unstained", pd$channel, ignore.case = TRUE))) {
      x <- cyto_select(
        x,
        channel = "Unstained",
        exclude = TRUE,
        exact = FALSE
      )
    }
    # EXPERIMENT DETAILS
    pd <- cyto_details(x)
    # EXTRACT DATA FROM BEST CONTROLS
    nms <- c()
    cs <- cytoset(
      structure(
        lapply(
          unique(pd$channel),
          function(z) {
            # FIND BEST CONTROL PER CHANNEL
            ind <- which(pd$channel == z)
            # MULTIPLE SINGLE COLOUR CONTROLS - MEDFI
            if(length(ind) > 1) {
              # COMPUTE MEDFI IN CHANNEL - PARENT
              medFI <- LAPPLY(
                ind,
                function(i) {
                  cyto_apply(
                    x[i],
                    parent = pd$parent[i],
                    FUN = "cyto_stat_median",
                    channels = z,
                    input = "matrix",
                    trans = axes_trans,
                    inverse = TRUE,
                    copy = TRUE, 
                    simplify = TRUE
                  )
                }
              )
              ind <- ind[which.max(medFI)]
            }
            # EXTRACT DATA
            nms <<- c(nms, cyto_names(x[ind]))
            cyto_data_extract(
              x[ind],
              parent = pd$parent[ind],
              format = "cytoframe",
              channels = channels, # ALL CHANNELS?
              trans = axes_trans,
              inverse = TRUE,
              copy = TRUE,
              events = events
            )[[1]][[1]]
          }
        ),
        names = nms
      )
    )
    # AUTOSPILL - SPILLOVER MATRIX
    spill <- .cyto_asp_spill(
      cs,
      channels = channels,
      trans = axes_trans, # PASS TRANSFORMERS
      iter = iter,
      trim = trim
    )
  }
  
  # FILL SPILLOVER TEMPLATE
  cols <- channels[channels %in% colnames(spill)]
  lapply(
    seq_len(nrow(spill)),
    function(z) {
      spill_mat[
        match(rownames(spill)[z], rownames(spill_mat)), 
        cols
      ] <<- spill[z, cols]
    }
  )
  
  # DEFAULT CSV FILENAME
  if (is.null(save_as)) {
    save_as <- cyto_file_name(
      paste0(
        format(
          Sys.Date(), 
          "%d%m%y"
        ), 
        "-Spillover-Matrix.csv"
      )
    )
  }
  
  # EXPORT SPILLOVER MATRIX TO CSV FILE
  if(!is.na(save_as)) {
    if (!cyto_class(save_as, "character")) {
      stop(
        "'save_as' should be the name of a csv file."
      )
    }
    write_to_csv(
      spill_mat, 
      save_as,
      row.names = TRUE
    )
  }
  
  # HEATMAP
  if(heatmap) {
    sp <- spill_mat
    if(is.null(rownames(sp))) {
      rownames(sp) <- colnames(sp)
    }
    diag(sp) <- NA
    # CONSTRUCT HEATMAP - USE CYTO_PLOT_HEATMAP?
    heat_map(
      sp,
      cell_col_empty = "black",
      cell_col_scale = .cyto_plot_point_col_scale(),
      title = "Spillover Matrix"
    )
  }
  
  return(spill_mat)
}
