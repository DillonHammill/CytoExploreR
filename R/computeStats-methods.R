#' Compute Statistics
#'
#' Calculate and export flow cytometry statistics.
#'
#' @param x object of class \code{\link[flowCore:flowFrame-class]{flowFrame}},
#'   \code{\link[flowCore:flowSet-class]{flowSet}} or
#'   \code{\link[flowWorkspace:GatingSet-class]{GatingSet}}.
#' @param ... additional method-specific arguments.
#'
#' @author Dillon Hammill, \email{Dillon.Hammill@anu.edu.au}
#'
#' @seealso \code{\link{computeStats,flowFrame-method}}
#' @seealso \code{\link{computeStats,flowSet-method}}
#' @seealso \code{\link{computeStats,GatingSet-method}}
#'
#' @export
setGeneric(name = "computeStats",
           def = function(x, ...){standardGeneric("computeStats")}
)

#' Compute Statistics - flowFrame Method
#'
#' Calculate and export flow cytometry statistics for a flowFrame.
#'
#' @param x object of class \code{\link[flowCore:flowFrame-class]{flowFrame}}.
#' @param channels names of of channels for which statistic should be
#'   calculated, set to all channels by default.
#' @param transList object of class
#'   \code{\link[flowCore:transformList-class]{transformList}} generated by
#'   \code{\link[flowCore:logicleTransform]{estimateLogicle}} used to transform
#'   the fluorescent channels of x. TransList is required to apply the inverse
#'   transformation such that the required statistics are returned on the
#'   original linear scale.
#' @param stat name of the statistic to calculate, options include
#'   \code{"count"}, \code{"freq"}, \code{"median"}, \code{"mode"},
#'   \code{"mean"}, \code{"geo mean"}, \code{"CV"} or \code{CVI}.
#' @param adjust smoothing parameter passed to
#'   \code{\link[stats:density]{density}} when calculating mode, set to 1.5 by
#'   default.
#'
#' @author Dillon Hammill, \email{Dillon.Hammill@anu.edu.au}
#'
#' @importFrom flowCore exprs inverseLogicleTransform transform
#' @importFrom stats median density sd
#'
#' @seealso \code{\link{computeStats,flowSet-method}}
#'
#' @export
setMethod(computeStats, signature = "flowFrame", definition = function(x, channels = NULL, transList = NULL, stat = "median", adjust = 1.5){

  # Assign x to fr
  fr <- x
  
  # Channels
  if(is.null(channels)){
    
    channels <- BiocGenerics::colnames(fr)
    
  }else{
    
    channels <- checkChannels(x = fr, channels = channels, plot = FALSE)
    
  }
  
  # Transformations
  if(is.null(transList) & stat %in% c("mean", "median","mode","geo mean","CV","CVI")){
    
    message("No transList supplied - statistics will be returned on current scale.")
    transList <- NULL
    
  }else if(!is.null(transList)){
    
    if(class(transList)[1] != "transformList"){
      
      stop(paste("Supplied transList should be of class transformList and not", class(transList),"."))
      
    }else{
      
      inv <- inverseLogicleTransform(transList)
      fr <- transform(fr, inv)
        
    }
    
  }
  
  # Extract data from fr
  fr.exprs <- exprs(fr)
  
  # Statistics
  if(stat == "count"){
    
    cnt <- data.frame(count = BiocGenerics::nrow(fr))
    rownames(cnt) <- fr@description$GUID
    
    return(cnt)
    
  }else if(stat %in% c("median", "mode","mean","CV","CVI")){
    
    # Calculate statistic
    sts <- lapply(channels, function(channel){
      
      if(stat == "mean"){
        
        mean(fr.exprs[, channel])
        
      }else if(stat == "median"){
        
        median(fr.exprs[, channel])
        
      }else if(stat == "mode"){
        
        d <- density(fr.exprs[,channel], adjust = adjust)
        d$x[d$y == max(d$y)]
        
      }else if(stat == "CV"){
        
        (sd(fr.exprs[, channel])/mean(fr.exprs[, channel]))*100
        
      }else if(stat == "CVI"){
        
        (1/(sd(fr.exprs[, channel])/mean(fr.exprs[, channel]))*100)
        
      }
      
    })
    names(sts) <- channels
    sts <- do.call(cbind, sts)
    rownames(sts) <- fr@description$GUID
    
    return(sts)
    
  }else if(stat == "geo mean"){
    
    # Don't transform calculate mean then inverse transform to get geo mean
    sts <- lapply(channels, function(channel){
      
      fr.exprs <- exprs(x)[,channel]
      
      # transList supplied
      if(!is.null(transList)){
        
        # Channel is already transformed
        if(channel %in% BiocGenerics::colnames(transList)){
          
          inv <- inverseLogicleTransform(transList)
          sts <- inv@transforms[[channel]]@f(mean(fr.exprs))
          
        # Channel has not been transformed
        }else if(!channel %in% BiocGenerics::colnames(transList)){

          sts <- exp(mean(log(fr.exprs)))
          
        }
       
      # No transList supplied 
      }else{
        
        sts <- exp(mean(log(fr.exprs)))
        
        if(is.nan(sts)){
          
          stop("Some channels have been transformed, supply the transformList to calculate the geometric mean.")
          
        }
        
      }
      
      return(sts)
      
    })
    sts <- do.call(cbind, sts)
    rownames(sts) <- fr@description$GUID
    colnames(sts) <- channels
  
  }
  
    return(sts)
  
})

#' Compute Statistics - flowSet Method
#'
#' Calculate and export flow cytometry statistics for a flowSet.
#'
#' @param x object of class \code{\link[flowCore:flowSet-class]{flowSet}}.
#' @param channels names of of channels for which statistic should be
#'   calculated, set to all channels by default.
#' @param transList object of class
#'   \code{\link[flowCore:transformList-class]{transformList}} generated by
#'   \code{\link[flowCore:logicleTransform]{estimateLogicle}} used to transform
#'   the fluorescent channels of x. TransList is required to apply the inverse
#'   transformation such that the required statistics are returned on the
#'   original linear scale.
#' @param stat name of the statistic to calculate, options include
#'   \code{"count"}, \code{"freq"}, \code{"median"}, \code{"mode"},
#'   \code{"mean"}, \code{"geo mean"}, \code{"CV"} or \code{CVI}.
#' @param adjust smoothing parameter passed to
#'   \code{\link[stats:density]{density}} when calculating mode, set to 1.5 by
#'   default.
#'
#' @author Dillon Hammill, \email{Dillon.Hammill@anu.edu.au}
#'
#' @importFrom flowCore exprs inverseLogicleTransform transform
#' @importFrom flowWorkspace pData
#'
#' @seealso \code{\link{computeStats,flowFrame-method}}
#' @seealso \code{\link{computeStats,GatingSet-method}}
#'
#' @export
setMethod(computeStats, signature = "flowSet", definition = function(x, channels = NULL, transList = NULL, stat = "median", adjust = 1.5){
  
  # Assign x to fs
  fs <- x
  
  # pData
  pdata <- as.data.frame(pData(fs))
  
  # computeStats
  sts <- fsApply(fs, function(fr){
    
    computeStats(fr, channels = channels, transList = transList, stat = stat, adjust = adjust)
    
  })
  
  # Structure of count statistics
  if(stat == "count"){
    
    sts <- do.call(rbind,sts)

  }
  
  # Merge with pdata
  pdata[,"name"] <- list(NULL)
  if(class(sts) == "list"){
    
    sts <- lapply(sts, function(x){
    
      cbind(pdata,x)
    
    })
    
  }else if(class(sts) == "data.frame"){
    
    sts <- lapply(list(sts), function(x){
      
      cbind(pdata,x)
      
    })
    
  }else if(class(sts) == "matrix"){
    
    sts <- lapply(list(sts), function(x){
      
      cbind(pdata,x)
      
    })
    
  }
  
  return(sts)
  
})

#' Compute Statistics - GatingSet Method
#'
#' Calculate and export flow cytometry statistics for a GatingSet.
#'
#' @param x object of class
#'   \code{\link[flowWorkspace:GatingSet-class]{GatingSet}}.
#' @param alias name(s) of the population(s) for which the statistic should be
#'   calculated.
#' @param parent name(s) of the parent population(s) used calculate population
#'   frequencies. The frequency of alias in each parent will be returned as a
#'   percentage.
#' @param channels names of of channels for which statistic should be
#'   calculated, set to all channels by default.
#' @param transList object of class
#'   \code{\link[flowCore:transformList-class]{transformList}} or
#'   \code{\link[flowWorkspace:transformerList]{transformerList}} generated by
#'   \code{\link[flowCore:logicleTransform]{estimateLogicle}} used to transform
#'   the fluorescent channels of x. TransList is required to apply the inverse
#'   transformation such that the required statistics are returned on the
#'   original linear scale.
#' @param stat name of the statistic to calculate, options include
#'   \code{"count"}, \code{"freq"}, \code{"median"}, \code{"mode"},
#'   \code{"mean"}, \code{"geo mean"}, \code{"CV"}, \code{CVI}, \code{"freq"}.
#' @param adjust smoothing parameter passed to
#'   \code{\link[stats:density]{density}} when calculating mode, set to 1.5 by
#'   default.
#' @param save logical indicating whether statistical results should be saved to
#'   a csv file.
#'
#' @author Dillon Hammill, \email{Dillon.Hammill@anu.edu.au}
#'
#' @importFrom flowCore exprs inverseLogicleTransform transform
#' @importFrom flowWorkspace getData sampleNames getTransformations
#' @importFrom utils write.csv
#'
#' @seealso \code{\link{computeStats,flowFrame-method}}
#' @seealso \code{\link{computeStats,flowSet-method}}
#'
#' @export
setMethod(computeStats, signature = "GatingSet", definition = function(x, alias = NULL, parent = NULL, channels = NULL, transList = NULL, stat = "median", adjust = 1.5, save = TRUE){
  
  # Assign x to gs
  gs <- x
  
  # transformerList?
  if(!is.null(transList)){
    
    if(class(transList)[1] == "transformerList"){
      
      transList <- transformList(names(transList), lapply(transList, `[[`, "transform"))
      
    }
    
  }  
    
  # Get transList if not supplied
  if(is.null(transList)){
    
    transList <- transformList(names(getTransformations(gs[[1]])), getTransformations(gs[[1]]))
    
  }

  # Extract population(s)
  fs.lst <- lapply(alias, function(x) getData(gs, x))
  
  # Population frequencies
  if(stat == "freq"){
    
    sts <- lapply(fs.lst, function(fs){
      
      as.data.frame(computeStats(fs, channels = channels, transList = transList, stat = "count", adjust = 1.5))
      
    })
    names(sts) <- alias
    
    # Get parent counts
    prnts <- lapply(parent, function(x){
      
      fs <- getData(gs, x)
      as.data.frame(computeStats(fs, channels = channels, transList = transList, stat = "count", adjust = 1.5))
      
    })
    names(prnts) <- parent
    
    sts <- lapply(sts, function(x){
      
      m <- matrix(rep(x[,"count"], length(parent)), ncol = length(parent), byrow = FALSE)
      colnames(m) <- rep("count", length(parent))
      sts <- cbind(x,m)
      return(sts)

    })
    
    sts <- lapply(sts, function(x){
      
      lapply(seq(1,length(parent), 1), function(y){
        
        N <- ncol(x) - length(parent)
        x[,(N + y)] <<- (x[,(N + y)]/prnts[[y]][,"count"])*100
        colnames(x)[(N + y)] <<- parent[y]
        
      })
      
      return(x)
    })
    
  }else{
    
    sts <- lapply(fs.lst, function(fs){
      
      sts <- computeStats(fs, channels = channels, transList = transList, stat = stat, adjust = 1.5)
      clnms <- colnames(sts[[1]])
      sts <- as.data.frame(sts)
      colnames(sts) <- clnms
      return(sts)
      
    })
    names(sts) <- alias
    
  }
  
  # Save to csv file
  if(save == TRUE){
    
    lapply(1:length(alias), function(x){
      
      write.csv(sts[[x]], paste(alias[x],stat, ".csv"))
      
    })
    
  }
  
  return(sts)
  
})
